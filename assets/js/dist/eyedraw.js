/* global jQuery:false */

/**
 * Namespace for all EyeDraw classes
 * @namespace ED
 */
var ED = ED || {};

/**
 * Radius of inner handle displayed with selected doodle
 * @constant
 */
ED.handleRadius = 15;

/**
 * Distance in doodle plane moved by pressing an arrow key
 * @constant
 */
ED.arrowDelta = 4;

/**
 * SquiggleWidth
 */
ED.squiggleWidth = {
	Thin: 4,
	Medium: 12,
	Thick: 20
};

/**
 * SquiggleStyle
 */
ED.squiggleStyle = {
	Outline: 0,
	Solid: 1
};

/**
 * Flag to detect double clicks
 */
ED.recentClick = false;

/**
 * Eye (Some doodles behave differently according to side)
 */
ED.eye = {
	Right: 0,
	Left: 1
};

/**
 * Draw function mode (Canvas pointInPath function requires a path)
 */
ED.drawFunctionMode = {
	Draw: 0,
	HitTest: 1
};

/**
 * Mouse dragging mode
 */
ED.Mode = {
	None: 0,
	Move: 1,
	Scale: 2,
	Arc: 3,
	Rotate: 4,
	Apex: 5,
	Handles: 6,
	Draw: 7,
	Select: 8,
	Size: 9
};

/**
 * Handle ring
 */
ED.handleRing = {
	Inner: 0,
	Outer: 1
};

/**
 * Flag to indicate when the drawing has been modified
 */
ED.modified = false;

/*
 * Chris Raettig's function for getting accurate mouse position in all browsers
 *
 * @param {Object} obj Object to get offset for, usually canvas object
 * @returns {Object} x and y values of offset
 */
ED.findOffset = function(obj, curleft, curtop) {
	if (obj.offsetParent) {
		do {
			curleft += obj.offsetLeft;
			curtop += obj.offsetTop;
		} while (!!(obj = obj.offsetParent));
		return {
			left: curleft,
			top: curtop
		};
	}
};

ED.findPosition = function(obj, event) {
	var offset;
	if (typeof jQuery !== 'undefined') {
		offset = jQuery(obj).offset();
	} else {
		offset = ED.findOffset(obj, 0, 0);
	}
	return {
		x: event.pageX - offset.left,
		y: event.pageY - offset.top
	};
};

/*
 * Function to test whether a Javascript object is empty
 *
 * @param {Object} _object Object to apply test to
 * @returns {Bool} Indicates whether object is empty or not
 */
ED.objectIsEmpty = function(_object) {
	for (var property in _object) {
		if (_object.hasOwnProperty(property)) {
			return false;
		}
	}

	return true;
};

/*
 * Returns true if browser is firefox
 *
 * @returns {Bool} True is browser is firefox
 */
ED.isFirefox = function() {
	var index = 0;
	var ua = window.navigator.userAgent;
	index = ua.indexOf("Firefox");

	if (index > 0) {
		return true;
	} else {
		return false;
	}
};

// Checks that the value is numeric http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric
ED.isNumeric = function(_value) {
	return (_value - 0) == _value && _value.length > 0;
};

/**
 * Returns 'true' remainder of a number divided by a modulus (i.e. always positive, unlike x%y)
 *
 * @param {Float} _x number
 * @param {Float} _y modulus
 * @returns {Float} True modulus of _x/_y
 */
ED.Mod = function Mod(_x, _y) {
	return _x - Math.floor(_x / _y) * _y;
};

/**
 * Converts an angle (positive or negative) into a positive angle (ie a bearing)
 *
 * @param {Float} _angle Angle in radians
 * @returns {Float} Positive angle between 0 and 2 * Pi
 */
ED.positiveAngle = function(_angle) {
	var circle = 2 * Math.PI;

	// First make it positive
	while (_angle < 0) {
		_angle += circle;
	}

	// Return remainder
	return _angle % circle;
};

/**
 * Error handler
 *
 * @param {String} _class Class
 * @param {String} _method Method
 * @param {String} _message Error message
 */
ED.errorHandler = function(_class, _method, _message) {
	console.trace('EYEDRAW ERROR! class: [' + _class + '] method: [' + _method + '] message: [' + _message + ']');
};

/**
 * Return a string with the first letter as uppercase.
 * @param  {String} str The string.
 */
ED.firstLetterToUpperCase = function(str) {
	return str.charAt(0).toUpperCase() + str.slice(1);
};

/**
 * Additional function for String object
 *
 * @returns {String} String with first letter made lower case, unless part of an abbreviation
 */
ED.firstLetterToLowerCase = function(str) {
	var secondChar = str.charAt(1);

	if (secondChar === secondChar.toUpperCase()) {
		return str;
	} else {
		return str.charAt(0).toLowerCase() + str.slice(1);
	}
};

/**
 * Additional function for String object
 *
 * @returns {String} String with last ', ' replaced with ', and '
 */
ED.addAndAfterLastComma = function(str) {
	// Search backwards from end of string for comma
	var found = false;
	for (var pos = str.length - 1; pos >= 0; pos--) {
		if (str.charAt(pos) === ',') {
			found = true;
			break;
		}
	}

	if (found) {
		return str.substring(0, pos) + ", and" + str.substring(pos + 1, str.length);
	} else {
		return str;
	}
};

/**
 * Default titles
 * @type {Object}
 */
ED.titles = {};

/**
 * Set titles.
 * @param {Object} titles An object containing the doodle titles.
 */
ED.setTitles = function(titles) {
	$.extend(this.titles, titles);
};

/**
 * Array of 200 random numbers
 */
ED.randomArray = [0.6570, 0.2886, 0.7388, 0.1621, 0.9896, 0.0434, 0.1695, 0.9099, 0.1948, 0.4433, 0.1580, 0.7392, 0.8730, 0.2165, 0.7138, 0.6316, 0.3425, 0.2838, 0.4551, 0.4153, 0.7421, 0.3364, 0.6087, 0.1986, 0.5764, 0.1952, 0.6179, 0.6699, 0.0903, 0.2968, 0.2684, 0.9383, 0.2488, 0.4579, 0.2921, 0.9085, 0.7951, 0.4500, 0.2255, 0.3366, 0.6670, 0.7300, 0.5511, 0.5623, 0.1376, 0.5553, 0.9898, 0.4317, 0.5922, 0.6452, 0.5008, 0.7077, 0.0704, 0.2293, 0.5697, 0.7415, 0.1557, 0.2944, 0.4566, 0.4129, 0.2449, 0.5620, 0.4105, 0.5486, 0.8917, 0.9346, 0.0921, 0.7998, 0.7717, 0.0357, 0.1179, 0.0168, 0.1520, 0.5187, 0.3466, 0.1663, 0.5935, 0.7524, 0.8410, 0.1859, 0.6012, 0.8171, 0.9272, 0.3367, 0.8133, 0.4868, 0.3665, 0.9625, 0.7839, 0.3052, 0.1651, 0.6414, 0.7361, 0.0065, 0.3267, 0.0554, 0.3389, 0.8967, 0.8777, 0.0557, 0.9201, 0.6015, 0.2676, 0.3365, 0.2606, 0.0989, 0.2085, 0.3526, 0.8476, 0.0146, 0.0190, 0.6896, 0.5198, 0.9871, 0.0288, 0.8037, 0.6741, 0.2148, 0.2584, 0.8447, 0.8480, 0.5557, 0.2480, 0.4736, 0.8869, 0.1867, 0.3869, 0.6871, 0.1011, 0.7561, 0.7340, 0.1525, 0.9968, 0.8179, 0.7103, 0.5462, 0.4150, 0.4187, 0.0478, 0.6511, 0.0386, 0.5243, 0.7271, 0.9093, 0.4461, 0.1264, 0.0756, 0.9405, 0.7287, 0.0684, 0.2820, 0.4059, 0.3694, 0.7641, 0.4188, 0.0498, 0.7841, 0.9136, 0.6210, 0.2249, 0.9935, 0.9709, 0.0741, 0.6218, 0.3166, 0.2237, 0.7754, 0.4191, 0.2195, 0.2935, 0.4529, 0.9112, 0.9183, 0.3275, 0.1856, 0.8345, 0.0442, 0.6297, 0.9030, 0.4689, 0.9512, 0.2219, 0.9993, 0.8981, 0.1018, 0.9362, 0.6426, 0.4563, 0.1267, 0.7889, 0.5057, 0.8588, 0.4669, 0.0687, 0.6623, 0.3681, 0.8152, 0.9004, 0.0822, 0.3652];
/**
 * @summary Contains the core classes for EyeDraw
 * @author <a href="mailto:bill.aylward@mac.com">Bill Aylward</a>
 * @version 1.2
 *
 * Modification date: 28th March 2012
 * Copyright 2011 OpenEyes
 *
 * This file is part of OpenEyes.
 *
 * OpenEyes is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenEyes is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenEyes.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @namespace ED
 * @description Namespace for all EyeDraw classes
 */
var ED = ED || {};

/**
 * A Drawing consists of one canvas element displaying one or more doodles;
 * Doodles are drawn in the 'doodle plane' consisting of a (nominal) 1001 pixel square grid -500 to 500) with central origin, and negative Y upwards
 * Affine transforms are used to convert points in the doodle plane to the canvas plane, the plane of the canvas element;
 * Each doodle contains additional transforms to handle individual position, rotation, and scale.
 * @namespace ED.Drawing
 * @memberOf ED
 * @property {Canvas} canvas A canvas element used to edit and display the drawing
 * @property {Eye} eye Right or left eye (some doodles display differently according to side)
 * @property {Bool} isEditable Flag indicating whether canvas is editable or not
 * @property {Context} context The 2d context of the canvas element
 * @property {Array} doodleArray Array of doodles in the drawing
 * @property {AffineTransform} transform Transform converts doodle plane -> canvas plane
 * @property {AffineTransform} inverseTransform Inverse transform converts canvas plane -> doodle plane
 * @property {Doodle} selectedDoodle The currently selected doodle, null if no selection
 * @property {Bool} mouseIsDown Flag indicating whether mouse is down in canvas
 * @property {Mode} mode The current mouse dragging mode
 * @property {Point} lastMousePosition Last position of mouse in canvas coordinates
 * @property {Image} image Optional background image
 * @property {Int} doubleClickMilliSeconds Duration of double click
 * @property {Bool} newPointOnClick Flag indicating whether a mouse click will create a new PointInLine doodle
 * @property {Bool} completeLine Flag indicating whether to draw an additional line to the first PointInLine doodle
 * @property {Float} scale Scaling of transformation from canvas to doodle planes, preserving aspect ratio and maximising doodle plnae
 * @property {Float} globalScaleFactor Factor used to scale all added doodles to this drawing, defaults to 1
 * @property {Int} scrollValue Current value of scrollFactor
 * @property {Int} lastDoodleId id of last doodle to be added
 * @property {Bool} isActive Flag indicating that the mouse is interacting with the drawing
 * @property {Bool} isNew Flag indicating that the drawing is new (false after doodles loaded from an input string)
 * @property {Bool} isReady Flag indicating that the drawing has finished loading (set by widget controller)
 * @property {Bool} showDoodleControls Flag indicating whether doodles should display controls when selected
 * @property {Float} scaleOn Options for setting scale to either width or height
 * @param {Canvas} _canvas Canvas element
 * @param {Eye} _eye Right or left eye
 * @param {String} _idSuffix String suffix to identify HTML elements related to this drawing
 * @param {Bool} _isEditable Flag indicating whether canvas is editable or not
 * @param {Array} _options Associative array of optional parameters
 */

ED.Drawing = function(_canvas, _eye, _idSuffix, _isEditable, _options) {

	// Check we're working with an actual canvas HTML element.
	if (!_canvas || !(_canvas instanceof HTMLCanvasElement)) {
		ED.errorHandler('ED.Drawing', 'constructor', 'Invalid canvas element');
		return;
	}

	// Defaults for optional parameters
	var offsetX = 0;
	var offsetY = 0;
	var toImage = false;
	var globalScaleFactor = 1;
	var toggleScaleFactor = 0;

	this.graphicsPath = 'assets/img';
	this.scaleOn = 'height';

	// If optional parameters exist, use them instead
	if (typeof(_options) != 'undefined') {
		if (_options['offsetX']) offsetX = _options['offsetX'];
		if (_options['offsetY']) offsetY = _options['offsetY'];
		if (_options['toImage']) toImage = _options['toImage'];
		if (_options['graphicsPath']) this.graphicsPath = _options['graphicsPath'];
		if (_options['scaleOn']) this.scaleOn = _options['scaleOn'];
		if (_options['scale']) globalScaleFactor = _options['scale'];
		if (_options['toggleScale']) toggleScaleFactor = _options['toggleScale'];
	}

	// Initialise properties
	this.drawingName = _options.drawingName;
	this.canvas = _canvas;
	this.eye = _eye;
	this.idSuffix = _idSuffix;
	this.isEditable = _isEditable;
	this.hoverTimer = null;
	this.convertToImage = (toImage && !this.isEditable) ? true : false;
	this.context = this.canvas.getContext('2d');
	this.doodleArray = new Array();
	this.bindingArray = new Array();
	this.listenerArray = new Array();
	this.transform = new ED.AffineTransform();
	this.inverseTransform = new ED.AffineTransform();
	this.selectedDoodle = null;
	this.mouseIsDown = false;
	this.doubleClick = false;
	this.mode = ED.Mode.None;
	this.lastMousePosition = new ED.Point(0, 0);
	this.doubleClickMilliSeconds = 250;
	this.readyNotificationSent = false;
	this.newPointOnClick = false;
	this.completeLine = false;
	this.globalScaleFactor = globalScaleFactor;
	this.toggleScaleFactor = toggleScaleFactor;
	this.origScaleLevel = globalScaleFactor;
	this.scrollValue = 0;
	this.lastDoodleId = 0;
	this.isActive = false;
	this.isNew = true;
	this.isReady = false;
	this.showDoodleControls = false;
	this.onReadyCommands = [];
	this.resetDoodleSet = false;
	this.lastTouchPoint = undefined;

	// Freehand drawing properties NB from November 2013 moved to Freehand doodle
//	this.squiggleColour = new ED.Colour(0, 255, 0, 1);
//	this.squiggleWidth = ED.squiggleWidth.Medium;
//	this.squiggleStyle = ED.squiggleStyle.Outline;

	// Put settings into display canvas
//	this.refreshSquiggleSettings();

	// Associative array of bound element no doodle values (ie value associated with deleted doodle)
	this.boundElementDeleteValueArray = new Array();

	// Grab the canvas parent element
	this.canvasParent = this.canvas.parentElement;

	// Array of objects requesting notifications
	this.notificationArray = new Array();

	// Optional tooltip (this property will be null if a span element with this id not found
	this.canvasTooltip = document.getElementById(this.canvas.id + 'Tooltip');

	// Make sure doodle plane fits within canvas (Height priority)
	if (this.scaleOn == 'height') {
		this.scale = this.canvas.height / 1001;
	} else {
		this.scale = this.canvas.width / 1001;
	}

	// Calculate dimensions of doodle plane
	this.doodlePlaneWidth = this.canvas.width / this.scale;
	this.doodlePlaneHeight = this.canvas.height / this.scale;

	// Array of images to be preloaded
	this.imageArray = new Array();
	this.imageArray['LatticePattern'] = new Image();
	this.imageArray['CribriformPattern'] = new Image();
	this.imageArray['CribriformPatternSmall'] = new Image();
	this.imageArray['CryoPattern'] = new Image();
	this.imageArray['AntPVRPattern'] = new Image();
	this.imageArray['LaserPattern'] = new Image();
	this.imageArray['FuchsPattern'] = new Image();
	this.imageArray['PSCPattern'] = new Image();
	this.imageArray['MeshworkPatternLight'] = new Image();
	this.imageArray['MeshworkPatternMedium'] = new Image();
	this.imageArray['MeshworkPatternHeavy'] = new Image();
	this.imageArray['NewVesselPattern'] = new Image();
	this.imageArray['OedemaPattern'] = new Image();
	this.imageArray['OedemaPatternBullous'] = new Image();
	this.imageArray['BrownSpotPattern'] = new Image();
	this.imageArray['TranslucentPattern'] = new Image();

	// Set transform to map from doodle to canvas plane
	this.transform.translate(this.canvas.width / 2, this.canvas.height / 2);
	this.transform.scale(this.scale, this.scale);

	// Set inverse transform to map the other way
	this.inverseTransform = this.transform.createInverse();

	// Initialise canvas context transform by calling clear() method
	this.clear();

	// Selection rectangle
	this.selectionRectangleIsBeingDragged = false;
	this.selectionRectangleStart = new ED.Point(0, 0);
	this.selectionRectangleEnd = new ED.Point(0, 0);

	// Add event listeners (NB within the event listener 'this' refers to the canvas, NOT the drawing instance)
	if (this.isEditable) {
		var drawing = this;

		// Mouse listeners
		this.canvas.addEventListener('mousedown', function(e) {
			var position = ED.findPosition(this, e);
			var point = new ED.Point(position.x, position.y);
			drawing.mousedown(point);
		}, false);

		this.canvas.addEventListener('mouseup', function(e) {
			var position = ED.findPosition(this, e);
			var point = new ED.Point(position.x, position.y);
			drawing.mouseup(point);
		}, false);

		this.canvas.addEventListener('mousemove', function(e) {
			var position = ED.findPosition(this, e);
			var point = new ED.Point(position.x, position.y);
			drawing.mousemove(point);
		}, false);

		this.canvas.addEventListener('mouseover', function(e) {
			var position = ED.findPosition(this, e);
			var point = new ED.Point(position.x, position.y);
			drawing.mouseover(point);
		}, false);

		this.canvas.addEventListener('mouseout', function(e) {
			var position = ED.findPosition(this, e);
			var point = new ED.Point(position.x, position.y);
			drawing.mouseout(point);
		}, false);

		document.body.addEventListener('mousedown', function onBodyMouseDown(e) {

			// Deselect all doodles if the user clicks anywhere on the page that is
			// not the canvas itself, nor the doodle popup, nor any toolbar buttons.

			var elem = e.target;
			var isEyeDrawElement = false;

			var ignore = '(' + [
				'ed-doodle-popup',
				'ed-button',
				'ed-canvas',
				'ed_canvas',
				'ed-selected-doodle-select',
			].join(')|(') + ')';

			do {
				isEyeDrawElement = new RegExp(ignore).test(elem.className);
			} while (
				(elem = elem.parentNode) && (elem !== document.body) && (!isEyeDrawElement)
			);

			if (!isEyeDrawElement) {
				drawing.deselectDoodles();
			}
		}, false);

		//				this.canvas.addEventListener('mousewheel', function(e) {
		//																		 e.preventDefault();
		//																		 drawing.selectNextDoodle(e.wheelDelta);
		//																		 }, false);

		// iOS listeners
		this.canvas.addEventListener('touchstart', function(e) {
			if (e.targetTouches[0] !== undefined) {
				var canvas_pos = drawing.getPositionOfElement(drawing.canvas);
				var point = new ED.Point(e.targetTouches[0].pageX - canvas_pos[0] - this.offsetLeft, e.targetTouches[0].pageY - canvas_pos[1]);
				e.preventDefault();
			} else {
				ED.errorHandler('ED.Drawing', 'Class', 'Touches undefined: ');
			}
			this.lastTouchPoint = point;
			drawing.mousedown(point);
		}, false);

		this.canvas.addEventListener('touchend', function(e) {
            if (this.lastTouchPoint !== undefined) {
				drawing.mouseup(this.lastTouchPoint);
				this.lastTouchPoint = undefined;
			}
		}, false);

		this.canvas.addEventListener('touchmove', function(e) {
			if (e.targetTouches[0] !== undefined) {
				var canvas_pos = drawing.getPositionOfElement(drawing.canvas);
				var point = new ED.Point(e.targetTouches[0].pageX - canvas_pos[0] - this.offsetLeft, e.targetTouches[0].pageY - canvas_pos[1]);
                this.lastTouchPoint = point;
				drawing.mousemove(point);
			}
		}, false);

		// Keyboard listener
		window.addEventListener('keydown', function(e) {
			if (document.activeElement === _canvas) drawing.keydown(e);
		}, true);

		// Stop browser stealing double click to select text
		this.canvas.onselectstart = function() {
			return false;
		}
	}
};

ED.Drawing.prototype.getPositionOfElement = function(element) {
		var x=0;
		var y=0;
		while(true){
				x += element.offsetLeft;
				y += element.offsetTop;
				if(element.offsetParent === null){
						break;
				}
				element = element.offsetParent;
		}
		return [x, y];
};

/**
 * Carries out initialisation of drawing (called after a controller has been instantiated to ensure notification)
 */
ED.Drawing.prototype.init = function() {
	// Start loading of texture images (will send ready notification when ready)
	/* FIXME */
	this.preLoadImagesFrom(this.graphicsPath + '/' + 'patterns/');
};

/**
 * Replaces the canvas element inline with a PNG image, useful for printing
 */
ED.Drawing.prototype.replaceWithImage = function() {
	// Create a new image element
	var img = document.createElement("img");

	// Base64 encoded PNG version of the canvas element
	img.setAttribute('src', this.canvas.toDataURL('image/png'));

	// Removes canvas and hidden input element (+ any other children) as they will be replaced with an image
	if (this.canvasParent.hasChildNodes()) {
		while (this.canvasParent.childNodes.length >= 1) {
			this.canvasParent.removeChild(this.canvasParent.firstChild);
		}
	}

	this.canvasParent.appendChild(img);
};

/**
 * Preloads image files
 *
 * @param {String} Relative path to directory where images are stored
 */
ED.Drawing.prototype.preLoadImagesFrom = function(_path) {
	var drawing = this;
	var ready = false;

	// Iterate through array loading each image, calling checking function from onload event
	for (var key in this.imageArray) {
		// This line picked up by javadoc toolkit - @ignore does not work
		this.imageArray[key].onload = function() {
			drawing.checkAllLoaded();
		};

		// Error handling
		this.imageArray[key].onerror = (function(key){
			return function() {
				ED.errorHandler('ED.Drawing', 'preLoadImagesFrom', 'Error loading image file "' + key + '.gif" from directory: "' + _path + '"');
			}
		}(key));

		// Attempt to load image file
		this.imageArray[key].src = _path + key + '.gif';
	}
};

/**
 * Checks all images are loaded then sends a notification
 */
ED.Drawing.prototype.checkAllLoaded = function() {
	// Set flag to check loading
	var allLoaded = true;

	// Iterate through array loading each image, checking all are loaded
	for (var key in this.imageArray) {
		var imageLoaded = false;
		if (this.imageArray[key].width > 0) imageLoaded = true;

		// Check all are loaded
		allLoaded = allLoaded && imageLoaded;
	}

	// If all are loaded, send notification
	if (allLoaded) {
		if (!this.readyNotificationSent) {
			//this.onready();
			this.readyNotificationSent = true;

			// Notify
			this.notify("ready");
		}
	}
};

/**
 * Registers an object to receive notifications
 *
 * @param {Object} _object The object requesting notification
 * @param {String} _methodName The method in the receiving object which is called for a notification. Defaults to 'notificationHandler'
 * @param {Array} _notificationList Array of strings listing the notifications the object is interested in. If empty, receives all.
 */
ED.Drawing.prototype.registerForNotifications = function(_object, _methodName, _notificationList) {

	// Put in default values for optional parameters
	if (typeof(_methodName) == 'undefined') {
		_methodName = 'notificationHandler';
	}
	if (typeof(_notificationList) == 'undefined') {
		_notificationList = new Array();
	}

	// Add object and details to notification array
	this.notificationArray.push({
		object: _object,
		methodName: _methodName,
		notificationList: _notificationList
	});
};

/**
 * Unregisters an object for notifications	***TODO*** Need method of identifying objects for this to work
 *
 * @param {object} _object The object requesting notification
 */
ED.Drawing.prototype.unRegisterForNotifications = function(_object) {
	// Get index of object in array
	var index = this.notificationArray.indexOf(_object);

	// If its there, remove it
	if (index >= 0) {
		this.notificationArray.splice(index, 1);
	}
};

/**
 * Send notifications to all registered objects
 *
 * @param {String} _eventName Name of event
 * @param {Object} _object An optional object which may accompany an event containing additional information
 */
ED.Drawing.prototype.notify = function(_eventName, _object) {
	// Create array containing useful information
	var messageArray = {
		eventName: _eventName,
		selectedDoodle: this.selectedDoodle,
		object: _object
	};

	// Call method on each registered object
	for (var i = 0; i < this.notificationArray.length; i++) {

		// Assign to variables to make code easier to read
		var list = this.notificationArray[i]['notificationList'];
		var object = this.notificationArray[i]['object'];
		var methodName = this.notificationArray[i]['methodName'];

		// Check that event is in notification list for this object, or array is empty implying all notifications
		if (list.length == 0 || list.indexOf(_eventName) >= 0) {
			// Check method exists
			if (typeof(object[methodName]) != 'undefined') {
				// Call registered object using specified method, and passing message array
				object[methodName].apply(object, [messageArray]);
			} else {
				ED.errorHandler('ED.Drawing', 'notify', 'Attempt to call undefined notification handler method');
			}
		}
	}
};

/**
 * Loads doodles from an HTML element
 *
 * @param {string} _id Id of HTML input element containing JSON data
 */
ED.Drawing.prototype.loadDoodles = function(_id) {
	// Get element containing JSON string
	var sourceElement = document.getElementById(_id);

	// If it exists and contains something, load it
	if (sourceElement && sourceElement.value.length > 0) {
		var doodleSet = window.JSON.parse(sourceElement.value);
		this.resetDoodleSet = doodleSet;
		this.load(doodleSet);

		// Set isNew flag
		this.isNew = false;

		// Notify
		this.notify("doodlesLoaded");
	}
};

/**
 * Loads doodles from passed set in JSON format into doodleArray
 *
 * @param {Set} _doodleSet Set of doodles from server
 */
ED.Drawing.prototype.load = function(_doodleSet) {
	// Iterate through set of doodles and load into doodle array
	for (var i = 0; i < _doodleSet.length; i++) {
		// Check that class definition exists, otherwise skip it
		if (ED[_doodleSet[i].subclass] === undefined) {
			ED.errorHandler('ED.Drawing', 'load', 'Unrecognised doodle: ' + _doodleSet[i].subclass);
			break;
		}

		// Instantiate a new doodle object with parameters from doodle set
		this.doodleArray[i] = new ED[_doodleSet[i].subclass](this, _doodleSet[i]);
		this.doodleArray[i].id = i;
	}

	// Sort array by order (puts back doodle first)
	this.doodleArray.sort(function(a, b) {
		return a.order - b.order
	});
};

/**
 * Creates string containing drawing data in JSON format with surrounding square brackets
 *
 * @returns {String} Serialized data in JSON format with surrounding square brackets
 */
ED.Drawing.prototype.save = function() {
	// Store current data in textArea
	return '[' + this.json() + ']';
};

/**
 * Creates string containing drawing data in JSON format
 *
 * @returns {String} Serialized data in JSON format
 */
ED.Drawing.prototype.json = function() {
	var s = "";

	// Go through each member of doodle array, encoding it
	for (var i = 0; i < this.doodleArray.length; i++) {
		var doodle = this.doodleArray[i];
		if (doodle.isSaveable) {
			s = s + doodle.json() + ",";
		}
	}

	// Remove last comma
	s = s.substring(0, s.length - 1);

	return s;
};

/**
 * Draws all doodles for this drawing
 */
ED.Drawing.prototype.drawAllDoodles = function() {
	// Draw any connecting lines
	var ctx = this.context;
	ctx.beginPath();
	var started = false;
	var startPoint;

	for (var i = 0; i < this.doodleArray.length; i++) {
		if (this.doodleArray[i].isPointInLine) {
			// Start or draw line
			if (!started) {
				ctx.moveTo(this.doodleArray[i].originX, this.doodleArray[i].originY);
				started = true;
				startPoint = new ED.Point(this.doodleArray[i].originX, this.doodleArray[i].originY);
			} else {
				ctx.lineTo(this.doodleArray[i].originX, this.doodleArray[i].originY);
			}
		}
	}

	// Optionally add line to start
	if (this.completeLine && typeof(startPoint) != 'undefined') {
		ctx.lineTo(startPoint.x, startPoint.y);
	}

	// Draw lines
	if (started) {
		ctx.lineWidth = 4;
		ctx.strokeStyle = "rgba(20,20,20,1)";
		ctx.stroke();
	}

	// Draw doodles
	for (var i = 0; i < this.doodleArray.length; i++) {
		// Save context (draw method of each doodle may alter it)
		this.context.save();

		// Draw doodle
		this.doodleArray[i].draw();

		// Restore context
		this.context.restore();
	}
};

/**
 * Responds to mouse down event in canvas, cycles through doodles from front to back.
 * Selected doodle is first selectable doodle to have click within boundary path.
 * Double clicking on a selected doodle promotes it to drawing mode (if is drawable)
 *
 * @event Drawing#mousedown
 * @param {Point} _point Coordinates of mouse in canvas plane
 */
ED.Drawing.prototype.mousedown = function(_point) {
	// Set flag to indicate dragging can now take place
	this.mouseIsDown = true;
	
	var doodle = this.selectedDoodle;

	// Detect double click
	if (ED.recentClick) {
		this.doubleClick = true;
	}
	ED.recentClick = true;
	var t = setTimeout("ED.recentClick = false;", this.doubleClickMilliSeconds);

	// Set flags
	var found = false;
	this.lastSelectedDoodle = this.selectedDoodle;
	this.selectedDoodle = null;
	// Cycle through doodles from front to back doing hit test
	for (var i = this.doodleArray.length - 1; i > -1; i--) {
		if (!found) {
			// Save context (draw method of each doodle may alter it)
			this.context.save();

			// Successful hit test?
			if (this.doodleArray[i].draw(_point)) {
				if (this.doodleArray[i].isSelectable) {
					// If double clicked, go into drawing mode
					if (this.doubleClick && this.doodleArray[i].isSelected && this.doodleArray[i].isDrawable) {
						this.doodleArray[i].isForDrawing = true;
					}

					found = true;
					this.selectDoodle(this.doodleArray[i]);

					// If for drawing, mouse down starts a new squiggle
					if (!this.doubleClick && this.doodleArray[i].isForDrawing) {
						// Add new squiggle
						this.doodleArray[i].addSquiggle();
					}
					
				}
			}
			// Ensure that unselected doodles are marked as such
			else {
				this.doodleArray[i].isSelected = false;
				this.doodleArray[i].isForDrawing = false;
			}

			// Restore context
			this.context.restore();
		} else {
			this.doodleArray[i].isSelected = false;
			this.doodleArray[i].isForDrawing = false;
		}

		// Ensure drag flagged is off for each doodle
		this.doodleArray[i].isBeingDragged = false;
	}

	// If no doodles selected, run onDeselection code for last doodle
	if (!this.selectedDoodle) {
		if (this.lastSelectedDoodle) this.lastSelectedDoodle.onDeselection();
	}

	// Notify if doodle is deselected ***TODO*** move to onDeselection code for doodle to make this trigger for all deselections
	if (this.lastSelectedDoodle) {
		if (this.lastSelectedDoodle != this.selectedDoodle) {
			// Notify
			this.notify("doodleDeselected");
		}
	}

	// Drawing
	if (this.newPointOnClick && !found) {
		var mousePosDoodlePlane = this.inverseTransform.transformPoint(_point);

		var newPointInLine = this.addDoodle('PointInLine');
		newPointInLine.originX = mousePosDoodlePlane.x;
		newPointInLine.originY = mousePosDoodlePlane.y;
	}

	// Multiple Selecting
	/*
		if (!found)
		{
				this.mode = ED.Mode.Select;
				this.selectionRectangleStart = this.inverseTransform.transformPoint(_point);
		}
		 */

	// Repaint
	this.repaint();

	// Notify
	this.notify("mousedown", {
		drawing: this,
		point: _point
	});
};


/**
 * Responds to mouse down event in canvas, cycles through doodles from front to back.
 * Selected doodle is first selectable doodle to have click within boundary path.
 * Double clicking on a selected doodle promotes it to drawing mode (if is drawable)
 *
 * @event
 * @param {Point} _point Coordinates of mouse in canvas plane
 */
ED.Drawing.prototype.click = function(_point) {
	// Notify
	this.notify("click", {
		drawing: this,
		point: _point
	});
}


/**
 * Responds to mouse move event in canvas according to the drawing mode
 *
 * @event Drawing#mousemove
 * @param {Point} _point coordinates of mouse in canvas plane
 */
ED.Drawing.prototype.mousemove = function(_point) {
	// Notify
	this.notify("mousemove", {
		drawing: this,
		point: _point
	});

	// Get selected doodle
	var doodle = this.selectedDoodle;

	if (doodle && this.selectedDoodle.isLocked) {
		return;
	}

	// Draw selection rectangle
	/*
		if (this.mode == ED.Mode.Select)
		{
				if (!this.selectionRectangleIsBeingDragged)
				{
						this.selectionRectangleIsBeingDragged = true;
				}

				this.selectionRectangleEnd = this.inverseTransform.transformPoint(_point);
				this.repaint();
		}
		*/

	// Store action for notification
	var action = "";

	// Start the hover timer (also resets it)
	this.startHoverTimer(_point);
	// Only drag if mouse already down and a doodle selected
	if (this.mouseIsDown && doodle != null) {

		// Dragging not started
		if (!doodle.isBeingDragged) {
			// Flag start of dragging manoeuvre
			doodle.isBeingDragged = true;
		}
		// Dragging in progress
		else {
			// Get mouse position in doodle plane
			var mousePosDoodlePlane = this.inverseTransform.transformPoint(_point);
			var lastMousePosDoodlePlane = this.inverseTransform.transformPoint(this.lastMousePosition);

			// Get mouse positions in selected doodle's plane
			var mousePosSelectedDoodlePlane = doodle.inverseTransform.transformPoint(_point);
			var lastMousePosSelectedDoodlePlane = doodle.inverseTransform.transformPoint(this.lastMousePosition);

			// Get mouse positions in canvas plane relative to centre
			var mousePosRelCanvasCentre = new ED.Point(_point.x - this.canvas.width / 2, _point.y - this.canvas.height / 2);
			var lastMousePosRelCanvasCentre = new ED.Point(this.lastMousePosition.x - this.canvas.width / 2, this.lastMousePosition.y - this.canvas.height / 2);

			// Get position of centre of display (canvas plane relative to centre) and of an arbitrary point vertically above
			var canvasCentre = new ED.Point(0, 0);
			var canvasTop = new ED.Point(0, -100);

			// Get coordinates of origin of doodle in doodle plane
			var doodleOrigin = new ED.Point(doodle.originX, doodle.originY);

			// Get position of point vertically above doodle origin in doodle plane
			var doodleTop = new ED.Point(doodle.originX, doodle.originY - 100);

			// Effect of dragging depends on mode
			switch (this.mode) {
				case ED.Mode.None:
					break;

				case ED.Mode.Move:
					// If isMoveable is true, move doodle
					if (doodle.isMoveable) {
						// Initialise new values to stop doodle getting 'trapped' at origin due to failure of non-zero test in snapToQuadrant
						var newOriginX = doodle.originX;
						var newOriginY = doodle.originY;

						// Enforce snap to grid
						if (doodle.snapToGrid) {
							// Calculate mouse position and work out nearest position of a grid line
							var testX = mousePosDoodlePlane.x - doodle.gridDisplacementX;
							var gridSquaresX = Math.floor(testX / doodle.gridSpacing);
							var gridRemainderX = ED.Mod(testX, doodle.gridSpacing);
							newOriginX = doodle.gridDisplacementX + doodle.gridSpacing * (gridSquaresX + Math.round(gridRemainderX / doodle.gridSpacing));

							// Repeat for Y axis
							var testY = mousePosDoodlePlane.y - doodle.gridDisplacementY;
							var gridSquaresY = Math.floor(testY / doodle.gridSpacing);
							var gridRemainderY = ED.Mod(testY, doodle.gridSpacing);
							newOriginY = doodle.gridDisplacementY + doodle.gridSpacing * (gridSquaresY + Math.round(gridRemainderY / doodle.gridSpacing));

							// Doodle's move method notifies and also sets orientation
							doodle.move(newOriginX - doodle.originX, newOriginY - doodle.originY);
						}
						// Enforce snap to quadrant
						else if (doodle.snapToQuadrant) {
							if (mousePosDoodlePlane.x != 0) {
								newOriginX = doodle.quadrantPoint.x * mousePosDoodlePlane.x / Math.abs(mousePosDoodlePlane.x);
							}
							if (mousePosDoodlePlane.y != 0) {
								newOriginY = doodle.quadrantPoint.y * mousePosDoodlePlane.y / Math.abs(mousePosDoodlePlane.y);
							}

							// Doodle's move method notifies and also sets orientation
							doodle.move(newOriginX - doodle.originX, newOriginY - doodle.originY);
						}
						// Enforce snap to points
						else if (doodle.snapToPoints) {
							newOriginX = doodle.nearestPointTo(mousePosDoodlePlane).x;
							newOriginY = doodle.nearestPointTo(mousePosDoodlePlane).y;

							// Doodle's move method notifies and also sets orientation
							doodle.move(newOriginX - doodle.originX, newOriginY - doodle.originY);
						}
						// Normal move
						else {
							doodle.move(mousePosDoodlePlane.x - lastMousePosDoodlePlane.x, mousePosDoodlePlane.y - lastMousePosDoodlePlane.y);
						}

						action = 'move';
					}
					// Otherwise rotate it (if isRotatable)
					else {
						if (doodle.isRotatable) {
							// Calculate angles from centre to mouse positions relative to north
							var oldAngle = this.innerAngle(canvasTop, canvasCentre, lastMousePosRelCanvasCentre);
							var newAngle = this.innerAngle(canvasTop, canvasCentre, mousePosRelCanvasCentre);

							// Work out difference, and change doodle's angle of rotation by this amount
							var angleDelta = newAngle - oldAngle;

							// Calculate new value of rotation
							if (doodle.snapToAngles) {
								var newRotation = doodle.nearestAngleTo(newAngle);
							} else {
								var newRotation = ED.Mod(doodle.rotation + angleDelta, 2 * Math.PI);
							}

							// Restrict to allowable range
							doodle.setSimpleParameter('rotation', doodle.parameterValidationArray['rotation']['range'].constrainToAngularRange(newRotation, false));

							// Update dependencies
							doodle.updateDependentParameters('rotation');

							// Adjust radius property
							var oldRadius = Math.sqrt(lastMousePosDoodlePlane.x * lastMousePosDoodlePlane.x + lastMousePosDoodlePlane.y * lastMousePosDoodlePlane.y);
							var newRadius = Math.sqrt(mousePosDoodlePlane.x * mousePosDoodlePlane.x + mousePosDoodlePlane.y * mousePosDoodlePlane.y);
							var radiusDelta = doodle.radius + (newRadius - oldRadius);

							// Keep within bounds
							doodle.setSimpleParameter('radius', doodle.parameterValidationArray['radius']['range'].constrain(radiusDelta));

							// Update dependencies
							doodle.updateDependentParameters('radius');
						}
					}
					break;
				case ED.Mode.Scale:
					if (doodle.isScaleable) {
						// Get sign of scale (negative scales create horizontal and vertical flips)
						var signX = doodle.scaleX / Math.abs(doodle.scaleX);
						var signY = doodle.scaleY / Math.abs(doodle.scaleY);

						// Calculate change in scale (sign change indicates mouse has moved across central axis)
						var changeX = mousePosSelectedDoodlePlane.x / lastMousePosSelectedDoodlePlane.x;
						var changeY = mousePosSelectedDoodlePlane.y / lastMousePosSelectedDoodlePlane.y;

						// Ensure scale change is same if not squeezable
						if (!doodle.isSqueezable) {
							if (changeX > changeY) changeY = changeX;
							else changeY = changeX;
						}

						// Check that mouse has not moved from one quadrant to another
						if (changeX > 0 && changeY > 0) {
							// Now do scaling
							newScaleX = doodle.scaleX * changeX;
							newScaleY = doodle.scaleY * changeY;

							// Constrain scale
							newScaleX = doodle.parameterValidationArray['scaleX']['range'].constrain(Math.abs(newScaleX), this.globalScaleFactor);
							newScaleY = doodle.parameterValidationArray['scaleY']['range'].constrain(Math.abs(newScaleY), this.globalScaleFactor);

							doodle.setSimpleParameter('scaleX', newScaleX * signX);
							doodle.setSimpleParameter('scaleY', newScaleY * signY);

							// Update dependencies
							doodle.updateDependentParameters('scaleX');
							doodle.updateDependentParameters('scaleY');
						} else {
							this.mode = ED.Mode.None;
						}
					}
					break;

				case ED.Mode.Arc:

					// Calculate angles from centre to mouse positions relative to north
					var newAngle = this.innerAngle(doodleTop, doodleOrigin, mousePosSelectedDoodlePlane);
					var oldAngle = this.innerAngle(doodleTop, doodleOrigin, lastMousePosSelectedDoodlePlane);

					// Work out difference, and sign of rotation correction
					var deltaAngle = newAngle - oldAngle;
					if (doodle.isArcSymmetrical) deltaAngle = 2 * deltaAngle;
					rotationCorrection = 1;

					// Arc left or right depending on which handle is dragging
					if (doodle.draggingHandleIndex < 2) {
						deltaAngle = -deltaAngle;
						rotationCorrection = -1;
					}

					// Handle snapping
					if (doodle.snapToArc) {
						// Correct for negative handle
						if (rotationCorrection < 0) {
							newAngle = 2 * Math.PI - ED.positiveAngle(newAngle);
						}
						doodle.setSimpleParameter('arc', doodle.nearestArcTo(doodle.arc / 2 + newAngle));
					} else {
						// Check for permitted range and stop dragging if exceeded
						if (doodle.parameterValidationArray['arc']['range'].isBelow(doodle.arc + deltaAngle)) {
							deltaAngle = doodle.parameterValidationArray['arc']['range'].min - doodle.arc;
							doodle.setSimpleParameter('arc', doodle.parameterValidationArray['arc']['range'].min);
							this.mode = ED.Mode.None;
						} else if (doodle.parameterValidationArray['arc']['range'].isAbove(doodle.arc + deltaAngle)) {

							deltaAngle = doodle.parameterValidationArray['arc']['range'].max - doodle.arc;
							//doodle.arc = doodle.parameterValidationArray['arc']['range'].max;
							doodle.setSimpleParameter('arc', doodle.parameterValidationArray['arc']['range'].max);
							this.mode = ED.Mode.None;
						} else {
							doodle.setSimpleParameter('arc', doodle.arc + deltaAngle);
						}
					}

					// Update dependencies
					doodle.updateDependentParameters('arc');

					// Correct rotation with counter-rotation
					if (!doodle.isArcSymmetrical) {
						rotationCorrection = rotationCorrection * deltaAngle / 2;
						doodle.setSimpleParameter('rotation', doodle.rotation + rotationCorrection);

						// Update dependencies
						doodle.updateDependentParameters('rotation');
					}
					break;

				case ED.Mode.Rotate:

					if (doodle.isRotatable) {
						// Calculate angles from centre to mouse positions relative to north
						var oldAngle = this.innerAngle(doodleTop, doodleOrigin, lastMousePosDoodlePlane);
						var newAngle = this.innerAngle(doodleTop, doodleOrigin, mousePosDoodlePlane);

						// Work out difference, and change doodle's angle of rotation by this amount
						var deltaAngle = newAngle - oldAngle;
						//deltaAngle = ED.positiveAngle(deltaAngle);
						var newRotation = doodle.rotation + deltaAngle;
						newRotation = ED.positiveAngle(newRotation);

						// Restrict to allowable range
						doodle.setSimpleParameter('rotation', doodle.parameterValidationArray['rotation']['range'].constrainToAngularRange(newRotation, false));

						// Update dependencies
						doodle.updateDependentParameters('rotation');
					}
					break;

				case ED.Mode.Apex:
					// Move apex to new position
					var newApexX = doodle.apexX + (mousePosSelectedDoodlePlane.x - lastMousePosSelectedDoodlePlane.x);
					var newApexY = doodle.apexY + (mousePosSelectedDoodlePlane.y - lastMousePosSelectedDoodlePlane.y);

					// Enforce bounds
					doodle.setSimpleParameter('apexX', doodle.parameterValidationArray['apexX']['range'].constrain(newApexX));
					doodle.setSimpleParameter('apexY', doodle.parameterValidationArray['apexY']['range'].constrain(newApexY));

					// Update dependencies
					doodle.updateDependentParameters('apexX');
					doodle.updateDependentParameters('apexY');
					break;

				case ED.Mode.Size:
					// Alter width and height accordingly
					var newWidth = doodle.width + 2 * (mousePosSelectedDoodlePlane.x - lastMousePosSelectedDoodlePlane.x);
					var newHeight = doodle.height - 2 * (mousePosSelectedDoodlePlane.y - lastMousePosSelectedDoodlePlane.y);

					// Enforce bounds
					doodle.setSimpleParameter('width', doodle.parameterValidationArray['width']['range'].constrain(newWidth));
					doodle.setSimpleParameter('height', doodle.parameterValidationArray['height']['range'].constrain(newHeight));

					// Update dependencies
					doodle.updateDependentParameters('width');
					doodle.updateDependentParameters('height');
					break;

				case ED.Mode.Handles:

					// Move handles to new position (Stored in a squiggle)
					var index = doodle.draggingHandleIndex;

					// Get new position into a point object
					var newPosition = new ED.Point(0, 0);
					newPosition.x = doodle.squiggleArray[0].pointsArray[index].x + (mousePosSelectedDoodlePlane.x - lastMousePosSelectedDoodlePlane.x);
					newPosition.y = doodle.squiggleArray[0].pointsArray[index].y + (mousePosSelectedDoodlePlane.y - lastMousePosSelectedDoodlePlane.y);

					// Constraining coordinates handle with optional range array (set in a subclass)
					if (typeof(doodle.handleCoordinateRangeArray) != 'undefined') {
						newPosition.x = doodle.handleCoordinateRangeArray[index]['x'].constrain(newPosition.x);
						newPosition.y = doodle.handleCoordinateRangeArray[index]['y'].constrain(newPosition.y);
					}

					// Constraining radius and angle of handle with optional range array (set in a subclass)
					if (typeof(doodle.handleVectorRangeArray) != 'undefined') {
						var length = doodle.handleVectorRangeArray[index]['length'].constrain(newPosition.length());
						var angle = doodle.handleVectorRangeArray[index]['angle'].constrainToAngularRange(newPosition.direction(), false);
						newPosition.setWithPolars(length, angle);
					}

					// Set new position for handle
					doodle.squiggleArray[0].pointsArray[index].x = newPosition.x;
					doodle.squiggleArray[0].pointsArray[index].y = newPosition.y;

					// Update dependencies (NB handles is not stricly a parameter, but this will call the appropriate doodle methods)
					doodle.updateDependentParameters('handles');
					break;

				case ED.Mode.Draw:
					var p = new ED.Point(mousePosSelectedDoodlePlane.x, mousePosSelectedDoodlePlane.y);
					doodle.addPointToSquiggle(p);
					break;

				case ED.Mode.Select:
					var p = new ED.Point(mousePosSelectedDoodlePlane.x, mousePosSelectedDoodlePlane.y);
					// console.log('Selecting ', p.x, p.y);
					break;

				default:
					break;
			}

			// Update any bindings NB temporarilly moved to updateDependentParameters method which SHOULD be called for all relevant changes in this method
			//this.updateBindings();
		}

		// Store mouse position
		this.lastMousePosition = _point;

		// Notify
		this.notify("mousedragged", {
			point: _point,
			action: action
		});

		// Refresh
		this.repaint();
	}
};

/**
 * Responds to mouse up event in canvas
 *
 * @event Drawing#mouseup
 * @param {Point} _point coordinates of mouse in canvas plane
 */
ED.Drawing.prototype.mouseup = function(_point) {
	// Multiselect - Go through doodles seeing which are within dragging rectangle
	/*
		for (var i = 0; i < this.doodleArray.length; i++)
	{
				var doodle = this.doodleArray[i];
				var origin = new ED.Point(doodle.originX, doodle.originY);

				var p = this.transform.transformPoint(origin);

				// If doodle origin is in selection rectangle, select it
				if(this.selectionRectangleIsBeingDragged && this.context.isPointInPath(p.x, p.y))
				{
						doodle.isSelected = true;
				}
	}

		// TEMP - this is needed to ensure delete button is activated
		if (doodle) this.selectedDoodle = doodle;
		 */

	// Reset flags and mode
	this.mouseIsDown = false;
	this.doubleClick = false;
	this.mode = ED.Mode.None;
	this.selectionRectangleIsBeingDragged = false;

	// Reset selected doodle's dragging flag
	if (this.selectedDoodle != null) {
		this.selectedDoodle.isBeingDragged = false;

		// Optionally complete squiggle
		if (this.selectedDoodle.isDrawable) {
			this.selectedDoodle.completeSquiggle();
			this.drawAllDoodles();
		}

		// Remove selection from some doodles
		if (!this.selectedDoodle.willStaySelected) {
			this.selectedDoodle.isSelected = false;
			this.selectedDoodle = null;
		}
	}

	
	// Redraw to get rid of select rectangle
	this.repaint();

	// Notify
	this.notify("mouseup", _point);
};

/**
 * Responds to mouse out event in canvas, stopping dragging operation
 *
 * @param {Point} _point coordinates of mouse in canvas plane
 */
ED.Drawing.prototype.mouseover = function(_point) {
	// Make drawing active
	this.isActive = true;

	// Notify
	this.notify("mouseover", _point);
};

/**
 * Responds to mouse out event in canvas, stopping dragging operation
 *
 * @event Drawing#mouseout
 * @param {Point} _point coordinates of mouse in canvas plane
 */
ED.Drawing.prototype.mouseout = function(_point) {
	// Make drawing inactive
	this.isActive = false;

	// Stop the hover timer
	this.stopHoverTimer();

	// Reset flag and mode
	this.mouseIsDown = false;
	this.mode = ED.Mode.None;

	// Reset selected doodle's dragging flag
	if (this.selectedDoodle != null) {
		this.selectedDoodle.isBeingDragged = false;

		// Optionally complete squiggle
		if (this.selectedDoodle.isDrawable) {
			this.selectedDoodle.completeSquiggle();
			this.drawAllDoodles();
		}
	}

	// Notify
	this.notify("mouseout", _point);
};

/**
 * Responds to key down event in canvas
 *
 * @event Drawing#keydown
 * @param {event} e Keyboard event
 */
ED.Drawing.prototype.keydown = function(e) {
	// Keyboard action works on selected doodle
	if (this.selectedDoodle != null) {
		// Delete or move doodle
		switch (e.keyCode) {
			case 8: // Backspace
				if (this.selectedDoodle.className != "Label") this.deleteSelectedDoodle();
				break;
			case 37: // Left arrow
				this.selectedDoodle.move(-ED.arrowDelta, 0);
				break;
			case 38: // Up arrow
				this.selectedDoodle.move(0, -ED.arrowDelta);
				break;
			case 39: // Right arrow
				this.selectedDoodle.move(ED.arrowDelta, 0);
				break;
			case 40: // Down arrow
				this.selectedDoodle.move(0, ED.arrowDelta);
				break;
			default:
				break;
		}

		this.repaint();

		// Prevent key stroke bubbling up (***TODO*** may need cross browser handling)
		e.stopPropagation();
		e.preventDefault();

		this.notify("keydown", e.keyCode);
	}
};

/**
 * Starts a timer to display a tooltip simulating hover. Called from the mousemove event
 *
 * @event Drawing#startHoverTimer
 * @param {Point} _point coordinates of mouse in canvas plane
 */
ED.Drawing.prototype.startHoverTimer = function(_point) {
	// Only show tooltips for editable drawings with a span element of id 'canvasTooltip'
	if (this.isEditable && this.canvasTooltip != null) {
		// Stop any existing timer
		this.stopHoverTimer();

		// Restart it
		var drawing = this;
		this.hoverTimer = setTimeout(function() {
			drawing.hover(_point);
		}, 1000);
	}
};

/**
 * Stops the timer. Called by the mouseout event, and from the start of the startHoverTimer method
 *
 * @event Drawing#stopHoverTimer
 */
ED.Drawing.prototype.stopHoverTimer = function() {
	if (this.canvasTooltip != null) {
		// Reset any existing timer
		clearTimeout(this.hoverTimer);

		// Clear text
		this.canvasTooltip.innerHTML = "";

		// Hide hover
		this.hideTooltip();
	}
};

/**
 * Triggered by the hover timer
 *
 * @event Drawing#hover
 * @param {Point} _point coordinates of mouse in canvas plane
 */
ED.Drawing.prototype.hover = function(_point) {
	this.showTooltip(_point);

	// Notify
	this.notify("hover", _point);
};

/**
 * Shows a tooltip if present
 *
 * @event Drawing#showTooltip
 * @param {Point} _point coordinates of mouse in canvas plane
 */
ED.Drawing.prototype.showTooltip = function(_point) {


	// DISABLED TOOLTIPS AS PART OF #OED-4
	return;

	// Get coordinates of mouse
	var xAbs = _point.x;
	var yAbs = _point.y;
	if (this.canvas.offsetParent) {
		var obj = this.canvas;
		var keepGoing;

		// The tooltip <span> has an absolute position (relative to the 1st parent element that has a position other than static)
		do {
			// ***TODO*** is this a reliable way of getting the position attribute?
			var position = document.defaultView.getComputedStyle(obj, null).getPropertyValue('position');

			// Flag to continue going up the tree
			keepGoing = false;

			// Assign x and y values
			if (position != null) {
				if (position == 'static') {
					keepGoing = true;
					xAbs += obj.offsetLeft;
					yAbs += obj.offsetTop;
				}
			}

			// Does parent exist, or is origin for absolute positioning
			var keepGoing = keepGoing && (obj = obj.offsetParent);

		}
		while (keepGoing);
	}

	// Adjust coodinates of tooltip
	this.canvasTooltip.style.left = xAbs + "px";
	this.canvasTooltip.style.top = (yAbs + 18) + "px";

	// Set flag to indicate success
	var found = false;

	// Cycle through doodles from front to back doing hit test
	for (var i = this.doodleArray.length - 1; i > -1; i--) {
		if (!found) {
			// Save context (draw method of each doodle may alter it)
			this.context.save();

			// Successful hit test?
			if (this.doodleArray[i].draw(_point) && this.doodleArray[i].showsToolTip) {
				this.canvasTooltip.innerHTML = this.doodleArray[i].tooltip();
				found = true;
			}

			// Restore context
			this.context.restore();
		}
	}

	// Display tooltip
	if (this.canvasTooltip.innerHTML.length > 0) {
		this.canvasTooltip.style.display = 'block';
	}
};

/**
 * Hides a tooltip
 *
 * @event Drawing#hideTooltip
 */
ED.Drawing.prototype.hideTooltip = function() {
	this.canvasTooltip.style.display = 'none';
};

/**
 * Moves selected doodle to front
 */
ED.Drawing.prototype.moveToFront = function() {

	// Should only be called if a doodle is selected, but check anyway
	if (this.selectedDoodle != null) {

		if (this.selectedDoodle.isLocked) {
			return;
		}

		// Assign large number to selected doodle
		this.selectedDoodle.order = 1000;

		// Sort array by order (puts back doodle first)
		this.doodleArray.sort(function(a, b) {
			return a.order - b.order
		});

		// Re-assign ordinal numbers to array
		for (var i = 0; i < this.doodleArray.length; i++) {
			this.doodleArray[i].order = i;
		}

		// Refresh canvas
		this.repaint();
	}

	// Notify
	this.notify("moveToFront");
};

/**
 * Moves selected doodle to back
 */
ED.Drawing.prototype.moveToBack = function() {

	// Should only be called if a doodle is selected, but check anyway
	if (this.selectedDoodle !== null) {

		if (this.selectedDoodle.isLocked) {
			return;
		}

		// Assign negative order to selected doodle
		this.selectedDoodle.order = -1;

		// Sort array by order (puts back doodle first)
		this.doodleArray.sort(function(a, b) {
			return a.order - b.order
		});

		// Re-assign ordinal numbers to array
		for (var i = 0; i < this.doodleArray.length; i++) {
			this.doodleArray[i].order = i;
		}

		// Refresh canvas
		this.repaint();
	}

	// Notify
	this.notify("moveToBack");
};

/**
 * Moves a doodle next to the first doodle of the passed class name
 *
 * @param {Doodle} _doodle The doodle to move
 * @param {String} _className Classname of doodle to move next to
 * @param {Bool} _inFront True if doodle placed in front, otherwise behind
 */
ED.Drawing.prototype.moveNextTo = function(_doodle, _className, _inFront) {
	// Check that _className has an instance
	if (this.hasDoodleOfClass(_className)) {
		// Don't assume that _doodle is in front, so start by putting it there, and reorder
		_doodle.order = 1000;
		this.doodleArray.sort(function(a, b) {
			return a.order - b.order
		});
		for (var i = 0; i < this.doodleArray.length; i++) {
			this.doodleArray[i].order = i;
		}

		// Interate through doodle array altering order
		var offset = 0;
		for (var i = 0; i < this.doodleArray.length - 1; i++) {
			this.doodleArray[i].order = i + offset;

			// Look for doodle of passed classname (will definitely be found first)
			if (this.doodleArray[i].className == _className) {
				offset = 1;
				if (_inFront) {
					_doodle.order = i + 1;
				} else {
					_doodle.order = i;
					this.doodleArray[i].order = i + 1;
				}
			}
		}

		// Sort array by order (puts back doodle first)
		this.doodleArray.sort(function(a, b) {
			return a.order - b.order
		});
	}
};

/**
 * Flips the doodle around a vertical axis
 */
ED.Drawing.prototype.flipVer = function() {
	// Should only be called if a doodle is selected, but check anyway
	if (this.selectedDoodle != null) {
		// Vertical axis involved altering sign of scale y
		this.selectedDoodle.scaleY = this.selectedDoodle.scaleY * -1;

		// Refresh canvas
		this.repaint();
	}

	// Notify
	this.notify("flipVer");
};

/**
 * Flips the doodle around a horizontal axis
 */
ED.Drawing.prototype.flipHor = function() {
	// Should only be called if a doodle is selected, but check anyway
	if (this.selectedDoodle != null) {
		// Horizontal axis involved altering sign of scale x
		this.selectedDoodle.scaleX = this.selectedDoodle.scaleX * -1;

		// Refresh canvas
		this.repaint();
	}

	// Notify
	this.notify("flipHor");
};

/**
 * Deletes a doodle
 *
 * @param {Doodle} The doodle to be deleted
 */
ED.Drawing.prototype.deleteDoodle = function(_doodle, really) {
	// Class name and flag for successful deletion
	var deletedClassName = false;

	var errorMessage = 'Attempt to delete a doodle that does not exist';
	// Check that doodle will delete
	if (really || _doodle.willDelete()) {
		// Iterate through doodle array looking for doodle
		for (var i = 0; i < this.doodleArray.length; i++) {
			if (this.doodleArray[i].id == _doodle.id) {
				if (really || this.doodleArray[i].isDeletable) {
					deletedClassName = _doodle.className;

					// If its selected, deselect it
					if (this.selectedDoodle != null && this.selectedDoodle.id == _doodle.id) {
						this.selectedDoodle.onDeselection();
						this.selectedDoodle = null;
					}

					// Remove bindings and reset values of bound elements
					for (var parameter in _doodle.bindingArray) {
						var elementId = _doodle.bindingArray[parameter]['id'];
						var attribute = _doodle.bindingArray[parameter]['attribute'];

						var element = document.getElementById(elementId);
						var value = this.boundElementDeleteValueArray[elementId];

						// If available, set the value of the bound element to the appropriate value
						if (element != null && typeof(value) != 'undefined') {
							// Set the element according to the value
							switch (element.type) {
								case 'checkbox':
									if (attribute) {
										ED.errorHandler('ED.Drawing', 'deleteDoodle', 'Binding to a checkbox with a non-standard attribute not yet supported');
									} else {
										if (value == "true") {
											element.setAttribute('checked', 'checked');
										} else {
											element.removeAttribute('checked');
										}
									}
									break;

								case 'select-one':
									if (attribute) {
										for (var j = 0; j < element.length; j++) {
											if (element.options[j].getAttribute(attribute) == value) {
												element.value = element.options[j].value;
												break;
											}
										}
									} else {
										element.value = value;
									}
									break;

								default:
									if (attribute) {
										element.setAttribute(attribute, value);
									} else {
										element.value = value;
									}
									break;
							}
						}

						// Remove binding from doodle (also removes event listener from element)
						_doodle.removeBinding(parameter);
					}

					// Remove it from array
					this.doodleArray.splice(i, 1);
				} else {
					errorMessage = 'Attempt to delete a doodle that is not deletable, className: ' + _doodle.className;
				}
			}
		}
	} else {
		errorMessage = 'Doodle refused permission to be deleted, className: ' + _doodle.className;
	}

	// If successfully deleted, tidy up
	if (deletedClassName) {
		// Re-assign ordinal numbers within array
		for (var i = 0; i < this.doodleArray.length; i++) {
			this.doodleArray[i].order = i;
		}

		// Refresh canvas
		this.repaint();

		// Notify
		this.notify("doodleDeleted", deletedClassName);
	} else {
		ED.errorHandler('ED.Drawing', 'deleteDoodle', errorMessage);
	}
};


/**
 * Deletes currently selected doodle
 */
ED.Drawing.prototype.deleteSelectedDoodle = function() {
	// Should only be called if a doodle is selected, but check anyway
	if (this.selectedDoodle != null) {
		this.deleteDoodle(this.selectedDoodle,false);
	} else {
		ED.errorHandler('ED.Drawing', 'deleteSelectedDoodle', 'Attempt to delete selected doodle, when none selected');
	}

	// Multiple select
	/*
		for (var i = 0; i < this.doodleArray.length; i++)
		{
				if (this.doodleArray[i].isSelected)
				{
						this.deleteDoodle(this.doodleArray[i]);
				}
		}
		 */
};


/**
 * Resets the eyedraw canvas completely including any related form inputs
 */

ED.Drawing.prototype.resetEyedraw = function() {
	this.notify("beforeReset");

	this.deleteAllDoodles(true);

	if (this.resetDoodleSet !== false) {
		this.notify("resetEdit");
	} else {
		this.notify("reset");
	}

	if (this.resetDoodleSet !== false) {
		this.load(this.resetDoodleSet);

		// Set isNew flag
		this.isNew = false;

		// Notify
		this.notify("doodlesLoaded");
	} else {
		for (var i = 0; i < this.onReadyCommands.length; i++) {
			for (var j = 0; j < this.onReadyCommands[i].length; j++) {
				var method = this.onReadyCommands[i][j][0];
				var argumentArray = this.onReadyCommands[i][j][1];

				this[method].apply(this, argumentArray);
			}
		}
	}

	this.drawAllDoodles();
	this.deselectDoodles();

	this.addBindings(this.bindingArray);
};

/**
 * Set the scale level for drawing and all doodles
 * @param  {Number} level			Scale level.
 * @param  {String} eventName Event name to notify.
 */
ED.Drawing.prototype.setScaleForDrawingAndDoodles = function(level) {

	this.globalScaleFactor = level;

	this.doodleArray.forEach(function(doodle) {
		doodle.setScaleLevel(level);
	});

	this.repaint();
};

/**
 * This should be called only once the drawing is ready.
 * @param {Number} level [description]
 */
ED.Drawing.prototype.setScaleLevel = function(level) {
	this.setScaleForDrawingAndDoodles(level);
	this.notifyZoomLevel();
};

/**
 * Toggles the scale level of the drawing.
 * We're only supporting two zoom levels: "in" and "out".
 */
ED.Drawing.prototype.toggleZoom = function() {
	if (!this.toggleScaleFactor) return;
	var scale = this.globalScaleFactor === this.toggleScaleFactor ? this.origScaleLevel : this.toggleScaleFactor;
	this.setScaleLevel(scale);
};

ED.Drawing.prototype.notifyZoomLevel = function() {

	var zoomIn = 'drawingZoomIn';
	var zoomOut = 'drawingZoomOut';
	var evt;

	if (this.origScaleLevel < this.toggleScaleFactor) {
		evt = (this.globalScaleFactor < this.toggleScaleFactor) ? zoomOut : zoomIn;
	} else {
		evt = (this.globalScaleFactor <= this.toggleScaleFactor) ? zoomOut : zoomIn;
	}

	this.notify('drawingZoom');
	this.notify(evt);
};

/**
 * Sets a property on currently selected doodle NB currently only supports boolean properties
 *
 * @param {Object} _element An HTML element which called this function
 * @param {String} _property The name of the property to switch
 */
ED.Drawing.prototype.setSelectedDoodle = function(_element, _property) {
	// Get value of check box
	var value = _element.checked ? "true" : "false";

	// Should only be called if a doodle is selected, but check anyway
	if (this.selectedDoodle != null) {
		this.selectedDoodle.setParameterFromString(_property, value);
	} else {
		ED.errorHandler('ED.Drawing', 'setSelectedDoodle', 'Attempt to set a property on the selected doodle, when none selected');
	}
};

/**
 * Deletes doodle with selected id
 */
ED.Drawing.prototype.deleteDoodleOfId = function(_id) {
	var doodle = this.doodleOfId(_id);

	if (doodle) {
		this.deleteDoodle(doodle,false);
	} else {
		ED.errorHandler('ED.Drawing', 'deleteDoodleOfId', 'Attempt to delete doodle with invalid id');
	}
};

/**
 * Locks selected doodle
 */
ED.Drawing.prototype.lock = function() {
	// Should only be called if a doodle is selected, but check anyway
	if (this.selectedDoodle !== null) {
		this.selectedDoodle.isLocked = true;
		this.notify("doodleLocked");
		this.repaint();
	}
};

/**
 * Unlocks all doodles
 */
ED.Drawing.prototype.unlock = function() {
	// Go through doodles unlocking all
	for (var i = 0; i < this.doodleArray.length; i++) {
		this.doodleArray[i].isLocked = false;
	}
	this.notify("doodleUnlocked");
	// Refresh canvas
	this.repaint();
};

/**
 * Toggle doodle help text
 */
ED.Drawing.prototype.toggleHelp = function() {
	this.notify('toggleDoodleHelp');
};

/**
 * Deselect any selected doodles
 */
ED.Drawing.prototype.deselectDoodles = function() {

	// Deselect all doodles
	for (var i = 0; i < this.doodleArray.length; i++) {
		this.doodleArray[i].isSelected = false;
	}

	if (this.selectedDoodle) {
		this.selectedDoodle.onDeselection();
		this.selectedDoodle = null;
	}

	this.notify("doodleDeselected");

	// Refresh drawing
	this.repaint();
};

/**
 * Use scroll to select next doodle in array (From an idea of Adrian Duke)
 *
 * @param {Int} _value Value of scroll wheel
 */
ED.Drawing.prototype.selectNextDoodle = function(_value) {
	// Increment current scrollValue
	this.scrollValue += _value;

	// Scroll direction
	var up = _value > 0 ? true : false;

	// 'Damp' scroll speed by waiting for larger increments
	var dampValue = 96;

	if (this.scrollValue > dampValue || this.scrollValue < -dampValue) {
		// Reset scrollValue
		this.scrollValue = 0;

		// Index of selected doodle
		var selectedIndex = -1;

		// Iterate through doodles
		for (var i = 0; i < this.doodleArray.length; i++) {
			if (this.doodleArray[i].isSelected) {
				selectedIndex = i;

				// Deselected currently selected doodle
				this.doodleArray[i].isSelected = false;
			}
		}

		// If there is a selection, change it
		if (selectedIndex >= 0) {
			// Change index
			if (up) {
				selectedIndex++;
				if (selectedIndex == this.doodleArray.length) selectedIndex = 0;
			} else {
				selectedIndex--;
				if (selectedIndex < 0) selectedIndex = this.doodleArray.length - 1;
			}

			// Wrap
			if (selectedIndex == this.doodleArray.length) {

			}

			this.doodleArray[selectedIndex].isSelected = true;
			this.selectedDoodle = this.doodleArray[selectedIndex];
		}

		// Refresh drawing
		this.repaint();
	}
};

/**
 * Sets a doodle as selected
 *
 * @param {Int} _doodleId Value of scroll wheel
 */
ED.Drawing.prototype.setDoodleAsSelected = function(_doodleId) {
	var selectedIndex = -1;

	// Iterate through doodles
	for (var i = 0; i < this.doodleArray.length; i++) {
		if (this.doodleArray[i].id == _doodleId) {
			selectedIndex = i;
		}
	}

	if (selectedIndex >= 0) {
		var doodle = this.doodleArray[selectedIndex];
		this.selectDoodle(doodle);
	}
};

/**
 * Mark a doodle as selected
 * @param  {ED.Doodle} doodle
 */
ED.Drawing.prototype.selectDoodle = function(doodle) {

	this.deselectDoodles();

	doodle.isSelected = true;
	this.selectedDoodle = doodle;
	
	// Run onDeselection code for last doodle
	if (this.lastSelectedDoodle) this.lastSelectedDoodle.onDeselection();

	// Notify
	this.notify("doodleSelected");

	// Run onSelection code
	this.selectedDoodle.onSelection();

	this.repaint();
};

/**
 * Marks the doodle as 'unmodified' so we can catch an event when it gets modified by the user
 */
ED.Drawing.prototype.isReady = function() {
	this.modified = false;
	if (this.convertToImage) {
		this.replaceWithImage();
	}
};

/**
 * Adds a doodle to the array
 *
 * @param {String} _className Class name of doodle
 * @param {Array} _parameterDefaults Array of key value pairs containing default values or parameters
 * @param {Array} _parameterBindings Array of key value pairs. Key is element id, value is parameter to bind to
 * @returns {Doodle} The newly added doodle
 */
ED.Drawing.prototype.addDoodle = function(_className, _parameterDefaults, _parameterBindings) {
		
	// Set flag to indicate whether a doodle of this className already exists
	var doodleExists = this.hasDoodleOfClass(_className);

	// Check that class exists, and create a new doodle
	if (ED.hasOwnProperty(_className)) {
		// Create new doodle of class
		var newDoodle = new ED[_className](this);

		// Create an instance of the parent if it does not already exist
		/*
				if (newDoodle.parentClass.length > 0)
				{
						if (!this.hasDoodleOfClass(newDoodle.parentClass))
						{
								this.addDoodle(newDoodle.parentClass);
						}
				}
				*/
	} else {
		ED.errorHandler('ED.Drawing', 'addDoodle', 'Unable to find definition for subclass ' + _className);
		return null;
	}

	// Check if one is already there if unique)
	if (!(newDoodle.isUnique && this.hasDoodleOfClass(_className))) {
		// Ensure no other doodles are selected, and run onDeselection code if appropriate
		for (var i = 0; i < this.doodleArray.length; i++) {
			if (this.doodleArray[i].isSelected) this.doodleArray[i].onDeselection();
			this.doodleArray[i].isSelected = false;
		}

		// Set parameters for this doodle
		if (typeof(_parameterDefaults) != 'undefined') {
			for (var key in _parameterDefaults) {
				var res = newDoodle.validateParameter(key, _parameterDefaults[key]);
				if (res.valid) {
					newDoodle.setParameterFromString(key, res.value);
				} else {
					ED.errorHandler('ED.Drawing', 'addDoodle', 'ParameterDefaults array contains an invalid value for parameter ' + key);
				}
			}
		}

		// New doodles are selected by default
		this.selectedDoodle = newDoodle;

		// If drawable, also go into drawing mode
		if (newDoodle.isDrawable) {
			newDoodle.isForDrawing = true;
		}

		// Add to array
		this.doodleArray[this.doodleArray.length] = newDoodle;

		// Pre-existing binding
		if (!doodleExists) {
			for (var parameter in this.bindingArray[_className]) {
				var elementId = this.bindingArray[_className][parameter]['id'];
				var attribute = this.bindingArray[_className][parameter]['attribute'];
				var element = document.getElementById(elementId);

				// Get the value of the element
				var value;

				// Set the value to the value of the element
				switch (element.type) {
					case 'checkbox':
						if (attribute) {
							ED.errorHandler('ED.Drawing', 'addDoodle', 'Binding to a checkbox with a non-standard attribute not yet supported');
						} else {
							value = element.checked.toString();
						}
						break;

					case 'select-one':
						if (attribute) {
							if (element.selectedIndex > -1) {
								value = element.options[element.selectedIndex].getAttribute(attribute);
							}
						} else {
							value = element.value;
						}
						break;

					default:
						if (attribute) {
							value = element.getAttribute(attribute);
						} else {
							value = element.value;
						}
						break;
				}

				// If the element value is equal to the delete value, use the default value of the doodle instead
				if (value == this.boundElementDeleteValueArray[elementId]) {
					value = newDoodle[parameter];
				}

				// Check validity of new value
				var validityArray = newDoodle.validateParameter(parameter, value);

				// If new value is valid, set it, otherwise use default value of doodle
				if (validityArray.valid) {
					newDoodle.setParameterFromString(parameter, validityArray.value);
					//newDoodle.setSimpleParameter(parameter, validityArray.value);
					newDoodle.updateDependentParameters(parameter);
					//newDoodle.setParameterWithAnimation(parameter, validityArray.value);
				} else {
					value = newDoodle[parameter];
					ED.errorHandler('ED.Drawing', 'addDoodle', 'Invalid value for parameter: ' + parameter);
				}

				// Add binding to the doodle (NB this will set value of new doodle to the value of the element)
				newDoodle.addBinding(parameter, this.bindingArray[_className][parameter]);

				// Trigger binding by setting parameter
				//newDoodle.setSimpleParameter(parameter, value);
				newDoodle.setParameterFromString(parameter, validityArray.value);
				newDoodle.updateDependentParameters(parameter);
				this.updateBindings(newDoodle);
			}
		}

		// Binding passed as an argument to this method
		if (typeof(_parameterBindings) != 'undefined') {
			for (var key in _parameterBindings) {
				// Add binding to the doodle
				newDoodle.addBinding(key, _parameterBindings[key]);
			}
		}

		if (newDoodle.addAtBack) {
			// This method also calls the repaint method
			this.moveToBack();
		} else {
			// Refresh drawing
			this.repaint();
		}

		// Notify
		this.notify("doodleAdded", newDoodle);

		// Run onSelection code
		if (this.selectedDoodle) {
			// might already have been deselected depending on syncing rules
			this.selectedDoodle.onSelection();
		}

		// Return doodle
		return newDoodle;
	} else {
		ED.errorHandler('ED.Drawing', 'addDoodle', 'Attempt to add a second unique doodle of class ' + _className);
		return null;
	}
};

/**
 * Takes array of bindings, and adds them to the corresponding doodles. Adds an event listener to create a doodle if it does not exist
 *
 * @param {Array} _bindingArray Associative array. Key is className, and each value is an array with key: parameter name, value: elementId
 */
ED.Drawing.prototype.addBindings = function(_bindingArray) {
	// Store binding array as part of drawing object in order to restore bindings to doodles that are deleted and added again
	this.bindingArray = _bindingArray;

	// Get reference to this drawing object (for inner function)
	var drawing = this;

	// Iterate through classNames
	for (var className in _bindingArray) {
		// Look for the first doodle of this class to bind to
		var doodle = this.firstDoodleOfClass(className);

		// Iterate through bindings for this className
		for (var parameter in _bindingArray[className]) {
			// Get reference to element
			var elementId = _bindingArray[className][parameter]['id'];
			var element = document.getElementById(elementId);

			if (element) {
				// Add an event listener to the element to create a bound doodle on change, if it does not exist
				element.addEventListener('change', (function(className) {
					return function(event) {
						if (!drawing.hasDoodleOfClass(className)) {
							drawing.addDoodle(className);
							drawing.deselectDoodles();
						}
					};
				}(className)), false);

				// Add binding to doodle if it exists
				if (doodle) {
					doodle.addBinding(parameter, _bindingArray[className][parameter]);
				}
			} else {
				ED.errorHandler('ED.Drawing', 'addBindings', 'Attempt to add binding for an element that does not exist for parameter: ' + parameter + ' with id ' + elementId);
			}
		}
	}
};

/**
 * Takes an array of key value pairs and adds them to the boundElementDeleteValueArray
 *
 * @param {Array} _deleteValuesArray Associative array. Key is elementId, and value the value corresponding to an absent doodle
 */
ED.Drawing.prototype.addDeleteValues = function(_deleteValuesArray) {
	for (elementId in _deleteValuesArray) {
		this.boundElementDeleteValueArray[elementId] = _deleteValuesArray[elementId];
	}
};

/**
 * Called by events attached to HTML elements such as <input>
 *
 * @param {String} _type Type of event, only onchange is currently implemented
 * @param {Int} _doodleId The id of the doodle containing the binding
 * @param {String} _className The class name of the doodle containing the binding (for recreation if deleted)
 * @param {String} _elementId The id attribute of the element
 * @returns {Value} The current value of the element
 */
ED.Drawing.prototype.eventHandler = function(_type, _doodleId, _className, _elementId, _value) {
	//console.log("Event: " + _type + " doodleId: " + _doodleId + " doodleClass: " + _className + " elementId: " + _elementId + " value: " + _value);


	switch (_type) {
		case 'oninput':
		case 'onchange':
			// Get reference to associated doodle
			var doodle = this.doodleOfId(_doodleId);

			// Process event
			if (doodle) {
				// Look for value in boundElementDeleteValueArray
				if (this.boundElementDeleteValueArray[_elementId] == _value) {
					this.deleteDoodleOfId(_doodleId);
				} else {
					// Set state of drawing to be active to allow synchronisation to work when changed by bound element
					doodle.drawing.isActive = true;

					// Find key associated with the element id
					var parameter;
					for (var key in doodle.bindingArray) {
						if (doodle.bindingArray[key]['id'] == _elementId) {
							parameter = key;
						}
					}

					// Check validity of new value, only trim the value if change event
					var validityArray = doodle.validateParameter(parameter, _value, (_type === 'onchange'));

					// If new value is valid, set it
					if (validityArray.valid) {

						// [OE-4028] We do not want the doodle animation to update the bindings for the
						// following reasons:
						// 1) The form control is already set with the correct value.
						// 2) We do not want the value to update incrementally with the animation.
						var updateBindings = false;

						// Animate the doodle with the value of the form control.
						doodle.setParameterWithAnimation(parameter, validityArray.value, updateBindings);
					} else {
						ED.errorHandler('ED.Drawing', 'eventHandler', 'Attempt to change HTML element value to an invalid value for parameter ' + parameter);
					}

					// Apply new value to element if necessary
					if (_value != validityArray.value) {
						var element = document.getElementById(_elementId);
						var attribute = doodle.bindingArray[parameter]['attribute'];

						// Set the element according to the value
						switch (element.type) {
							case 'checkbox':
								if (attribute) {
									ED.errorHandler('ED.Drawing', 'eventHandler', 'Binding to a checkbox with a non-standard attribute not yet supported');
								} else {
									console.log('setting checkbox - needs testing with a suitable doodle');
									if (value == "true") {
										element.setAttribute('checked', 'checked');
									} else {
										element.removeAttribute('checked');
									}
								}
								break;

							case 'select-one':
								if (attribute) {
									for (var i = 0; i < element.length; i++) {
										if (element.options[i].getAttribute(attribute) == validityArray.value) {
											element.value = element.options[i].value;
											break;
										}
									}
								} else {
									element.value = validityArray.value;
								}
								break;

							case 'text':
								if (attribute) {
									ED.errorHandler('ED.Drawing', 'eventHandler', 'Binding to a textfield with a non-standard attribute not yet supported');
								} else {
									element.value = validityArray.value;
								}
								break;

							default:
								if (attribute) {
									element.setAttribute(attribute, validityArray.value);
								} else {
									element.value = validityArray.value;
								}
								break;
						}
					}


					// ***TODO*** Need to reset state of drawing elsewhere, since this gets called before animation finished.
					//doodle.drawing.isActive = false;
				}
			} else {
				ED.errorHandler('ED.Drawing', 'eventHandler', 'Doodle of id: ' + _doodleId + ' no longer exists');
			}
			break;
		default:
			break;
	}
};

/**
 * Updates value of bound elements to the selected doodle. Called by methods which change parameter values
 *
 * @param {ED.Doodle} _doodle Optional doodle object to update drawings without a selected doodle
 */
ED.Drawing.prototype.updateBindings = function(_doodle) {
	var doodle = _doodle;

	// Check for an argument, otherwise take selected doodle for this drawing
	if (typeof(doodle) == 'undefined') {
		doodle = this.selectedDoodle;
	}

	// Update bindings for this doodle
	if (doodle != null) {
		// Iterate through this doodle's bindings array and alter value of HTML element
		for (var parameter in doodle.bindingArray) {
			var element = document.getElementById(doodle.bindingArray[parameter]['id']);
			if (!element)
				continue;
			var attribute = doodle.bindingArray[parameter]['attribute'];
			var value = doodle.getParameter(parameter);
			// Modify value of element according to type
			switch (element.type) {
				case 'checkbox':
					if (attribute) {
						ED.errorHandler('ED.Drawing', 'updateBindings', 'Binding to a checkbox with a non-standard attribute not yet supported');
					} else {

						if (value == "true") {
							element.setAttribute('checked', 'checked');
						} else {
							element.removeAttribute('checked');
						}
					}
					break;

				case 'select-one':
					var originalValue = element.value;
					if (attribute) {
						for (var i = 0; i < element.length; i++) {
							if (element.options[i].getAttribute(attribute) == value) {
								element.value = element.options[i].value;
								break;
							}
						}
					} else {
						element.value = value;
					}
					if (originalValue !== element.value) {
                        // trigger a change event for anything listen to the bound html elements
                        // instead of the eyedraw doodles.
                        window.setTimeout(function(el) { el.dispatchEvent(new Event('change', {bubbles: true, cancelable: true})); }.bind(null, element), 100)
					}
					break;

				case 'text':
					if (attribute) {
						ED.errorHandler('ED.Drawing', 'updateBindings', 'Binding to a textfield with a non-standard attribute not yet supported');
					} else {
						element.value = value;
					}
					break;

				default:
					if (attribute) {
						element.setAttribute(attribute, value);
					} else {
						element.value = value;
					}
					break;
			}
		}
	} else {
		// Since moving updateBindings method, this is no longer an error
		//ED.errorHandler('ED.Drawing', 'updateBindings', 'Attempt to update bindings on null doodle');
	}
};

/**
 * Test if doodle of a class exists in drawing
 *
 * @param {String} _className Classname of doodle
 * @returns {Bool} True is a doodle of the class exists, otherwise false
 */
ED.Drawing.prototype.hasDoodleOfClass = function(_className) {
	var returnValue = false;

	// Go through doodle array looking for doodles of passed className
	for (var i = 0; i < this.doodleArray.length; i++) {
		if (this.doodleArray[i].className == _className) {
			returnValue = true;
		}
	}

	return returnValue;
};

/** Counts number of doodles of passed class
 *
 * @param {String} _className Classname of doodle
 * @returns {Int} Number of doodles of the class
 */
ED.Drawing.prototype.numberOfDoodlesOfClass = function(_className) {
	var returnValue = 0;

	// Go through doodle array looking for doodles of passed className
	for (var i = 0; i < this.doodleArray.length; i++) {
		if (this.doodleArray[i].className == _className) {
			returnValue++;
		}
	}

	return returnValue;
};

/**
 * Returns first doodle of the passed className, or false if does not exist
 *
 * @param {String} _className Classname of doodle
 * @returns {Doodle} The first doodle of the passed className
 */
ED.Drawing.prototype.firstDoodleOfClass = function(_className) {
	var returnValue = false;

	// Go through doodle array looking for doodles of passed className
	for (var i = 0; i < this.doodleArray.length; i++) {
		if (this.doodleArray[i].className == _className) {
			returnValue = this.doodleArray[i];
			break;
		}
	}

	return returnValue;
};


/**
 * Returns last doodle of the passed className, or false if does not exist
 *
 * @param {String} _className Classname of doodle
 * @returns {Doodle} The last doodle of the passed className
 */
ED.Drawing.prototype.lastDoodleOfClass = function(_className) {
	var returnValue = false;

	// Go through doodle array backwards looking for doodles of passed className
	for (var i = this.doodleArray.length - 1; i >= 0; i--) {
		if (this.doodleArray[i].className == _className) {
			returnValue = this.doodleArray[i];
			break;
		}
	}

	return returnValue;
};

/**
 * Returns all doodles of the passed className
 *
 * @param {String} _className Classname of doodle
 * @returns {Array} Array of doodles of the passed className
 */
ED.Drawing.prototype.allDoodlesOfClass = function(_className) {
	var returnValue = [];

	// Go through doodle array backwards looking for doodles of passed className
	for (var i = this.doodleArray.length - 1; i >= 0; i--) {
		if (this.doodleArray[i].className == _className) {
			returnValue.push(this.doodleArray[i]);
		}
	}

	return returnValue;
};

/**
 * Sets a parameter value for all doodles of this class
 *
 * @param {String} _parameter Name of parameter
 * @param {String} _className Classname of doodle
 * @param {String} _value New value of parameter
 */
ED.Drawing.prototype.setParameterValueForClass = function(_parameter, _value, _className) {
	// Go through doodle array (backwards because of splice function) looking for doodles of passed className
	for (var i = this.doodleArray.length - 1; i >= 0; i--) {
		// Find doodles of given class name
		if (this.doodleArray[i].className == _className) {
			var doodle = this.doodleArray[i];

			// Set parameter
			doodle.setParameterWithAnimation(_parameter, _value);
		}
	}

	// Refresh drawing
	this.repaint();
};

/**
 * Returns the doodle with the corresponding id
 *
 * @param {Int} Id Id of doodle
 * @returns {Doodle} The doodle with the passed id
 */
ED.Drawing.prototype.doodleOfId = function(_id) {
	var doodle = false;

	// Go through doodle array looking for the corresponding doodle
	for (var i = 0; i < this.doodleArray.length; i++) {
		if (this.doodleArray[i].id == _id) {
			doodle = this.doodleArray[i];
			break;
		}
	}

	return doodle;
};

/**
 * Deletes all doodles that are deletable
 */
ED.Drawing.prototype.deleteAllDoodles = function(really_all) {
	// Go through doodle array (backwards because of splice function)
	for (var i = this.doodleArray.length - 1; i >= 0; i--) {
		// Only delete deletable ones
		if (really_all || this.doodleArray[i].isDeletable) {
			this.deleteDoodle(this.doodleArray[i],really_all);
		}
	}
};

/**
 * Deletes doodles of one class from the drawing
 *
 * @param {String} _className Classname of doodle
 */
ED.Drawing.prototype.deleteDoodlesOfClass = function(_className) {
	// Go through doodle array (backwards because of splice function) looking for doodles of passed className
	for (var i = this.doodleArray.length - 1; i >= 0; i--) {
		// Find doodles of given class name
		if (this.doodleArray[i].className == _className) {
			this.deleteDoodle(this.doodleArray[i],false);
		}
	}
};

/**
 * Updates a doodle with a new value of a parameter ***TODO** These two methods need updating with new notification system
 *
 * @param {Doodle} _doodle The doodle to be updated
 * @param {String} _parameter Name of the parameter
 * @param {Any} _value New value of the parameter
 */
ED.Drawing.prototype.setParameterForDoodle = function(_doodle, _parameter, _value) {
	// Determine whether doodle exists
	if (typeof(_doodle[_parameter]) != 'undefined') {
		_doodle[_parameter] = +_value;
	} else {
		_doodle.setParameterFromString(_parameter, _value);
	}

	// Save to hidden input, if exists, and refresh drawing
	if (typeof(this.saveToInputElement) != 'undefined') this.saveToInputElement();
	this.repaint();
};

/**
 * Updates a doodle of class with a vew value of a parameter. Use if only one member of a class exists
 *
 * @param {String} _className The name of the doodle class to be updated
 * @param {String} _parameter Name of the parameter
 * @param {Any} _value New value of the parameter
 */
ED.Drawing.prototype.setParameterForDoodleOfClass = function(_className, _parameter, _value) {
	// Get pointer to doodle
	var doodle = this.firstDoodleOfClass(_className);

	// Set parameter for the doodle
	doodle.setParameterWithAnimation(_parameter, _value);

	// Save to hidden input, if exists, and refresh drawing
	if (typeof(this.saveToInputElement) != 'undefined') this.saveToInputElement();
	this.repaint();
};

/**
 * Returns the total extent in degrees covered by doodles of the passed class
 *
 * @param {String} _class Class of the doodle to be updated
 * @returns {Int} Total extent in degrees, with maximum of 360
 */
ED.Drawing.prototype.totalDegreesExtent = function(_class) {
	var degrees = 0;

	// Calculate total for all doodles of this class
	for (var i = 0; i < this.doodleArray.length; i++) {
		// Find doodles of given class name
		if (this.doodleArray[i].className == _class) {
			degrees += this.doodleArray[i].degreesExtent();
		}
	}

	// Overlapping doodles do not increase total beyond 360 degrees
	if (degrees > 360) degrees = 360;

	return degrees;
};

/**
 * Suppresses reporting for all doodles currently in drawing.
 */
ED.Drawing.prototype.suppressReports = function() {
	// Iterate through all doodles
	for (var i = 0; i < this.doodleArray.length; i++) {
		this.doodleArray[i].willReport = false;
	}
};

/**
 * Returns a list of report strings to allow more fine grained manipulation of results.
 *
 * @returns {Array} list of report strings from doodle(s) on drawing
 */
ED.Drawing.prototype.reportData = function() {
	var reports = [];
	var grouped = {};
	for (var i = 0; i < this.doodleArray.length; i++) {
		var doodle = this.doodleArray[i];
		var description = doodle.description();

		if (doodle.willReport) {
			var groupDescription = doodle.groupDescription();
			if (groupDescription.length > 0) {
				if (typeof(grouped[doodle.className]) === 'undefined') {
					grouped[doodle.className] = {
						'start': groupDescription,
						'descriptions': [],
						'end': doodle.groupDescriptionEnd()
					}
				}
				grouped[doodle.className]['descriptions'].push(description)
			} else {
				if (description.length) {
					reports.push(description);
				}
			}
		}
	}

	// consolidate group reports
  for (var cls in grouped) {
		var groupStr = '';
    if (grouped.hasOwnProperty(cls)) {
      groupStr = grouped[cls]['start'];
      groupStr += ED.addAndAfterLastComma(grouped[cls]['descriptions'].join(", "));
      groupStr += grouped[cls]['end'];
      reports.push(groupStr);
    }
  }

	return reports;
}

/**
 * Returns a string containing a description of the drawing
 *
 * @returns {String} Description of the drawing
 */
ED.Drawing.prototype.report = function() {
	var returnString = "";

	var data = this.reportData();
	for (var i = 0; i < data.length; i++) {
		returnString += (i === 0) ? data[i] : ", " + ED.firstLetterToLowerCase(data[i]);
	}

	return (returnString.length > 0) ? returnString : "No abnormality";
};


/**
 * Returns a SNOMED diagnostic code derived from the drawing, returns empty array if no code
 *
 * @returns {Int} SnoMed code of doodle with highest position in hierarchy
 */
ED.Drawing.prototype.diagnosis = function() {
	var topOfHierarchy = 0;
	var returnCodes = new Array();

	// Loop through doodles with diagnoses, taking one highest in hierarchy, or those that are equal
	for (var i = 0; i < this.doodleArray.length; i++) {
		var doodle = this.doodleArray[i];
		var codeArray = doodle.snomedCodes();
		for (var j = 0; j < codeArray.length; j++) {
			var code = codeArray[j][0];
            if (code > 0) {
                var codePosition = codeArray[j][1];
                if (codePosition > topOfHierarchy) {
                    topOfHierarchy = codePosition;
                    returnCodes.push(code);
                } else if (codePosition == topOfHierarchy) {
                    if (returnCodes.indexOf(code) < 0) {
                        returnCodes.push(code);
                    }
                }
            }

		}
	}

	return returnCodes;
};

/**
 * Changes value of eye
 *
 * @param {String} _eye Eye to change to
 */
ED.Drawing.prototype.setEye = function(_eye) {
	// Change eye
	if (_eye == "Right") this.eye = ED.eye.Right;
	if (_eye == "Left") this.eye = ED.eye.Left;

	// Refresh drawing
	this.repaint();
};

/**
 * Clears canvas and sets context
 */
ED.Drawing.prototype.clear = function() {
	// Resetting a dimension attribute clears the canvas and resets the context
	this.canvas.width = this.canvas.width;

	// But, might not clear canvas, so do it explicitly
	this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

	// Set context transform to map from doodle plane to canvas plane
	this.context.translate(this.canvas.width / 2, this.canvas.height / 2);

	this.context.scale(this.scale, this.scale);
};

/**
 * Clears canvas and draws all doodles
 */
ED.Drawing.prototype.repaint = function() {
	// Clear canvas
	this.clear();

	// Draw background image (In doodle space because of transform)
	if (typeof(this.image) != 'undefined') {
		if (this.image.width >= this.image.height) {
			var height = 1000 * this.image.height / this.image.width;
			this.context.drawImage(this.image, -500, -height / 2, 1000, height);
		} else {
			var width = 1000 * this.image.width / this.image.height;
			this.context.drawImage(this.image, -width / 2, -500, width, 1000);
		}
	}

	// Redraw all doodles
	this.drawAllDoodles();

	// Go through doodles unsetting and then setting property display
	for (var i = 0; i < this.doodleArray.length; i++) {
		this.doodleArray[i].setDisplayOfParameterControls(false);
	}
	if (this.selectedDoodle != null) {
		this.selectedDoodle.setDisplayOfParameterControls(true);
	}

	// ***TODO*** ask Mark what this code is for
	if (!this.modified) {
		this.modified = true;
	}

	// Draw selection frame
	if (this.selectionRectangleIsBeingDragged) {
		// Get context
		var ctx = this.context;

		// Boundary path
		ctx.beginPath();

		// Square
		ctx.moveTo(this.selectionRectangleStart.x, this.selectionRectangleStart.y);
		ctx.lineTo(this.selectionRectangleEnd.x, this.selectionRectangleStart.y);
		ctx.lineTo(this.selectionRectangleEnd.x, this.selectionRectangleEnd.y);
		ctx.lineTo(this.selectionRectangleStart.x, this.selectionRectangleEnd.y);

		// Close path
		ctx.closePath();

		// Set line attributes
		ctx.lineWidth = 1;
		ctx.strokeStyle = "gray";

		ctx.stroke();
	}

	// Notify
	this.notify("drawingRepainted");
};

/**
 * Calculates angle between three points (clockwise from _pointA to _pointB in radians)
 *
 * @param {Point} _pointA First point
 * @param {Point} _pointM Mid point
 * @param {Point} _pointB Last point
 * @returns {Float} Angle between three points in radians (clockwise)
 */
ED.Drawing.prototype.innerAngle = function(_pointA, _pointM, _pointB) {
	// Get vectors from midpoint to A and B
	var a = new ED.Point(_pointA.x - _pointM.x, _pointA.y - _pointM.y);
	var b = new ED.Point(_pointB.x - _pointM.x, _pointB.y - _pointM.y);

	return a.clockwiseAngleTo(b);
};

/**
 * Toggles drawing state for drawing points in line
 */
ED.Drawing.prototype.togglePointInLine = function() {
	if (this.newPointOnClick) {
		this.newPointOnClick = false;
		this.completeLine = true;
		this.deselectDoodles();
		this.repaint();
	} else {
		this.newPointOnClick = true;
		this.completeLine = false;
	}
};

/**
 * Generates a numeric id guaranteed to be unique for the lifetime of the drawing object
 * (Index of doodleArray could be repeated if a doodle is deleted before adding another)
 *
 * @returns {Int} Id of next doodle
 */
ED.Drawing.prototype.nextDoodleId = function() {
	return this.lastDoodleId++;
};

ED.Drawing.prototype.getScaleLevel = function() {
	return this.globalScaleFactor;
};

/**
 * Changes the drawing colour of freehand drawing
 *
 * @param {Object} _colour Colour object
 * @returns {String} _hexColour A string describing the colour to use for freehand drawing
 */
// ED.Drawing.prototype.setSquiggleColour = function(_colour) {
//	this.squiggleColour = _colour;
//
//	this.refreshSquiggleSettings()
// }

/**
 * Changes the line width for freehand drawing
 *
 * @returns {Int} _hexColour A number describing the width
 */
// ED.Drawing.prototype.setSquiggleWidth = function(_width) {
//	this.squiggleWidth = _width;
//
//	this.refreshSquiggleSettings()
// }

/**
 * Changes the line width for freehand drawing
 *
 * @returns {int} _style A string describing the style to use for freehand drawing
 */
// ED.Drawing.prototype.setSquiggleStyle = function(_style) {
//	this.squiggleStyle = _style;
//
//	this.refreshSquiggleSettings()
// }

/**
 * Refreshes the display of settings for freehand drawing
 *
 * @returns {String} _hexColour A string describing the colour to use for freehand drawing
 */
// ED.Drawing.prototype.refreshSquiggleSettings = function() {
//	// Get reference to canvas
//	var displayCanvas = document.getElementById("squiggleSettings" + this.idSuffix);
//
//	if (displayCanvas) {
//		// Get context
//		var ctx = displayCanvas.getContext('2d');
//
//		// Reset canvas
//		displayCanvas.width = displayCanvas.width;
//		ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
//
//		// Set colours
//		ctx.strokeStyle = this.squiggleColour.rgba();
//		ctx.fillStyle = this.squiggleColour.rgba();;
//
//		// Line width
//		ctx.beginPath();
//		ctx.moveTo(3, 8);
//		ctx.lineTo(20, 8);
//		ctx.lineWidth = this.squiggleWidth / 2;
//		ctx.stroke();
//
//		// Outline or solid
//		ctx.beginPath();
//		ctx.rect(5, 19, 13, 8);
//		ctx.lineWidth = 3;
//		ctx.stroke();
//		if (this.squiggleStyle == ED.squiggleStyle.Solid) {
//			ctx.fill();
//		}
//	}
// }

///**
// * Static class to implement groups of doodles
// *
// * @returns {String}
// */
//ED.DoodleGroups =
//{
//		bar: function (val)
//		{
//				console.log(val);
//		},
//		foo: 2
//}
//
//ED.DoodleGroups.foo = 4;

/**
 * Doodles are components of drawings which have built in knowledge of what they represent, and how to behave when manipulated;
 * Doodles are drawn in the 'doodle plane' consisting of 1001 pixel square grid with central origin (ie -500 to 500) and
 * are rendered in a canvas element using a combination of the affine transform of the host drawing, and the doodle's own transform.
 * @namespace ED.Doodle
 * @memberOf ED
 * @property {Drawing} drawing Drawing to which this doodle belongs
 * @property {Int} originX X coordinate of origin in doodle plane
 * @property {Int} originY Y coordinate of origin in doodle plane
 * @property {Float} radius of doodle from origin (used for some rotatable doodles that are fixed at origin)
 * @property {Int} apexX X coordinate of apex in doodle plane
 * @property {Int} apexY Y coordinate of apex in doodle plane
 * @property {Float} scaleX Scale of doodle along X axis
 * @property {Float} scaleY Scale of doodle along Y axis
 * @property {Float} arc Angle of arc for doodles that extend in a circular fashion
 * @property {Float} rotation Angle of rotation from 12 o'clock
 * @property {Int} order Order in which doodle is drawn (0 first ie backmost layer)
 * @property {Array} squiggleArray Array containing squiggles (freehand drawings)
 * @property {AffineTransform} transform Affine transform which handles the doodle's position, scale and rotation
 * @property {AffineTransform} inverseTransform The inverse of transform
 * @property {Bool} isLocked True if doodle is locked (temporarily unselectable)
 * @property {Bool} isSelectable True if doodle is non-selectable
 * @property {Bool} isShowHighlight True if doodle shows a highlight when selected
 * @property {Bool} willStaySelected True if selection persists on mouseup
 * @property {Bool} isDeletable True if doodle can be deleted
 * @property {Bool} isSaveable Flag indicating whether doodle will be included in saved JSON string
 * @property {Bool} isOrientated True if doodle should always point to the centre (default = false)
 * @property {Bool} isScaleable True if doodle can be scaled. If false, doodle increases its arc angle
 * @property {Bool} isSqueezable True if scaleX and scaleY can be independently modifed (ie no fixed aspect ratio)
 * @property {Bool} isMoveable True if doodle can be moved. When combined with isOrientated allows automatic rotation.
 * @property {Bool} isRotatable True if doodle can be rotated
 * @property {Bool} isDrawable True if doodle accepts freehand drawings
 * @property {Bool} isUnique True if only one doodle of this class allowed in a drawing
 * @property {Bool} isArcSymmetrical True if changing arc does not change rotation
 * @property {Bool} addAtBack True if new doodles are added to the back of the drawing (ie first in array)
 * @property {Bool} isPointInLine True if centre of all doodles with this property should be connected by a line segment
 * @property {Bool} snapToGrid True if doodle should snap to a grid in doodle plane
 * @property {Bool} snapToQuadrant True if doodle should snap to a specific position in quadrant (defined in subclass)
 * @property {Bool} snapToPoints True if doodle should snap to one of a set of specific points
 * @property {Bool} snapToAngles True if doodle should snap to one of a set of specific rotation values
 * @property {Array} pointsArray Array of points to snap to
 * @property {Array} anglesArray Array of angles to snap to
 * @property {Bool} willReport True if doodle responds to a report request (can be used to suppress reports when not needed)
 * @property {Bool} willSync Flag used to indicate whether doodle will synchronise with another doodle
 * @property {Float} radius Distance from centre of doodle space, calculated for doodles with isRotable true
 * @property {Bool} isSelected True if doodle is currently selected
 * @property {Bool} isBeingDragged Flag indicating doodle is being dragged
 * @property {Int} draggingHandleIndex index of handle being dragged
 * @property {Range} draggingHandleRing Inner or outer ring of dragging handle
 * @property {Bool} isClicked Hit test flag
 * @property {Enum} drawFunctionMode Mode for boundary path
 * @property {Bool} isFilled True if boundary path is filled as well as stroked
 * @property {Bool} showsToolTip Shows a tooltip if true
 * @property {Int} frameCounter Keeps track of how many animation frames have been drawn
 * @property {Array} handleArray Array containing handles to be rendered
 * @property {Point} leftExtremity Point at left most extremity of doodle (used to calculate arc)
 * @property {Point} rightExtremity Point at right most extremity of doodle (used to calculate arc)
 * @property {Int} gridSpacing Separation of grid elements
 * @property {Int} gridDisplacementX Displacement of grid matrix from origin along x axis
 * @property {Int} gridDisplacementY Displacement of grid matrix from origin along y axis
 * @property {Float} version Version of doodle
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 * @param {Int} _order
 * @param {Object} linkedDoodleParameters
 */
ED.Doodle = function(_drawing, _parameterJSON) {
	// Function called as part of prototype assignment has no parameters passed
	if (typeof(_drawing) !== 'undefined') {
		// Drawing containing this doodle
		this.drawing = _drawing;

		// Unique ID of doodle within this drawing
		this.id = this.drawing.nextDoodleId();

		// can override with 'stroke' to support line hit testing
		this.hitTestMethod = 'path';

		// Optional array of squiggles
		this.squiggleArray = new Array();

		// Transform used to draw doodle (includes additional transforms specific to the doodle)
		this.transform = new ED.AffineTransform();
		this.inverseTransform = new ED.AffineTransform();

		// Store created time
		this.createdTime = (new Date()).getTime();

		// Set initial scale level (the scale level will be adjusted later only once
		// params have been set)
		this.scaleLevel = 1;

		// Object indexed by linked doodle class name to define parameters that should be synced between the doodles
		// primarily for the benefit of cross section doodles
		// TODO: see if we can subclass to a cross section doodle and include in that instead
		this.linkedDoodleParameters = {};

		// Dragging defaults - set individual values in subclasses
		this.isLocked = false;
		this.isSelectable = true;
		this.isShowHighlight = true;
		this.willStaySelected = true;
		this.isDeletable = true;
		this.isSaveable = true;
		this.isOrientated = false;
		this.isScaleable = true;
		this.isSqueezable = false;
		this.isMoveable = true;
		this.isRotatable = true;
		this.isDrawable = false;
		this.isUnique = false;
		this.isArcSymmetrical = false;
		this.addAtBack = false;
		this.isPointInLine = false;
		this.snapToGrid = false;
		this.snapToQuadrant = false;
		this.snapToPoints = false;
		this.snapToAngles = false;
		this.snapToArc = false;
		this.willReport = true;
		this.willSync = true;

		// Calculate maximum range of origin:
		var halfWidth = Math.round(this.drawing.doodlePlaneWidth / 2);
		var halfHeight = Math.round(this.drawing.doodlePlaneHeight / 2);

		// Parameter validation array
		this.parameterValidationArray = {
			originX: {
				kind: 'simple',
				type: 'int',
				range: new ED.Range(-halfWidth, +halfWidth),
				defaultValue: +0,
				delta: 15
			},
			originY: {
				kind: 'simple',
				type: 'int',
				range: new ED.Range(-halfHeight, +halfHeight),
				defaultValue: +0,
				delta: 15
			},
			width: {
				kind: 'simple',
				type: 'int',
				range: new ED.Range(+100, +halfHeight),
				defaultValue: +50,
				delta: 15
			},
			height: {
				kind: 'simple',
				type: 'int',
				range: new ED.Range(+100, +halfWidth),
				defaultValue: +50,
				delta: 15
			},
			radius: {
				kind: 'simple',
				type: 'float',
				range: new ED.Range(+100, +450),
				precision: 6,
				defaultValue: +100,
				delta: 15
			},
			apexX: {
				kind: 'simple',
				type: 'int',
				defaultValue: +0,
				range: new ED.Range(-500, +500),
				delta: 15
			},
			apexY: {
				kind: 'simple',
				type: 'int',
				range: new ED.Range(-500, +500),
				defaultValue: +0,
				delta: 15
			},
			scaleX: {
				kind: 'simple',
				type: 'float',
				range: new ED.Range(+0.5, +4.0),
				precision: 6,
				defaultValue: +1,
				delta: 0.1
			},
			scaleY: {
				kind: 'simple',
				type: 'float',
				range: new ED.Range(+0.5, +4.0),
				precision: 6,
				defaultValue: +1,
				delta: 0.1
			},
			arc: {
				kind: 'simple',
				type: 'float',
				range: new ED.Range(Math.PI / 12, Math.PI * 2),
				precision: 6,
				defaultValue: Math.PI,
				delta: 0.1
			},
			rotation: {
				kind: 'simple',
				type: 'float',
				range: new ED.Range(0, 2 * Math.PI),
				precision: 6,
				defaultValue: +0,
				delta: 0.2
			},
		};

		// Optional array for saving non-bound parameters
		if (!this.savedParameterArray) {
			this.savedParameterArray = [];
		}

		// Optional array for parameters linked to elements in doodle control panel
		if (!this.controlParameterArray) {
			this.controlParameterArray = [];
		}

		// Optional array for saving details of object parameters for reconstitution from string
		if (!this.parameterObjectTypeArray) {
			this.parameterObjectTypeArray = [];
		}

		// Grid properties
		this.gridSpacing = 200;
		this.gridDisplacementX = 0;
		this.gridDisplacementY = 0;

		// Flags and other properties
		this.isBeingDragged = false;
		this.draggingHandleIndex = null;
		this.draggingHandleRing = null;
		this.isClicked = false;
		this.drawFunctionMode = ED.drawFunctionMode.Draw;
		this.isFilled = true;
		this.showsToolTip = true;
		this.derivedParametersArray = new Array(); // Array relating special parameters to corresponding common parameter
		this.animationFrameRate = 30; // Frames per second
		this.animationDataArray = new Array(); // Associative array, key = parameter name, value = array with animation info
		this.parentClass = ""; // Class of parent that a doodle is dependent on (parent auto-created)
		this.inFrontOfClassArray = new Array(); // Array of classes to put this doodle in front of (in order)

		// Array of points to snap to
		this.pointsArray = new Array();
		this.anglesArray = new Array();
		this.arcArray = new Array();
		this.quadrantPoint = new ED.Point(200, 200);

		// Bindings to HTML element values. Associative array with parameter name as key
		this.bindingArray = new Array();
		this.drawing.listenerArray[this.id] = new Array();

		// Array of 5 handles
		this.handleArray = new Array();
		this.handleArray[0] = new ED.Doodle.Handle(new ED.Point(-50, 50), false, ED.Mode.Scale, false);
		this.handleArray[1] = new ED.Doodle.Handle(new ED.Point(-50, -50), false, ED.Mode.Scale, false);
		this.handleArray[2] = new ED.Doodle.Handle(new ED.Point(50, -50), false, ED.Mode.Scale, false);
		this.handleArray[3] = new ED.Doodle.Handle(new ED.Point(50, 50), false, ED.Mode.Scale, false);
		this.handleArray[4] = new ED.Doodle.Handle(new ED.Point(this.apexX, this.apexY), false, ED.Mode.Apex, false);
		this.setHandles();

		// Extremities
		this.leftExtremity = new ED.Point(-100, -100);
		this.rightExtremity = new ED.Point(0, -100);

		// Version
		this.version = +1.1;

		// Set dragging default settings
		this.setPropertyDefaults();

		// Assign default values to simple parameters
		for (var parameter in this.parameterValidationArray) {
			var validation = this.parameterValidationArray[parameter];
			if (validation.kind == 'simple') {
				this[parameter] = validation.defaultValue;
			}
		}

		// New doodle (constructor called with _drawing parameter only)
		if (typeof(_parameterJSON) == 'undefined') {

			// Default is to put new doodle in front
			this.order = this.drawing.doodleArray.length;

			// Other initialisation
			this.setParameterDefaults();

			// Set the scale level and adjust params.
			this.setScaleLevel(this.drawing.globalScaleFactor);

			// Newly added doodles are selected
			this.isSelected = true;
		}
		// Doodle with passed parameters
		else {
			// Iterate array assigning values from passed array (arc and rotation are stored in degrees for legacy reasons)
			for (var p in _parameterJSON) {

				// Skip setting the scaleLevel. The initial scaleLevel should always be 1,
				// and we should use the setScaleLevel() method for adjusting values based on scale.
				if (p === 'scaleLevel') continue;

				// Parameters arc and rotation are stored in degrees
				if (p == 'arc' || p == 'rotation') {
					this[p] = _parameterJSON[p] * Math.PI / 180;
				}
				// Squiggles
				else if (p == 'squiggleArray') {
					var squiggleArray = _parameterJSON[p];
					for (var j = 0; j < squiggleArray.length; j++) {
						// Get parameters and create squiggle
						var c = squiggleArray[j].colour;
						var colour = new ED.Colour(c.red, c.green, c.blue, c.alpha);
						var thickness = squiggleArray[j].thickness;
						var filled = squiggleArray[j].filled;
						var squiggle = new ED.Squiggle(this, colour, thickness, filled);

						// Add points to squiggle and complete it
						var pointsArray = squiggleArray[j].pointsArray;
						for (var k = 0; k < pointsArray.length; k++) {
							var point = undefined;
							if (!isNaN(parseFloat(pointsArray[k].x)) && !isNaN(parseFloat(pointsArray[k].y))) {
                                point = new ED.Point(pointsArray[k].x, pointsArray[k].y);
							}
							squiggle.addPoint(point);
						}
						squiggle.complete = true;

						// Add squiggle to doodle's squiggle array
						this.squiggleArray.push(squiggle);
					}
				}
				// Saved parameters (V1.3 method - keep for legacy data)
				else if (p == 'params') {
					for (var j = 0; j < _parameterJSON[p].length; j++) {
						var param_name = _parameterJSON[p][j].name;
						var param_value = _parameterJSON[p][j].value;
						this.setParameterFromString(param_name, param_value);
					}
				}
				// Other parameters
				else {
					// Complex objects (e.g. date)
					if (p in this.parameterObjectTypeArray) {
						this[p] = this.parseObjectString(_parameterJSON[p], this.parameterObjectTypeArray[p]);
					}
					// Other parameters are simple assignments
					else {
						this[p] = _parameterJSON[p];
					}
				}
			}

			// Set orientation if appropriate
			if (this.isOrientated) {
				this.rotation = this.orientation();
			}

			// Order
			this.order = +_parameterJSON['order'];

			// Update values of any derived parameters
			// 			for (var parameter in this.parameterValidationArray) {
			// 				var validation = this.parameterValidationArray[parameter];
			// 				if (validation.kind == 'simple') {
			// 					this.updateDependentParameters(parameter);
			// 				}
			// 			}

			// Set the scale level and adjust params.
			this.setScaleLevel(this.drawing.globalScaleFactor);

			for (var p in this.savedParameterArray) {
				this.updateDependentParameters(this.savedParameterArray[p]);
			}

			// Loaded doodles are not selected
			this.isSelected = false;
			this.isForDrawing = false;
		}
	}
};

/**
 * Parses JSON string to reconstitute parameters which are entries in this.parameterObjectTypeArray
 *
 * @param {String} _string String containing object from JSON string
 * @param {String} _type Type of object
 */
ED.Doodle.prototype.parseObjectString = function(_string, _type) {
	var returnObject = false;
	switch (_type) {
		case 'date':
			var a = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(_string);
			returnObject = new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4], +a[5], +a[6]));
			break;

		default:
			ED.errorHandler('ED.Doodle', 'parseObjectString', 'Object type: ' + _type + ' currently not supported');
			break;
	}

	return returnObject;
};

/**
 * Sets default handle attributes (overridden by subclasses)
 */
ED.Doodle.prototype.setHandles = function() {};

/**
 * Sets default properties (overridden by subclasses)
 */
ED.Doodle.prototype.setPropertyDefaults = function() {};

/**
 * Sets default parameters (overridden by subclasses)
 */
ED.Doodle.prototype.setParameterDefaults = function() {};

/**
 * Sets position in array relative to other relevant doodles (overridden by subclasses)
 */
ED.Doodle.prototype.position = function() {};

/**
 * Called on attempt to delete doodle, and returns permission (overridden by subclasses)
 *
 * @returns {Bool} True if OK to delete
 */
ED.Doodle.prototype.willDelete = function() {
	return true;
};

/**
 * Moves doodle and adjusts rotation as appropriate
 *
 * @param {Float} _x Distance to move along x axis in doodle plane
 * @param {Float} _y Distance to move along y axis in doodle plane
 */
ED.Doodle.prototype.move = function(_x, _y) {

	// Ensure parameters are integers
	var x = Math.round(+_x);
	var y = Math.round(+_y);

	if (this.isMoveable) {
		// Enforce bounds
		var newOriginX = this.parameterValidationArray['originX']['range'].constrain(this.originX + x, this.scaleLevel);
		var newOriginY = this.parameterValidationArray['originY']['range'].constrain(this.originY + y, this.scaleLevel);

		// Move doodle to new position
		if (x != 0) this.setSimpleParameter('originX', newOriginX);
		if (y != 0) this.setSimpleParameter('originY', newOriginY);

		// Update dependencies
		this.updateDependentParameters('originX');
		this.updateDependentParameters('originY');

		// Only need to change rotation if doodle has moved
		if (x != 0 || y != 0) {
			// If doodle isOriented is true, rotate doodle around centre of canvas (eg makes 'U' tears point to centre)
			if (this.isOrientated) {

				// Alter orientation of doodle
				this.setSimpleParameter('rotation', this.orientation());

				// Update dependencies
				this.updateDependentParameters('rotation');
			}
		}

		// Notify (NB pass doodle in message array, since this is not necessarily selected)
		this.drawing.notify("doodleMoved", {
			doodle: this
		});
	}
};

/**
 * Calculates orientation based on x and y coordinates of doodle
 *
 * @returns {Float} Orientation in radians
 */
ED.Doodle.prototype.orientation = function() {
	// Get position of centre of display (canvas plane relative to centre) and of an arbitrary point vertically above
	var canvasCentre = new ED.Point(0, 0);
	var canvasTop = new ED.Point(0, -100);

	// New position of doodle
	var newDoodleOrigin = new ED.Point(this.originX, this.originY);

	// Calculate angle to current position from centre relative to north
	return this.drawing.innerAngle(canvasTop, canvasCentre, newDoodleOrigin);
};

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Doodle.prototype.draw = function(_point) {
	// Determine function mode
	if (typeof(_point) != 'undefined') {
		this.drawFunctionMode = ED.drawFunctionMode.HitTest;
	} else {
		this.drawFunctionMode = ED.drawFunctionMode.Draw;
	}

	// Get context
	var ctx = this.drawing.context;

	// Augment transform with properties of this doodle
	ctx.translate(this.originX, this.originY);
	ctx.rotate(this.rotation);
	ctx.scale(this.scaleX, this.scaleY);

	// Mirror with internal transform
	this.transform.setToTransform(this.drawing.transform);
	this.transform.translate(this.originX, this.originY);
	this.transform.rotate(this.rotation);
	this.transform.scale(this.scaleX, this.scaleY);

	// Update inverse transform
	this.inverseTransform = this.transform.createInverse();

	// Reset hit test flag
	this.isClicked = false;
};

/**
 * Draws selection handles and sets dragging mode which is determined by which handle and part of handle is selected
 * Function either performs a hit test or draws the handles depending on whether a valid Point object is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Doodle.prototype.drawHandles = function(_point) {
	// Reset handle index and selected ring
	if (this.drawFunctionMode == ED.drawFunctionMode.HitTest) {
		this.draggingHandleIndex = null;
		this.draggingHandleRing = null;
	}

	// Get context
	var ctx = this.drawing.context;

	// Save context to stack
	ctx.save();

	// Reset context transform to identity matrix
	ctx.setTransform(1, 0, 0, 1, 0, 0);

	// Dimensions and colour of handles
	ctx.lineWidth = 1;
	ctx.strokeStyle = "red";
	ctx.fillStyle = "yellow";

	// Draw corner handles
	var arc = Math.PI * 2;

	for (var i = 0; i < this.handleArray.length; i++) {
		var handle = this.handleArray[i];

		if (handle.isVisible) {
			// Path for inner ring
			ctx.beginPath();
			ctx.arc(handle.location.x, handle.location.y, ED.handleRadius / 2, 0, arc, true);

			// Hit testing for inner ring
			if (this.drawFunctionMode == ED.drawFunctionMode.HitTest) {
				if (ctx.isPointInPath(_point.x, _point.y)) {
					this.draggingHandleIndex = i;
					this.draggingHandleRing = ED.handleRing.Inner;
					this.drawing.mode = handle.mode;
					this.isClicked = true;
				}
			}

			// Path for optional outer ring
			if (this.isRotatable && handle.isRotatable) {
				ctx.moveTo(handle.location.x + ED.handleRadius, handle.location.y);
				ctx.arc(handle.location.x, handle.location.y, ED.handleRadius, 0, arc, true);

				// Hit testing for outer ring
				if (this.drawFunctionMode == ED.drawFunctionMode.HitTest) {
					if (ctx.isPointInPath(_point.x, _point.y)) {
						this.draggingHandleIndex = i;
						if (this.draggingHandleRing == null) {
							this.draggingHandleRing = ED.handleRing.Outer;
							this.drawing.mode = ED.Mode.Rotate;
						}
						this.isClicked = true;
					}
				}
			}

			// Draw handles
			if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
				ctx.fill();
				ctx.stroke();
			}
		}
	}

	// Restore context
	ctx.restore();
};

ED.Doodle.prototype.hitTest = function(ctx, _point)
{
	var result;
    // Workaround for Mozilla bug 405300 https://bugzilla.mozilla.org/show_bug.cgi?id=405300
    if (ED.isFirefox()) {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        result = this.hitTestMethod === 'stroke' ? ctx.isPointInStroke(_point.x, _point.y) : ctx.isPointInPath(_point.x, _point.y);
        ctx.restore();
    } else {
        result = this.hitTestMethod === 'stroke' ? ctx.isPointInStroke(_point.x, _point.y) : ctx.isPointInPath(_point.x, _point.y);
    }
    return result;
};

/**
 * Draws the boundary path or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Doodle.prototype.drawBoundary = function(_point, mode) {
	if (mode === undefined) {
		mode = this.drawFunctionMode;
	}
	// Get context
	var ctx = this.drawing.context;
	// HitTest
	if (mode == ED.drawFunctionMode.HitTest) {
		if (this.hitTest(ctx, _point)) {
			// Set dragging mode
			if (this.isDrawable && this.isForDrawing) {
				this.drawing.mode = ED.Mode.Draw;
			} else {
				this.drawing.mode = ED.Mode.Move;
			}

			// Set flag indicating positive hit test
			this.isClicked = true;
		}
	}
	// Drawing
	else {
		// Specify highlight attributes
		if (this.isSelected && this.isShowHighlight) {
            ctx.shadowColor = "gray";
			ctx.shadowOffsetX = 0;
			ctx.shadowOffsetY = 0;
			ctx.shadowBlur = 20;
		}

		// Specify highlight attributes
		if (this.isForDrawing) {
			ctx.shadowColor = "blue";
			ctx.shadowOffsetX = 0;
			ctx.shadowOffsetY = 0;
			ctx.shadowBlur = 20;
		}

		// Fill path and draw it
		if (this.isFilled) {
			ctx.fill();
		}
		ctx.stroke();

		// Reset so shadow only on boundary
		ctx.shadowBlur = 0;

		// Draw any additional highlight items
		if (this.isSelected && this.isShowHighlight) {
			this.drawHighlightExtras();
		}
	}
};

/**
 * Draws extra items if the doodle is highlighted
 */
ED.Doodle.prototype.drawHighlightExtras = function() {
};

/**
 * Shows doodle parameter controls. Doodle must set display:true in parameterValidationArray
 *
 * @param {Bool} _flag Flag determining whether display is shown or not shown
 */
ED.Doodle.prototype.setDisplayOfParameterControls = function(_flag) {
	for (var parameter in this.parameterValidationArray) {
		var validation = this.parameterValidationArray[parameter];
		if (validation.display) {
			// Construct id of element
			var id = parameter + this.className + this.drawing.idSuffix;

			// Look for corresponding element and toggle display
			var element = document.getElementById(id);
			if (element) {
				// Get parent label
				var label = element.parentNode;
				if (_flag) {
					label.style.display = 'inline';
				} else {
					label.style.display = 'none';
				}

				// Ensure value of checkbox matches value of property
				element.checked = this[parameter];
			}
		}
	}
};

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.Doodle.prototype.groupDescription = function() {
	return "";
};

/**
 * Runs when doodle is selected by the user
 */
// ED.Doodle.prototype.onSelection = function() {
// }

/**
 * Runs when doodle is deselected by the user
 */
// ED.Doodle.prototype.onDeselection = function() {
// }

/**
 * Returns a string containing a text description of the doodle (overridden by subclasses)
 *
 * @returns {String} Description of doodle
 */
ED.Doodle.prototype.description = function() {
	return "";
};

/**
 * Returns a String which, if not empty, determines the suffix following a group description
 *
 * @returns {String} Group description end
 */
ED.Doodle.prototype.groupDescriptionEnd = function() {
	return "";
};

/**
 * Returns the SnoMed code of the doodle (overridden by subclasses)
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.Doodle.prototype.snomedCode = function() {
	return 0;
};

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest) (overridden by subclasses)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.Doodle.prototype.diagnosticHierarchy = function() {
	return 0;
};

/**
 * Should be overridden for doodles that can provide multiple SNOMEDs - each should be paired with with a
 * diagnostic hierarchy value for appropriate ordering.
 *
 * @returns {Array}
 */
ED.Doodle.prototype.snomedCodes = function() {
	return new Array([this.snomedCode(), this.diagnosticHierarchy()]);
};

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.Doodle.prototype.dependentParameterValues = function(_parameter, _value) {
	return new Array();
};

/**
 * Updates dependent parameters
 *
 * @param {String} _parameter Name of parameter for which dependent parameters will be updated
 * @param {Boolean} _updateBindings Update the doodle form control bindings?
 */
ED.Doodle.prototype.updateDependentParameters = function(_parameter, _updateBindings) {
	// Retrieve list of dependent parameters and set them
	var valueArray = this.dependentParameterValues(_parameter, this[_parameter]);
	for (var parameter in valueArray) {
		this.setSimpleParameter(parameter, valueArray[parameter]);
	}

	// Update bindings
	if (_updateBindings || _updateBindings === undefined) {
		this.drawing.updateBindings(this);
	}
};

/**
 * Validates the value of a parameter, and returns it in appropriate format
 * If value is invalid, returns a constrained value or the original value
 * Called by event handlers of HTML elements
 *
 * @param {String} _parameter Name of the parameter
 * @param {Undefined} _value Value of the parameter to validate
 * @param {Boolean} _trim=true Trim the value prior to validation
 * @returns {Array} Array containing a bool indicating validity, and the correctly formatted value of the parameter
 */
ED.Doodle.prototype.validateParameter = function(_parameter, _value, _trim) {

	_trim = _trim === undefined ? true : _trim;

	// Retrieve validation object for this doodle
	var validation = this.parameterValidationArray[_parameter];

	// Set return value;
	var value = "";

	if (validation) {
		// Validity flag
		var valid = false;

		// Enforce string type and optionally trim it
		value = _value.toString();
		if (_trim) {
			value = value.trim();
		}

		switch (validation.type) {
			case 'string':

				// Check that its in list of valid values
				if (validation.list.indexOf(value) >= 0) {
					valid = true;
				}
				break;

			case 'float':

				// Test that value is a number
				if (ED.isNumeric(value)) {
					// Convert string to float value
					value = parseFloat(value);

					// Constrain value to allowable range
					value = validation.range.constrain(value);

					// Convert back to string, applying any formatting
					value = value.toFixed(validation.precision);

					valid = true;
				}
				break;

			case 'int':

				// Test that value is a number, and if not reset to current value of doodle
				if (ED.isNumeric(value)) {
					// Convert string to float value
					value = parseInt(value);

					// Constrain value to allowable range
					value = validation.range.constrain(value);

					// Convert back to string, applying any formatting
					value = value.toFixed(0);

					valid = true;
				}
				break;

			case 'mod':

				// Test that value is a number, and if not reset to current value of doodle
				if (ED.isNumeric(value)) {
					// Convert string to float value
					value = parseInt(value);

					// Constrain value to allowable range
					value = validation.range.constrain(value);

					// Deal with crossover
					if (validation.clock == 'top') {
						if (value == validation.range.min) value = validation.range.max;
					} else if (validation.clock == 'bottom') {
						if (value == validation.range.max) value = validation.range.min;
					}

					// Convert back to string, applying any formatting
					value = value.toFixed(0);

					valid = true;
				}
				break;

			case 'bool':

				// Event handler detects check box type and returns checked attribute
				if (_value == 'true' || _value == 'false') {
					// Convert to string for compatibility with setParameterFromString method
					value = _value;
					valid = true;
				}
				break;

			case 'colourString':
				// ***TODO*** Add some actual validation here
				valid = true;
				break;

			case 'freeText':
				valid = true;
				if (validation.validate && typeof validation.validate === 'function') {
					valid = validation.validate(_value);
				}
				else if (validation.maxLength !== undefined) {
					valid = (_value.length <= validation.maxLength);
				}
				break;

			default:
				ED.errorHandler('ED.Drawing', 'eventHandler', 'Illegal validation type');
				break;
		}
	} else {
		ED.errorHandler('ED.Doodle', 'validateParameter', 'Unknown parameter name: ' + _parameter + ' with value: ' + _value);
	}

	// If not valid, get current value of parameter
	if (!valid) {
		value = this.getParameter(_parameter);
		ED.errorHandler('ED.Doodle', 'validateParameter', 'Validation failure for parameter: ' + _parameter + ' with value: ' + _value);
	}

	// Show validation message/s
	this.showControlValidationMsg(_parameter, valid);

	// Return validity and value
	var returnArray = new Array();
	returnArray['valid'] = valid;
	returnArray['value'] = value;
	return returnArray;
};

/**
 * Generates a unique id for a control element bound to a parameter ***TODO*** improve this
 *
 * @param {String} _parameter Name of the parameter
 * @returns {String} ID for a control element
 */
ED.Doodle.prototype.parameterControlElementId = function(_parameter) {
	return this.drawing.canvas.id + '_' + _parameter + '_control';
};

/**
 * Runs when doodle is selected by the user
 */
ED.Doodle.prototype.onSelection = function() {
	// Show control bar
	if (this.drawing.showDoodleControls) {
		this.showDoodleControls();
	}
};

/**
 * Runs when doodle is deselected by the user
 */
ED.Doodle.prototype.onDeselection = function() {
	// Hide control bar
	if (this.drawing.showDoodleControls) {
		this.removeDoodleControls();
	}
};

/**
 * Creates an array of control elements
 * @return {Array}    The array of elements.
 */
ED.Doodle.prototype.getControlElements = function() {
	var elements = [];
	for (var parameter in this.controlParameterArray) {
		// Create element
		elements.push(
			this.parameterElement(parameter)
		);
	}
	return elements;
};

/**
 * Add bindings to the control elements.
 */
ED.Doodle.prototype.addControlBindings = function() {
	for (var parameter in this.controlParameterArray) {
		if (!parameter in this.parameterValidationArray) {
			continue;
		}
		if (this.parameterValidationArray[parameter].type == 'combo') {
			for (var i in this.parameterValidationArray[parameter].list) {
				var childParam = this.parameterValidationArray[parameter].list[i];
				this.addBinding(childParam, {
					id: this.parameterControlElementId(childParam)
				});
			}
		} else {
			this.addBinding(parameter, {
				id: this.parameterControlElementId(parameter)
			});
		}
	}
};

/**
 * Show a validation msg for a param that has a bound field control, only if the
 * associated form elements exist.
 * @param  {String} _parameter Parameter name
 * @param  {Boolean} _valid     Is the parameter value valid?
 */
ED.Doodle.prototype.showControlValidationMsg = function(_parameter, _valid) {

	if (!(_parameter in this.controlParameterArray)) {
		return;
	}

	var elementId = this.parameterControlElementId(_parameter);

	var label = document.querySelector('[for='+elementId+']');
	if (!label) return;

	var msg = label.querySelector('.validation-msg');
	if (!msg) return;

	if (_valid) {
		if (msg) msg.parentNode.removeChild(msg);
	} else {
		if (!msg) {
			msg = document.createElement('span');
			label.appendChild(msg);
			msg.classList.add('validation-msg');
		}
		msg.textContent = '*';
	}
};

/**
 * Generate and append the control elements to the DOM.
 * @param  {HTMLElement} controlDiv The container element.
 */
ED.Doodle.prototype.showDoodleControls = function(controlDiv) {

	// Find the container element
	if (!controlDiv) {

		var id = this.drawing.canvas.id + '_' + 'controls';
		var controlDiv = document.getElementById(id);

		if (!controlDiv) {
			return ED.errorHandler('ED.Doodle', 'showDoodleControls', 'Unable to create doodle controls: element with id ' + id + ' does not exist');
		}
	}

	// Append controls to the container
	this.getControlElements().forEach(function(element) {
		controlDiv.appendChild(element);
	});

	// Add bindings
	this.addControlBindings();
};

/**
 * Remove controls elements.
 * @param  {HTMLElement} controlDiv The container element.
 */
ED.Doodle.prototype.removeDoodleControls = function(controlDiv) {

	// Find the container element
	if (!controlDiv) {
		var id = this.drawing.canvas.id + '_' + 'controls';
		var controlDiv = document.getElementById(id);

		if (!controlDiv) {
			return ED.errorHandler('ED.Doodle', 'removeDoodleControls', 'Unable to remove doodle controls: element with id ' + id + ' does not exist');
		}
	}

	// Remove all bindings
	for (var parameter in this.controlParameterArray) {
		this.removeBinding(parameter);
	}

	// Remove elements
	while(controlDiv.hasChildNodes()){
		controlDiv.removeChild(controlDiv.lastChild);
	}
};

/**
 * Creates an element for parameter in the doodle control bar
 *
 * @param {String} _parameter Name of the parameter
 * @returns {String} _id ID for a control element
 */
ED.Doodle.prototype.parameterElement = function(_parameter, showLabel) {
	if (showLabel === undefined)
		showLabel = true;

	var element;
	switch (this.parameterValidationArray[_parameter].type) {
		case 'combo':
			element = document.createElement('span');
			element.setAttribute('class', 'combo');
			for (var i in this.parameterValidationArray[_parameter]['list']) {
				element.appendChild(this.parameterElement(this.parameterValidationArray[_parameter]['list'][i], false));
			}
			break;
		case 'string':
			// Create a select element
			element = document.createElement('select');
			element.setAttribute('id', this.parameterControlElementId(_parameter));

			// Add options from validation array
			for (var i in this.parameterValidationArray[_parameter].list) {
				var option = document.createElement('option');
				option.innerText = this.parameterValidationArray[_parameter].list[i];
				//if (option.innerText == this[_parameter]) option.selected = true;
				element.appendChild(option);
			}
			break;

		case 'bool':
			// Create a checkbox element
			element = document.createElement('input');
    		element.type = 'checkbox';
    		element.setAttribute('id', this.parameterControlElementId(_parameter));
    		break;

		case 'colourString':
			// Create a colour picker
			element = document.createElement('select');
			element.setAttribute('id', this.parameterControlElementId(_parameter));

			// Add options from validation array
			for (var i in this.parameterValidationArray[_parameter].list) {
				var option = document.createElement('option');
				// Hack until colour picker worked out
				if (this.parameterValidationArray[_parameter].list[i] == "FF0000FF") {
					option.innerText = "Red";
				}
				else if (this.parameterValidationArray[_parameter].list[i] == "00FF00FF") {
					option.innerText = "Green";
				}
				else {
					option.innerText = "Blue";
				}
				option.value = this.parameterValidationArray[_parameter].list[i];
				element.appendChild(option);
			}
    		break;

		case 'float':
			// Create a text input element
			element = document.createElement('input');
    		element.type = 'text';
    		element.setAttribute('id', this.parameterControlElementId(_parameter));
    		break;

		case 'int':
			// Create a text input element
			element = document.createElement('input');
    		element.type = 'text';
    		element.setAttribute('id', this.parameterControlElementId(_parameter));
    		break;

		case 'mod':
			// Create a text input element
			element = document.createElement('input');
    		element.type = 'text';
    		element.setAttribute('id', this.parameterControlElementId(_parameter));
    		break;

		case 'freeText':
			// Create a text input element
			element = document.createElement('input');
    		element.type = 'text';
    		element.setAttribute('id', this.parameterControlElementId(_parameter));
    		break;

// 		case 'radio':
// 			// Create a radio button element
// 			element = document.createElement('input');
//     		element.type = 'checkbox';
//     		element.setAttribute('id', this.parameterControlElementId(_parameter));
//     		break;

		default:
			ED.errorHandler('ED.Doodle', 'parameterElement', 'Unexpected type: ' + this.parameterValidationArray[_parameter].type + ' for parameter: ' + _parameter);
			break;
	}

	// Wrap in div to allow display in vertical block
	var div = document.createElement('div');
	if (showLabel) {
		// Create label  ***TODO*** deal with optional label and language
		var label = document.createElement('label');
		label.innerText = this.controlParameterArray[_parameter];
		label.setAttribute('for', this.parameterControlElementId(_parameter));
		div.appendChild(label);
	}
	div.appendChild(element);

	return div;
};

/**
 * Attempts to animate a change in value of a parameter
 *
 * @param {String} _parameter Name of parameter
 * @param {String} _value New value of parameter
 * @param {Boolean} _updateBindings Update the doodle form control bindings? We don't want to update the
 * bindings if the new param values originated from the bound controls.
 */
ED.Doodle.prototype.setParameterWithAnimation = function(_parameter, _value, _updateBindings) {

	// Attempt to get parameter value
	var valueArray = this.dependentParameterValues(_parameter, _value);

	// Check for animation flag and for valid result
	if (this.parameterValidationArray[_parameter]['animate'] && !ED.objectIsEmpty(valueArray)) {

			// Animate parameters
			for (var parameter in valueArray) {
				// Read delta in units per frame
				var delta = this.parameterValidationArray[parameter]['delta'];

				// Calculate 'distance' to go
				var distance = valueArray[parameter] - this[parameter];

				// Calculate sign and apply to delta
				if (parameter == 'rotation') {
					// This formula works out correct distance and direction on a radians 'clock face' (ie the shortest way round)
					var sign = ((Math.PI - Math.abs(distance)) * distance) < 0 ? -1 : 1;
					distance = distance * sign;

					// Make distance positive
					if (distance < 0) distance += 2 * Math.PI;

					// Test for roughly half way
					if (distance > 3.141) {
						if (this.rotation < Math.PI) sign = -sign;
					}
				} else {
					var sign = distance < 0 ? -1 : 1;
				}
				delta = delta * sign;

				// Calculate number of frames to animate
				var frames = Math.abs(Math.floor(distance / delta));

				// Put results into an associative array for this parameter
				var array = {
					timer: null,
					delta: delta,
					frames: frames,
					frameCounter: 0
				};
				this.animationDataArray[parameter] = array;

				// Call animation method
				if (frames > 0) {
					this.increment(parameter, valueArray[parameter], _updateBindings);
				}
				// Increment may be too small to animate, but still needs setting
				else {
					// Set  parameter to exact value
					this.setSimpleParameter(parameter, valueArray[parameter]);

					// Update dependencies
					this.updateDependentParameters(parameter, _updateBindings);

					// Refresh drawing
					this.drawing.repaint();
				}
			}
	}

	// Otherwise just set value directly
	else {
		this.setParameterFromString(_parameter, _value.toString(), _updateBindings);
	}

	this.drawing.notify("setParameterWithAnimationComplete");
};

/**
 * Set the value of a doodle's parameter directly, and triggers a notification
 *
 * @param {String} _parameter Name of parameter
 * @param {Undefined} _value New value of parameter
 */
ED.Doodle.prototype.setSimpleParameter = function(_parameter, _value) {
	// Create notification message var messageArray = {eventName:_eventName, selectedDoodle:this.selectedDoodle, object:_object};
	var object = new Object;
	object.doodle = this;
	object.parameter = _parameter;
	object.value = _value;
	object.oldValue = this[_parameter];

	// Set parameter
	this[_parameter] = _value;

	// Trigger notification
	this.drawing.notify('parameterChanged', object);
};

/**
 * Set the value of a doodle's parameter from a string format following validation
 *
 * @param {String} _parameter Name of parameter
 * @param {String} _value New value of parameter
 * @param {Boolean} _updateBindings Update form element bindings?
 */
ED.Doodle.prototype.setParameterFromString = function(_parameter, _value, _updateBindings) {
	// Check type of passed value variable
	var type = typeof(_value);
	if (type != 'string') {
		ED.errorHandler('ED.Doodle', 'setParameterFromString', '_value parameter should be of type string, not ' + type);
	}

	// Retrieve validation object for this doodle
	var validation = this.parameterValidationArray[_parameter];

	if (validation) {
		// Set value according to type of parameter
		switch (validation.type) {
			case 'string':
				this[_parameter] = _value;
				break;

			case 'float':
				this[_parameter] = parseFloat(_value);
				break;

			case 'int':
				this[_parameter] = parseInt(_value);
				break;

			case 'mod':
				this[_parameter] = parseInt(_value);
				break;

			case 'bool':
				this[_parameter] = (_value == 'true');
				break;

			case 'colourString':
				this[_parameter] = _value;
				break;

			case 'freeText':
				this[_parameter] = _value;
				break;

			default:
				ED.errorHandler('ED.Doodle', 'setParameterFromString', 'Illegal validation type: ' + validation.type);
				break;
		}

		// Update dependencies
		this.updateDependentParameters(_parameter, _updateBindings);

		// Update child dependencies of any derived parameters
		if (this.parameterValidationArray[_parameter]['kind'] == 'derived') {
			var valueArray = this.dependentParameterValues(_parameter, _value);
			for (var parameter in valueArray) {
				// Update dependencies
				this.updateDependentParameters(parameter, _updateBindings);
			}
		}

		// Create notification message var messageArray = {eventName:_eventName, selectedDoodle:this.selectedDoodle, object:_object};
		var object = new Object;
		object.doodle = this;
		object.parameter = _parameter;
		object.value = _value;
		object.oldValue = this[_parameter];

		// Trigger notification
		this.drawing.notify('parameterChanged', object);
	} else {
		ED.errorHandler('ED.Doodle', 'setParameterFromString', 'No item in parameterValidationArray corresponding to parameter: ' + _parameter);
	}

	// Refresh drawing
	this.drawing.repaint();
};

/**
 * Set the value of a doodle's origin to avoid overlapping other doodles
 *
 * @param {String} _first Displacement of first doodle
 * @param {String} _next Displacement of subsequent doodles
 */
ED.Doodle.prototype.setOriginWithDisplacements = function(_first, _next) {
	this.originX = this.drawing.eye == ED.eye.Right ? -_first : _first;
	this.originY = -_first;

	// Get last doodle to be added
	if (this.addAtBack) {
		var doodle = this.drawing.firstDoodleOfClass(this.className);
	} else {
		var doodle = this.drawing.lastDoodleOfClass(this.className);
	}

	// If there is one, make position relative to it
	if (doodle) {
		var newOriginX = doodle.originX - _next;
		var newOriginY = doodle.originY - _next;

		this.originX = this.parameterValidationArray['originX']['range'].constrain(newOriginX);
		this.originY = this.parameterValidationArray['originY']['range'].constrain(newOriginY);
	}
};

/**
 * Set the value of a doodle's origin as if rotating
 *
 * @param {Int} _radius The radius of rotation
 * @param {Int} _first Rotation in degrees of first doodle anticlockwise right eye, clockwise left eye
 * @param {Int} _next Additional rotation of subsequent doodles
 */
ED.Doodle.prototype.setOriginWithRotations = function(_radius, _first, _next) {
	var direction = this.drawing.eye == ED.eye.Right ? -1 : 1;

	var origin = new ED.Point(0,0);
	origin.setWithPolars(_radius, direction * _first * Math.PI / 180);

	// Get last doodle to be added
	if (this.addAtBack) {
		var doodle = this.drawing.firstDoodleOfClass(this.className);
	} else {
		var doodle = this.drawing.lastDoodleOfClass(this.className);
	}

	// If there is one, make position relative to it
	if (doodle) {
		var doodleOrigin = new ED.Point(doodle.originX, doodle.originY);
		origin.setWithPolars(_radius, doodleOrigin.direction() + direction * _next * Math.PI / 180);
	}

	this.originX = origin.x;
	this.originY = origin.y;
};

/**
 * Set the value of a doodle's rotation to avoid overlapping other doodles
 *
 * @param {int} _first Rotation in degrees of first doodle anticlockwise right eye, clockwise left eye
 * @param {int} _next Additional rotation of subsequent doodles
 */
ED.Doodle.prototype.setRotationWithDisplacements = function(_first, _next) {
	var direction = this.drawing.eye == ED.eye.Right ? -1 : 1;
	var newRotation;
	var doodle;

	// Get last doodle to be added
	if (this.addAtBack) {
		doodle = this.drawing.firstDoodleOfClass(this.className);
	} else {
		doodle = this.drawing.lastDoodleOfClass(this.className);
	}

	// If there is one, make rotation relative to it
	if (doodle) {
		newRotation = ((doodle.rotation * 180 / Math.PI + direction * _next + 360) % 360) * Math.PI / 180;
	} else {
		newRotation = ((direction * _first + 360) % 360) * Math.PI / 180;
	}

	this.rotation = this.parameterValidationArray['rotation']['range'].constrain(newRotation);
};

/**
 * Deselects doodle
 */
ED.Doodle.prototype.deselect = function() {
	// Deselect
	this.isSelected = false;
	this.drawing.selectedDoodle = null;

	// Refresh drawing
	this.drawing.repaint();
};

/**
 * Returns parameter values in validated string format
 *
 * @param {String} _parameter Name of parameter
 * @returns {String} Value of parameter
 */
ED.Doodle.prototype.getParameter = function(_parameter) {
	// Retrieve validation object for this doodle
	var validation = this.parameterValidationArray[_parameter];

	// Set return value;
	var value = "";

	if (validation) {
		switch (validation.type) {
			case 'string':
				value = this[_parameter];
				break;

			case 'float':
				// Convert to string, applying any formatting
				value = this[_parameter].toFixed(validation.precision);
				break;

			case 'int':
				// Convert to string, applying any formatting
				value = this[_parameter].toFixed(0);
				break;

			case 'mod':
				// Round to integer applying any formatting
				value = Math.round(this[_parameter]);

				// Deal with crossover
				if (validation.clock == 'top') {
					if (value == validation.range.min) value = validation.range.max;
				} else if (validation.clock == 'bottom') {
					if (value == validation.range.max) value = validation.range.min;
				}

				// Convert to string
				value = value.toFixed(0);
				break;

			case 'bool':
				value = this[_parameter].toString();
				break;

			case 'colourString':
				value = this[_parameter];
				break;

			case 'freeText':
				value = this[_parameter];
				break;

			default:
				ED.errorHandler('ED.Doodle', 'getParameter', 'Illegal validation type');
				break;
		}
	} else {
		ED.errorHandler('ED.Doodle', 'getParameter', 'No entry in parameterValidationArray corresponding to parameter: ' + _parameter);
	}

	// Return value
	return value;
};

/**
 * Uses a timeout to call itself and produce the animation
 *
 * @param {String} _parameter Name of parameter
 * @param {String} _value New value of parameter
 * @param {Boolean} _updateBindings Update the doodle form control bindings?
 */
ED.Doodle.prototype.increment = function(_parameter, _value, _updateBindings) {
	// Increment parameter and framecounter
	var currentValue = this[_parameter];
	this.animationDataArray[_parameter]['frameCounter']++;

	// Calculate interval between frames in milliseconds
	var interval = 1000 / this.animationFrameRate;

	// Complete or continue animation
	if (this.animationDataArray[_parameter]['frameCounter'] == this.animationDataArray[_parameter]['frames']) {
		// Set  parameter to exact value
		this.setSimpleParameter(_parameter, _value);

		// Update dependencies
		this.updateDependentParameters(_parameter, _updateBindings);

		// Stop timer
		clearTimeout(this.animationDataArray[_parameter]['timer']);
	} else {
		// Set parameter to new value
		this.setSimpleParameter(_parameter, currentValue + this.animationDataArray[_parameter]['delta']);

		// Update dependencies
		this.updateDependentParameters(_parameter, _updateBindings);

		// Start timer and set to call this function again after interval
		var doodle = this;
		this.animationDataArray[_parameter]['timer'] = setTimeout(function() {
			doodle.increment(_parameter, _value, _updateBindings);
		}, interval);
	}

	// Refresh drawing
	this.drawing.repaint();
};

/**
 * Adds a binding to the doodle. Only derived parameters can be bound
 *
 * @param {String} _parameter Name of parameter to be bound
 * @param {String} _fieldParameters Details of bound HTML element
 */
ED.Doodle.prototype.addBinding = function(_parameter, _fieldParameters) {
	var elementId = _fieldParameters['id'];
	var attribute = _fieldParameters['attribute'];

	// Check that doodle has a parameter of this name
	if (typeof(this[_parameter]) != 'undefined') {
		// Get reference to HTML element
		var element = document.getElementById(elementId);

		// Check element exists
		if (element != null) {
			// Add binding to array
			this.bindingArray[_parameter] = {
				'id': elementId,
				'attribute': attribute
			};

			// Attach onchange event of element with a function which calls the drawing event handler
			var drawing = this.drawing;
			var id = this.id;
			var className = this.className;
			var listener;

			// Set the parameter to the value of the element, and attach a listener
			switch (element.type) {
				case 'checkbox':
					if (attribute) {
						ED.errorHandler('ED.Doodle', 'addBinding', 'Binding to a checkbox with a non-standard attribute not yet supported');
					} else {
						// For parameters linked to an element with a saved value, set value to that of bound element
						if (this.savedParameterArray.indexOf(_parameter) < 0) {
							this.setParameterFromString(_parameter, element.checked.toString());
						}
						// Otherwise set element value to saved doodle parameter
						else {
							this.drawing.updateBindings(this);
						}
						element.addEventListener('change', listener = function(event) {
							drawing.eventHandler('onchange', id, className, this.id, this.checked.toString());
						}, false);
					}
					break;

				case 'select-one':
					if (attribute) {
						if (element.selectedIndex > -1) {
							// For parameters linked to a saved value, set value to that of bound element
							if (this.savedParameterArray.indexOf(_parameter) < 0) {
								this.setParameterFromString(_parameter, element.options[element.selectedIndex].getAttribute(attribute));
							}
						}
						element.addEventListener('change', listener = function(event) {
							drawing.eventHandler('onchange', id, className, this.id, this.options[this.selectedIndex].getAttribute(attribute));
						}, false);
					} else {
						// For parameters linked to an element with a saved value, set value to that of bound element
						if (this.savedParameterArray.indexOf(_parameter) < 0) {
							this.setParameterFromString(_parameter, element.value);
						}
						// Otherwise set element value to saved doodle parameter
						else {
							this.drawing.updateBindings(this);
						}
						element.addEventListener('change', listener = function(event) {
							drawing.eventHandler('onchange', id, className, this.id, this.value);
						}, false);
					}
					break;

				case 'text':
					if (attribute) {
						ED.errorHandler('ED.Doodle', 'addBinding', 'Binding to a text field with a non-standard attribute not yet supported');
					} else {
						// For parameters linked to an element with a saved value, set value to that of bound element
						if (this.savedParameterArray.indexOf(_parameter) < 0) {
							this.setParameterFromString(_parameter, element.value);
						}
						// Otherwise set element value to saved doodle parameter
						else {
							this.drawing.updateBindings(this);
						}

						// Change event for input fields are only invoked when the input element is blurred.
						element.addEventListener('change', listener = function(event) {
							drawing.eventHandler('onchange', id, className, this.id, this.value);
						}, false);
					}
					break;

				default:
					if (attribute) {
						this.setParameterFromString(_parameter, element.getAttribute(attribute));
						element.addEventListener('change', listener = function(event) {
							drawing.eventHandler('onchange', id, className, this.id, this.getAttribute(attribute));
						}, false);
					} else {
						this.setParameterFromString(_parameter, element.value);
						element.addEventListener('change', listener = function(event) {
							drawing.eventHandler('onchange', id, className, this.id, this.value);
						}, false);
					}
					break;
			}

			// Add listener to array
			this.drawing.listenerArray[this.id][_parameter] = listener;
		} else {
			ED.errorHandler('ED.Doodle', 'addBinding', 'Failed to add binding. DOM has no element with id: ' + elementId);
		}
	} else {
		ED.errorHandler('ED.Doodle', 'addBinding', 'Failed to add binding. Doodle of class: ' + this.className + ' has no parameter of name: ' + _parameter);
	}
};

/**
 * Removes a binding from a doodle
 *
 * @param {String} _parameter Name of parameter whosse binding is to be removed
 */
ED.Doodle.prototype.removeBinding = function(_parameter) {

	// Get id of corresponding element
	var elementId;
	for (var parameter in this.bindingArray) {
		if (parameter == _parameter) {
			elementId = this.bindingArray[_parameter]['id'];
		}
	}

	// Remove entry in binding array
	delete this.bindingArray[_parameter];

	var element = document.getElementById(elementId);
	if (element) {
		// Attempt to remove the event listener.
		element.removeEventListener('change', this.drawing.listenerArray[this.id][_parameter], false);
	}

	// Remove entry in listener array
	delete this.drawing.listenerArray[this.id][_parameter];
};

/**
 * Returns the roation converted to clock hours
 *
 * @param {Int} _Offset Optional integer offset (1 to 11)
 * @returns {Int} Clock hour from 1 to 12
 */
ED.Doodle.prototype.clockHour = function(_offset) {
	var clockHour;
	var offset;

	if (typeof(_offset) != 'undefined') offset = _offset
	else offset = 0;

	if (this.isRotatable && !this.isMoveable) {
		clockHour = ((this.rotation * 6 / Math.PI) + 12 + offset) % 12;
	} else {
		var twelvePoint = new ED.Point(0, -100);
		var thisPoint = new ED.Point(this.originX, this.originY);
		clockHour = ((twelvePoint.clockwiseAngleTo(thisPoint) * 6 / Math.PI) + 12 + offset) % 12;
	}

	clockHour = clockHour.toFixed(0);
	if (clockHour == 0) clockHour = 12;
	return clockHour
};

/**
 * Returns the quadrant of a doodle based on origin coordinates
 *
 * @returns {String} Description of quadrant
 */
ED.Doodle.prototype.quadrant = function() {
	var returnString = "";

	// Use trigonometry on rotation field to determine quadrant
	returnString += this.originY < 0 ? "supero" : "infero";
	if (this.drawing.eye == ED.eye.Right) {
		returnString += this.originX < 0 ? "temporal" : "nasal";
	} else {
		returnString += this.originX < 0 ? "nasal" : "temporal";
	}

	returnString += " quadrant";

	return returnString;
};

/**
 * Returns the rotation converted to degrees
 *
 * @returns {Int} Degrees from 0 to 360
 */
ED.Doodle.prototype.degrees = function() {
	var degrees;

	if (this.isRotatable && !this.isMoveable) {
		degrees = ((this.rotation * 180 / Math.PI) + 360) % 360;
	} else {
		var twelvePoint = new ED.Point(0, -100);
		var thisPoint = new ED.Point(this.originX, this.originY);
		degrees = ((twelvePoint.clockwiseAngleTo(thisPoint) * 180 / Math.PI) + 360) % 360;
	}

	degrees = degrees.toFixed(0);
	if (degrees == 0) degrees = 0;
	return degrees;
};

/**
 * Returns the extent converted to clock hours
 *
 * @returns {Int} Clock hour from 1 to 12
 */
ED.Doodle.prototype.clockHourExtent = function(label) {
	if (label === undefined) {
        label = '';
	} else {
		label = ' ' + label;
	}

	var clockHourStart;
	var clockHourEnd;

	if (this.isRotatable && !this.isMoveable) {
		clockHourStart = (((this.rotation - this.arc / 2) * 6 / Math.PI) + 12) % 12;
		clockHourEnd = (((this.rotation + this.arc / 2) * 6 / Math.PI) + 12) % 12;
	} else {
		var twelvePoint = new ED.Point(0, -100);
		var thisPoint = new ED.Point(this.originX, this.originY);
		var clockHour = ((twelvePoint.clockwiseAngleTo(thisPoint) * 6 / Math.PI) + 12) % 12;
	}

	clockHourStart = clockHourStart.toFixed(0);
	if (clockHourStart == 0) clockHourStart = 12;
	clockHourEnd = clockHourEnd.toFixed(0);
	if (clockHourEnd == 0) clockHourEnd = 12;
	return "from " + clockHourStart + label + " to " + clockHourEnd + label;
};

/**
 * Returns the extent converted to degrees
 *
 * @returns {Int} Extent 0 to 360 degrees
 */
ED.Doodle.prototype.degreesExtent = function() {
	var degrees = this.arc * 180 / Math.PI;
	var intDegrees = Math.round(degrees);
	return intDegrees;
};

/**
 * Returns the location relative to the disc
 *
 * @returns {String} Text description of location
 */
ED.Doodle.prototype.locationRelativeToDisc = function() {
	var locationString = "";

	// Right eye
	if (this.drawing.eye == ED.eye.Right) {
		if (this.originX > 180 && this.originX < 420 && this.originY > -120 && this.originY < 120) {
			locationString = "at the disc";
		} else {
			locationString += this.originY <= 0 ? "supero" : "infero";
			locationString += this.originX <= 300 ? "temporally" : "nasally";
		}
	}
	// Left eye
	else {
		if (this.originX < -180 && this.originX > -420 && this.originY > -120 && this.originY < 120) {
			locationString = "at the disc";
		} else {
			locationString += this.originY <= 0 ? "supero" : "infero";
			locationString += this.originX >= -300 ? "temporally" : "nasally";
		}
	}

	return locationString;
};

/**
 * Returns the location relative to the fovea
 *
 * @returns {String} Text description of location
 */
ED.Doodle.prototype.locationRelativeToFovea = function() {
	var locationString = "";

	// Right eye
	if (this.drawing.eye == ED.eye.Right) {
		if (this.originX > -10 && this.originX < 10 && this.originY > -10 && this.originY < 10) {
			locationString = "at the fovea";
		} else {
			locationString += this.originY <= 0 ? "supero" : "infero";
			locationString += this.originX <= 0 ? "temporal" : "nasal";
			locationString += " to the fovea";
		}
	}
	// Left eye
	else {
		if (this.originX > -10 && this.originX < 10 && this.originY > -10 && this.originY < 10) {
			locationString = "at the fovea";
		} else {
			locationString += this.originY <= 0 ? "supero" : "infero";
			locationString += this.originX >= 0 ? "temporally" : "nasally";
			locationString += " to the fovea";
		}
	}
	return locationString;
};

/**
 * Adds a new squiggle to the doodle's squiggle array
 */
ED.Doodle.prototype.addSquiggle = function() {
	// Get colour (stored as a HEX string in the doodle) and create colour object
	var colourObject = new ED.Colour(0, 0, 0, 1);
	colourObject.setWithHexString(this.colourString);

	// Line thickness
	var lineThickness;
	switch (this.thickness) {
		case "Thin":
			lineThickness = ED.squiggleWidth.Thin;
			break;
		case "Medium":
			lineThickness = ED.squiggleWidth.Medium;
			break;
		case "Thick":
			lineThickness = ED.squiggleWidth.Thick;
			break;
		default:
			lineThickness = ED.squiggleWidth.Thin;
			break;
	}

	// Create new squiggle
	var squiggle = new ED.Squiggle(this, colourObject, lineThickness, this.filled);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);
};


/**
 * Adds a point to the active squiggle (the last in the squiggle array)
 *
 * @param {Point} _point The point in the doodle plane to be added
 */
ED.Doodle.prototype.addPointToSquiggle = function(_point) {
	if (this.squiggleArray.length > 0) {
		var index = this.squiggleArray.length - 1;
		var squiggle = this.squiggleArray[index];

		squiggle.addPoint(_point);
	}
};

/**
 * Complete the active squiggle (last in the array)
 */
ED.Doodle.prototype.completeSquiggle = function() {
	if (this.squiggleArray.length > 0) {
		var index = this.squiggleArray.length - 1;
		var squiggle = this.squiggleArray[index];

		squiggle.complete = true;
	}
};

/**
 * Calculates arc for doodles without a natural arc value
 *
 * @returns Arc value in radians
 */
ED.Doodle.prototype.calculateArc = function() {
	// Transform extremity points to origin of 0,0
	var left = new ED.Point(this.leftExtremity.x - this.drawing.canvas.width / 2, this.leftExtremity.y - this.drawing.canvas.height / 2);
	var right = new ED.Point(this.rightExtremity.x - this.drawing.canvas.width / 2, this.rightExtremity.y - this.drawing.canvas.height / 2);

	// Return angle between them
	return left.clockwiseAngleTo(right);
};

/**
 * Finds the nearest point in the doodle pointsArray
 *
 * @param {ED.Point} _point The point to test
 * @returns {ED.Point} The nearest point
 */
ED.Doodle.prototype.nearestPointTo = function(_point) {
	// Check that pointsArray has content
	if (this.pointsArray.length > 0) {
		var min = 10000000; // Greater than square of maximum separation in doodle plane
		var index = 0;

		// Iterate through points array to find nearest point
		for (var i = 0; i < this.pointsArray.length; i++) {
			var p = this.pointsArray[i];
			var d = (_point.x - p.x) * (_point.x - p.x) + (_point.y - p.y) * (_point.y - p.y);

			if (d < min) {
				min = d;
				index = i;
			}
		}

		return this.pointsArray[index];
	}
	// Otherwise generate error and return passed point
	else {
		ED.errorHandler('ED.Doodle', 'nearestPointTo', 'Attempt to calculate nearest points with an empty points array');
		return _point;
	}
};

/**
 * Finds the nearest angle in the doodle anglesArray
 *
 * @param {Float} _angle The angle to test
 * @returns {Float} The nearest angle
 */
ED.Doodle.prototype.nearestAngleTo = function(_angle) {
	// Check that anglesArray has content
	if (this.anglesArray.length > 0) {
		var min = 2 * Math.PI; // Greater than one complete rotation
		var index = 0;

		// Iterate through angles array to find nearest point
		for (var i = 0; i < this.anglesArray.length; i++) {
			var p = this.anglesArray[i];

			var d = Math.abs(p - _angle);

			if (d < min) {
				min = d;
				index = i;
			}
		}

		return this.anglesArray[index];
	}
	// Otherwise generate error and return passed angle
	else {
		ED.errorHandler('ED.Doodle', 'nearestAngleTo', 'Attempt to calculate nearest angle with an empty angles array');
		return _angle;
	}
};

/**
 * Finds the nearest arc in the doodle arcArray
 *
 * @param {Float} _arc The angle to test
 * @returns {Float} The nearest angle
 */
ED.Doodle.prototype.nearestArcTo = function(_arc) {
	// Check that arcArray has content
	if (this.arcArray.length > 0) {
		var min = 2 * Math.PI; // Greater than one complete rotation
		var index = 0;

		// Iterate through angles array to find nearest point
		for (var i = 0; i < this.arcArray.length; i++) {
			var p = this.arcArray[i];

			var d = Math.abs(p - _arc);

			if (d < min) {
				min = d;
				index = i;
			}
		}

		return this.arcArray[index];
	}
	// Otherwise generate error and return passed arc
	else {
		ED.errorHandler('ED.Doodle', 'nearestArcTo', 'Attempt to calculate nearest arc with an empty arc array');
		return _arc;
	}
};

/**
 * Returns a doodle in JSON format
 *
 * @returns {String} A JSON encoded string representing the variable properties of the doodle
 */
ED.Doodle.prototype.json = function() {

	// Start of JSON string
	var s = '{';

	// Version and doodle subclass
	s = s + '"scaleLevel": ' + this.scaleLevel + ',';
	s = s + '"version":' + this.version.toFixed(1) + ',';
	s = s + '"subclass":' + '"' + this.className + '",';

	// Only save values of parameters specified in savedParameterArray
	if (typeof(this.savedParameterArray) != 'undefined') {
		if (this.savedParameterArray.length > 0) {
			for (var i = 0; i < this.savedParameterArray.length; i++) {
				var p = this.savedParameterArray[i];

				// Value to output
				var o = this[p];

				// Offset the scale.
				switch(p) {
					case 'scaleX':
					case 'scaleY':
					case 'originX':
					case 'originY':
					case 'lastOriginX':
					case 'lastOriginY':
						o *= (1 / this.scaleLevel);
					break;
				}

				// Special treatment according to parameter
				if (p == 'scaleX' || p == 'scaleY') {
					o = o.toFixed(2)
				} else if (p == 'arc' || p == 'rotation') {
					o = (o * 180 / Math.PI).toFixed(0);
				} else if (p == 'originX' || p == 'originY' || p == 'radius' || p == 'apexX' || p == 'apexY' || p == 'width' || p == 'height') {
					o = o.toFixed(0);
				} else if (typeof(o) == 'number') {
					o = o.toFixed(2);
				} else if (typeof(o) == 'string') {
					o = '"' + o + '"';
				} else if (typeof(o) == 'boolean') {
					o = o;
				} else if (typeof(o) == 'object') {
					o = JSON.stringify(o);
				} else {
					ED.errorHandler('ED.Doodle', 'json', 'Attempt to create json for parameter ' + p + ' with an unhandled parameter type: ' + typeof(o));
					o = "ERROR";
				}

				// Construct json
				s = s + '"' + p + '":' + o + ',';
			}
		}
	}

	// Optional squiggle array
	if (this.squiggleArray.length > 0) {
		s = s + '"squiggleArray":[';
		for (var j = 0; j < this.squiggleArray.length; j++) {
			s = s + this.squiggleArray[j].json();
			if (this.squiggleArray.length - j > 1) {
				s = s + ',';
			}
		}
		s = s + '],';
	}

	// Order
	s = s + '"order":' + this.order.toFixed(0);

	// End of JSON
	s = s + '}';

	return s;
};

/**
 * Draws a circular spot with given parameters
 *
 * @param {Object} _ctx Context of canvas
 * @param {Float} _x X-coordinate of origin
 * @param {Float} _y Y-coordinate of origin
 * @param {Float} _r Radius
 * @param {String} _colour String containing colour
 */
ED.Doodle.prototype.drawSpot = function(_ctx, _x, _y, _r, _colour) {
	_ctx.save();
	_ctx.beginPath();
	_ctx.arc(_x, _y, _r, 0, Math.PI * 2, true);
	_ctx.fillStyle = _colour;
	_ctx.strokeStyle = _colour;
	_ctx.lineWidth = 0;
	_ctx.fill();
	_ctx.stroke();
	_ctx.restore();
};

/**
 * Draws a circle with given parameters
 *
 * @param {Object} _ctx Context of canvas
 * @param {Float} _x X-coordinate of origin
 * @param {Float} _y Y-coordinate of origin
 * @param {Float} _r Radius
 * @param {String} _fillColour String containing fill colour
 * @param {Int} _lineWidth Line width in pixels
 * @param {String} _strokeColour String containing stroke colour
 */
ED.Doodle.prototype.drawCircle = function(_ctx, _x, _y, _r, _fillColour, _lineWidth, _strokeColour) {
	_ctx.save();
	_ctx.beginPath();
	_ctx.arc(_x, _y, _r, 0, Math.PI * 2, true);
	_ctx.fillStyle = _fillColour;
	_ctx.fill();
	_ctx.lineWidth = _lineWidth;
	_ctx.strokeStyle = _strokeColour;
	_ctx.stroke();
	_ctx.restore();
};

/**
 * Draws a line with given parameters
 *
 * @param {Object} _ctx Context of canvas
 * @param {Float} _x1 X-coordinate of origin
 * @param {Float} _y1 Y-coordinate of origin
 * @param {Float} _x2 X-coordinate of origin
 * @param {Float} _y2 Y-coordinate of origin
 * @param {Float} _w Width of line
 * @param {String} _colour String containing colour
 */
ED.Doodle.prototype.drawLine = function(_ctx, _x1, _y1, _x2, _y2, _w, _colour) {
	_ctx.save();
	_ctx.beginPath();
	_ctx.moveTo(_x1, _y1);
	_ctx.lineTo(_x2, _y2);
	_ctx.lineWidth = _w;
	_ctx.strokeStyle = _colour;
	_ctx.stroke();
	_ctx.restore();
};

/**
 * Draws a laser spot
 *
 * @param {Object} _ctx Context of canvas
 * @param {Float} _x X-coordinate of origin
 * @param {Float} _y Y-coordinate of origin
 */
ED.Doodle.prototype.drawLaserSpot = function(_ctx, _x, _y) {
	this.drawCircle(_ctx, _x, _y, 15, "Yellow", 10, "rgba(255, 128, 0, 1)");
};

/**
 * Draws a haemorrhage orientated to be parallel to nerve fibre layer
 *
 * @param {Object} _ctx Context of canvas
 * @param {Float} _x X-coordinate of origin
 * @param {Float} _y Y-coordinate of origin
 */
ED.Doodle.prototype.drawNFLHaem = function(_ctx, _x, _y) {
	// Parameters
	var r = 10;

	// Create point from parameters
	var p = new ED.Point(_x, _y);

	// Create two new points 'tangential'
	var phi1 = p.direction() + Math.PI/2;
	var phi2 = p.direction() + 3 * Math.PI/2;
	var p1 = new ED.Point(0,0);
	p1.setWithPolars(r, phi1);
	var p2 = new ED.Point(0,0);
	p2.setWithPolars(r, phi2);

	// Draw line
	_ctx.beginPath();
	_ctx.moveTo(_x + p1.x, _y + p1.y);
	_ctx.lineTo(_x + p2.x, _y + p2.y);

	_ctx.lineWidth = 16;
	_ctx.lineCap = 'round';
	_ctx.strokeStyle = "rgba(255,0,0,0.5)";

	_ctx.stroke();
};

/**
 * Adds an ellipse to a path
 *
 * @param {Object} _ctx Context of canvas
 * @param {Float} _x X-coordinate of origin
 * @param {Float} _y Y-coordinate of origin
 * @param {Float} _w Width
 * @param {Float} _h Height
 */
ED.Doodle.prototype.addEllipseToPath = function(_ctx, _x, _y, _w, _h) {
  var kappa = 0.5522848;
  var ox = (_w / 2) * kappa;
  var oy = (_h / 2) * kappa;

  _ctx.moveTo(-_w/2, 0);
  _ctx.bezierCurveTo(_x - _w/2, _y - oy, _x - ox, _y - _h/2, _x, _y - _h/2);
  _ctx.bezierCurveTo(_x + ox, _y - _h/2, _x + _w/2, _y - oy, _x + _w/2, _y);
  _ctx.bezierCurveTo(_x + _w/2, _y + oy, _x + ox, _y + _h/2, _x, _y + _h/2);
  _ctx.bezierCurveTo(_x - ox, _y + _h/2, _x - _w/2, _y + oy, _x - _w/2, _y);
};

/**
 * Returns the x coordinate of a point given its y and the radius
 *
 * @param {Float} _r Radius to point
 * @param {Float} _y y coordinate of point
 * @returns {Float} x coordinate of point
 */
ED.Doodle.prototype.xForY = function(_r, _y) {
	return Math.sqrt(_r * _r - _y * _y);
};

/**
 * Set the scale level.
 * @param {Number} _level The scaling level.
 */
ED.Doodle.prototype.setScaleLevel = function(_newLevel) {
	var diff = (_newLevel / this.scaleLevel);
	this.adjustScaleAndPosition(diff);
	this.scaleLevel = _newLevel;
};

ED.Doodle.prototype.adjustScaleAndPosition = function(amount){
	this.scaleX *= amount;
	this.scaleY *= amount;
	this.originX *= amount;
	this.originY *= amount;
	if (this.lastOriginX) this.lastOriginX *= amount;
	if (this.lastOriginY) this.lastOriginY *= amount;
};

ED.Doodle.prototype.getLinkedParameters = function(linkedDoodleClass) {
	if (typeof(this.linkedDoodleParameters[linkedDoodleClass]) != "undefined") {
		return this.linkedDoodleParameters[linkedDoodleClass];
	}
}

/**
 * Outputs doodle information to the console
 */
ED.Doodle.prototype.debug = function() {
	console.log('org: ' + this.originX + " : " + this.originY);
	console.log('apx: ' + this.apexX + " : " + this.apexY);
	console.log('rot: ' + this.rotation * 180 / Math.PI);
	console.log('arc: ' + this.arc * 180 / Math.PI);
};

/**
 * Represents a control handle on the doodle
 *
 * @class Handle
 * @property {Point} location Location in doodle plane
 * @property {Bool} isVisible Flag indicating whether handle should be shown
 * @property {Enum} mode The drawing mode that selection of the handle triggers
 * @property {Bool} isRotatable Flag indicating whether the handle shows an outer ring used for rotation
 * @param {Point} _location
 * @param {Bool} _isVisible
 * @param {Enum} _mode
 * @param {Bool} _isRotatable
 */
ED.Doodle.Handle = function(_location, _isVisible, _mode, _isRotatable) {
	// Properties
	if (_location == null) {
		this.location = new ED.Point(0, 0);
	} else {
		this.location = _location;
	}
	this.isVisible = _isVisible;
	this.mode = _mode;
	this.isRotatable = _isRotatable;
};
/**
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 *
 * OpenEyes is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenEyes is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenEyes.  If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * An object of the Report class is used to extract data for the Royal College of Ophthalmologists retinal detachment dataset.
 * The object analyses an EyeDraw drawing, and sets the value of HTML elements on the page accordingly.
 * @namespace ED.Report
 * @memberOf ED
 * @property {Canvas} canvas A canvas element used to edit and display the drawing
 * @property {Int} breaksInAttached The number of retinal breaks in attached retina
 * @property {Int} breaksInDetached The number of retinal breaks in detached retina
 * @property {String} largestBreakType The type of the largest retinal break
 * @property {Int} largestBreakSize The size in clock hours of the largest retinal break
 * @property {Int} lowestBreakPosition The lowest position of any break in clock hours
 * @property {String} pvrType The type of PVR
 * @property {Int} pvrCClockHours The number of clock hours of posterior PVR type C
 * @property {Int} antPvrClockHours The number of clock hours of anterior PVR
 * @param Drawing _drawing The drawing object to be analysed
 */
ED.Report = function(_drawing) {
	// Properties
	this.drawing = _drawing;
	this.breaksInAttached = 0;
	this.breaksInDetached = 0;
	this.largestBreakType = 'Not found';
	this.largestBreakSize = 0;
	this.lowestBreakPosition = 12;
	this.pvrType = 'None';
	this.pvrCClockHours = 0;
	this.antPvrClockHours = 0;

	// Variables
	var pvrCDegrees = 0;
	var AntPvrDegrees = 0;
	var minDegreesFromSix = 180;

	// Create array of doodle classes which are retinal breaks
	var breakClassArray = new Array();
	breakClassArray["UTear"] = "U tear";
	breakClassArray["RoundHole"] = "Round hole";
	breakClassArray["Dialysis"] = "Dialysis";
	breakClassArray["GRT"] = "GRT";
	breakClassArray["MacularHole"] = "Macular hole";
	breakClassArray["OuterLeafBreak"] = "Outer Leaf Break";

	// Array of RRD doodles
	this.rrdArray = new Array();

	// First iteration to create array of retinal detachments
	var i, doodle;
	for (i = 0; i < this.drawing.doodleArray.length; i++) {
		doodle = this.drawing.doodleArray[i];

		// If its a RRD, add to RRD array
		if (doodle.className == "RRD") {
			this.rrdArray.push(doodle);
		}
	}

	// Second iteration for other doodles
	for (i = 0; i < this.drawing.doodleArray.length; i++) {
		doodle = this.drawing.doodleArray[i];

		// Star fold - PVR C
		if (doodle.className == "StarFold") {
			this.pvrType = 'C';
			pvrCDegrees += doodle.arc * 180 / Math.PI;
		}
		// Anterior PVR
		else if (doodle.className == "AntPVR") {
			this.pvrType = 'C';
			AntPvrDegrees += doodle.arc * 180 / Math.PI;
		}
		// Retinal breaks
		else if (doodle.className in breakClassArray) {
			// Bearing of break is calculated in two different ways
			var breakBearing = 0;
			if (doodle.className == "UTear" || doodle.className == "RoundHole" || doodle.className == "OuterLeafBreak") {
				breakBearing = (Math.round(Math.atan2(doodle.originX, -doodle.originY) * 180 / Math.PI) + 360) % 360;
			} else {
				breakBearing = (Math.round(doodle.rotation * 180 / Math.PI + 360)) % 360;
			}

			// Bool if break is in detached retina
			var inDetached = this.inDetachment(breakBearing);

			// Increment totals
			if (inDetached) {
				this.breaksInDetached++;
			} else {
				this.breaksInAttached++;
			}

			// Get largest break in radians
			if (inDetached && doodle.arc > this.largestBreakSize) {
				this.largestBreakSize = doodle.arc;
				this.largestBreakType = breakClassArray[doodle.className];
			}

			// Get lowest break
			var degreesFromSix = Math.abs(breakBearing - 180);

			if (inDetached && degreesFromSix < minDegreesFromSix) {
				minDegreesFromSix = degreesFromSix;

				// convert to clock hours
				var bearing = breakBearing + 15;
				remainder = bearing % 30;
				this.lowestBreakPosition = Math.floor((bearing - remainder) / 30);
				if (this.lowestBreakPosition == 0) this.lowestBreakPosition = 12;
			}
		}
	}

	// Star folds integer result (round up to one clock hour)
	pvrCDegrees += 25;
	var remainder = pvrCDegrees % 30;
	this.pvrCClockHours = Math.floor((pvrCDegrees - remainder) / 30);

	// Anterior PVR clock hours
	AntPvrDegrees += 25;
	remainder = AntPvrDegrees % 30;
	this.antPvrClockHours = Math.floor((AntPvrDegrees - remainder) / 30);

	// Convert largest break size to clockhours
	var size = this.largestBreakSize * 180 / Math.PI + 25;
	var remainder = size % 30;
	this.largestBreakSize = Math.floor((size - remainder) / 30);
}

/**
 * Accepts a bearing in degrees (0 is at 12 o'clock) and returns true if it is in an area of detachment
 *
 * @param {Float} _angle Bearing in degrees
 * @returns {Bool} True is the bearing intersects with an area of retinal deatchment
 */
ED.Report.prototype.inDetachment = function(_angle) {
	var returnValue = false;

	// Iterate through retinal detachments
	for (key in this.rrdArray) {
		var rrd = this.rrdArray[key];

		// Get start and finish bearings of detachment in degrees
		var min = (rrd.rotation - rrd.arc / 2) * 180 / Math.PI;
		var max = (rrd.rotation + rrd.arc / 2) * 180 / Math.PI;

		// Convert to positive numbers
		var min = (min + 360) % 360;
		var max = (max + 360) % 360;

		// Handle according to whether RRD straddles 12 o'clock
		if (max < min) {
			if ((0 <= _angle && _angle <= max) || (min <= _angle && _angle <= 360)) {
				returnValue = true;
			}
		} else if (max == min) // Case if detachment is total
		{
			return true;
		} else {
			if (min <= _angle && _angle <= max) {
				returnValue = true;
			}
		}
	}

	return returnValue;
}

/**
 * Extent of RRD in clock hours
 *
 * @returns {Array} An array of extents (1 to 3 clock hours) for each quadrant
 */
ED.Report.prototype.extent = function() {
	// Array of extents by quadrant
	var extentArray = new Array();
	if (this.drawing.eye == ED.eye.Right) {
		extentArray["SN"] = 0;
		extentArray["IN"] = 0;
		extentArray["IT"] = 0;
		extentArray["ST"] = 0;
	} else {
		extentArray["ST"] = 0;
		extentArray["IT"] = 0;
		extentArray["IN"] = 0;
		extentArray["SN"] = 0;
	}

	// get middle of first hour in degrees
	var midHour = 15;

	// Go through each quadrant counting extent of detachment
	for (quadrant in extentArray) {
		for (var i = 0; i < 3; i++) {
			var addition = this.inDetachment(midHour) ? 1 : 0;
			extentArray[quadrant] = extentArray[quadrant] + addition;
			midHour = midHour + 30;
		}
	}

	return extentArray;
}

/**
 * Returns true if the macular is off
 *
 * @returns {Bool} True if the macula is off
 */
ED.Report.prototype.isMacOff = function() {
	var result = false;

	// Iterate through each detachment, one macoff is enough
	for (key in this.rrdArray) {
		var rrd = this.rrdArray[key];
		if (rrd.isMacOff()) result = true;
	}

	return result;
}

/**
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 *
 * OpenEyes is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenEyes is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenEyes.  If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * Creates a new transformation matrix initialised to the identity matrix
 *
 * @class AffineTransform
 * @property {Array} components Array representing 3x3 matrix
 */
ED.AffineTransform = function() {
	// Properties - array of arrays of column values one for each row
	this.components = [
		[1, 0, 0],
		[0, 1, 0],
		[0, 0, 1]
	];
}

/**
 * Sets matrix to identity matrix
 */
ED.AffineTransform.prototype.setToIdentity = function() {
	this.components[0][0] = 1;
	this.components[0][1] = 0;
	this.components[0][2] = 0;
	this.components[1][0] = 0;
	this.components[1][1] = 1;
	this.components[1][2] = 0;
	this.components[2][0] = 0;
	this.components[2][1] = 0;
	this.components[2][2] = 1;
}

/**
 * Sets the transform matrix to another
 *
 * @param {AffineTransform} _transform Array An affine transform
 */
ED.AffineTransform.prototype.setToTransform = function(_transform) {
	this.components[0][0] = _transform.components[0][0];
	this.components[0][1] = _transform.components[0][1];
	this.components[0][2] = _transform.components[0][2];
	this.components[1][0] = _transform.components[1][0];
	this.components[1][1] = _transform.components[1][1];
	this.components[1][2] = _transform.components[1][2];
	this.components[2][0] = _transform.components[2][0];
	this.components[2][1] = _transform.components[2][1];
	this.components[2][2] = _transform.components[2][2];
}

/**
 * Adds a translation to the transform matrix
 *
 * @param {float} _x value to translate along x-axis
 * @param {float} _y value to translate along y-axis
 */
ED.AffineTransform.prototype.translate = function(_x, _y) {
	this.components[0][2] = this.components[0][0] * _x + this.components[0][1] * _y + this.components[0][2];
	this.components[1][2] = this.components[1][0] * _x + this.components[1][1] * _y + this.components[1][2];
	this.components[2][2] = this.components[2][0] * _x + this.components[2][1] * _y + this.components[2][2];
}

/**
 * Adds a scale to the transform matrix
 *
 * @param {float} _sx value to scale along x-axis
 * @param {float} _sy value to scale along y-axis
 */
ED.AffineTransform.prototype.scale = function(_sx, _sy) {
	this.components[0][0] = this.components[0][0] * _sx;
	this.components[0][1] = this.components[0][1] * _sy;
	this.components[1][0] = this.components[1][0] * _sx;
	this.components[1][1] = this.components[1][1] * _sy;
	this.components[2][0] = this.components[2][0] * _sx;
	this.components[2][1] = this.components[2][1] * _sy;
}

/**
 * Adds a rotation to the transform matrix
 *
 * @param {float} _rad value to rotate by in radians
 */
ED.AffineTransform.prototype.rotate = function(_rad) {
	// Calulate trigonometry
	var c = Math.cos(_rad);
	var s = Math.sin(_rad);

	// Make new matrix for transform
	var matrix = [
		[0, 0, 0],
		[0, 0, 0],
		[0, 0, 0]
	];

	// Apply transform
	matrix[0][0] = this.components[0][0] * c + this.components[0][1] * s;
	matrix[0][1] = this.components[0][1] * c - this.components[0][0] * s;
	matrix[1][0] = this.components[1][0] * c + this.components[1][1] * s;
	matrix[1][1] = this.components[1][1] * c - this.components[1][0] * s;
	matrix[2][0] = this.components[2][0] * c + this.components[2][1] * s;
	matrix[2][1] = this.components[2][1] * c - this.components[2][0] * s;

	// Change old matrix
	this.components[0][0] = matrix[0][0];
	this.components[0][1] = matrix[0][1];
	this.components[1][0] = matrix[1][0];
	this.components[1][1] = matrix[1][1];
	this.components[2][0] = matrix[2][0];
	this.components[2][1] = matrix[2][1];
}

/**
 * Applies transform to a point
 *
 * @param {Point} _point a point
 * @returns {Point} a transformed point
 */
ED.AffineTransform.prototype.transformPoint = function(_point) {
	var newX = _point.x * this.components[0][0] + _point.y * this.components[0][1] + 1 * this.components[0][2];
	var newY = _point.x * this.components[1][0] + _point.y * this.components[1][1] + 1 * this.components[1][2];

	return new ED.Point(newX, newY);
}

/**
 * Calculates determinant of transform matrix
 *
 * @returns {Float} determinant
 */
ED.AffineTransform.prototype.determinant = function() {
	return this.components[0][0] * (this.components[1][1] * this.components[2][2] - this.components[1][2] * this.components[2][1]) -
		this.components[0][1] * (this.components[1][0] * this.components[2][2] - this.components[1][2] * this.components[2][0]) +
		this.components[0][2] * (this.components[1][0] * this.components[2][1] - this.components[1][1] * this.components[2][0]);
}

/**
 * Inverts transform matrix
 *
 * @returns {Array} inverse matrix
 */
ED.AffineTransform.prototype.createInverse = function() {
	// Create new matrix
	var inv = new ED.AffineTransform();

	var det = this.determinant();

	//if (det != 0)
	var invdet = 1 / det;

	// Calculate components of inverse matrix
	inv.components[0][0] = invdet * (this.components[1][1] * this.components[2][2] - this.components[1][2] * this.components[2][1]);
	inv.components[0][1] = invdet * (this.components[0][2] * this.components[2][1] - this.components[0][1] * this.components[2][2]);
	inv.components[0][2] = invdet * (this.components[0][1] * this.components[1][2] - this.components[0][2] * this.components[1][1]);

	inv.components[1][0] = invdet * (this.components[1][2] * this.components[2][0] - this.components[1][0] * this.components[2][2]);
	inv.components[1][1] = invdet * (this.components[0][0] * this.components[2][2] - this.components[0][2] * this.components[2][0]);
	inv.components[1][2] = invdet * (this.components[0][2] * this.components[1][0] - this.components[0][0] * this.components[1][2]);

	inv.components[2][0] = invdet * (this.components[1][0] * this.components[2][1] - this.components[1][1] * this.components[2][0]);
	inv.components[2][1] = invdet * (this.components[0][1] * this.components[2][0] - this.components[0][0] * this.components[2][1]);
	inv.components[2][2] = invdet * (this.components[0][0] * this.components[1][1] - this.components[0][1] * this.components[1][0]);

	return inv;
}
/**
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 *
 * OpenEyes is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenEyes is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenEyes.  If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * A colour in the RGB space;
 * Usage: var c = new ED.Colour(0, 0, 255, 0.75); ctx.fillStyle = c.rgba();
 *
 * @property {Int} red The red value as an integer from 0 to 255
 * @property {Int} green The green value as an integer from 0 to 255
 * @property {Int} blue The blue value as an integer from 0 to 255
 * @property {Float} alpha The alpha value as a float from 0 to 1
 * @param {Int} _red
 * @param {Int} _green
 * @param {Int} _blue
 * @param {Float} _alpha
 */
ED.Colour = function(_red, _green, _blue, _alpha) {
	this.red = _red;
	this.green = _green;
	this.blue = _blue;
	this.alpha = _alpha;
}

/**
 * Sets the colour from a hex encoded string
 *
 * @param {String} Colour in hex format (eg 'E0AB4F')
 */
ED.Colour.prototype.setWithHexString = function(_hexString) {
	// ***TODO*** add some string reality checks here
	this.red = parseInt((_hexString.charAt(0) + _hexString.charAt(1)), 16);
	this.green = parseInt((_hexString.charAt(2) + _hexString.charAt(3)), 16);
	this.blue = parseInt((_hexString.charAt(4) + _hexString.charAt(5)), 16);
	if (_hexString.length > 6) {
		this.alpha = parseInt((_hexString.charAt(6) + _hexString.charAt(7)), 16);
	}
}

/**
 * Outputs the colour as a hex string
 *
 * @returns {String} Colour in hex format (eg 'E0AB4F')
 */
ED.Colour.prototype.hexString = function() {
	var hexString = "";

	// temporary while awaiting internet! Works for red and green only
	if (this.red > 0) return "FF0000FF";
	else return "00FF00FF";

	// ***TODO*** add some string reality checks here
// 	this.red = parseInt((_hexString.charAt(0) + _hexString.charAt(1)), 16);
// 	this.green = parseInt((_hexString.charAt(2) + _hexString.charAt(3)), 16);
// 	this.blue = parseInt((_hexString.charAt(4) + _hexString.charAt(5)), 16);
// 	if (_hexString.length > 6) {
// 		this.alpha = parseInt((_hexString.charAt(6) + _hexString.charAt(7)), 16);
// 	}
}

/**
 * Returns a colour in Javascript rgba format
 *
 * @returns {String} Colour in rgba format
 */
ED.Colour.prototype.rgba = function() {
	return "rgba(" + this.red + ", " + this.green + ", " + this.blue + ", " + this.alpha + ")";
}

/**
 * Returns a colour in JSON format
 *
 * @returns {String} A JSON encoded string representing the colour
 */
ED.Colour.prototype.json = function() {
	return "{\"red\":" + this.red + ",\"green\":" + this.green + ",\"blue\":" + this.blue + ",\"alpha\":" + this.alpha + "}";
}

/**
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 *
 * OpenEyes is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenEyes is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenEyes.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Represents a point in two dimensional space
 * @class Point
 * @property {Int} x The x-coordinate of the point
 * @property {Int} y The y-coordinate of the point
 * @property {Array} components Array representing point in matrix notation
 * @param {Float} _x
 * @param {Float} _y
 */
ED.Point = function(_x, _y) {
	// Properties
	this.x = Math.round(+_x);
	this.y = Math.round(+_y);
	this.components = [this.x, this.y, 1];
}

/**
 * Sets properties of the point using polar coordinates
 *
 * @param {Float} _r Distance from the origin
 * @param {Float} _p Angle in radians from North going clockwise
 */
ED.Point.prototype.setWithPolars = function(_r, _p) {
	this.x = Math.round(_r * Math.sin(_p));
	this.y = Math.round(-_r * Math.cos(_p));
}

/**
 * Sets x and y of the point
 *
 * @param {Float} _x value of x
 * @param {Float} _y value of y
 */
ED.Point.prototype.setCoordinates = function(_x, _y) {
	this.x = _x;
	this.y = _y;
}

/**
 * Calculates the distance between this point and another
 *
 * @param {Point} _point
 * @returns {Float} Distance from the passed point
 */
ED.Point.prototype.distanceTo = function(_point) {
	return Math.sqrt(Math.pow(this.x - _point.x, 2) + Math.pow(this.y - _point.y, 2));
}

/**
 * Calculates the dot product of two points (treating points as 2D vectors)
 *
 * @param {Point} _point
 * @returns {Float} The dot product
 */
ED.Point.prototype.dotProduct = function(_point) {
	return this.x * _point.x + this.y * _point.y;
}

/**
 * Calculates the cross product of two points (treating points as 2D vectors)
 *
 * @param {Point} _point
 * @returns {Float} The cross product
 */
ED.Point.prototype.crossProduct = function(_point) {
	return this.x * _point.y - this.y * _point.x;
}

/**
 * Calculates the length of the point treated as a vector
 *
 * @returns {Float} The length
 */
ED.Point.prototype.length = function() {
	return Math.sqrt(this.x * this.x + this.y * this.y);
}

/**
 * Calculates the direction of the point treated as a vector
 *
 * @returns {Float} The angle from zero (north) going clockwise
 */
ED.Point.prototype.direction = function() {
	var north = new ED.Point(0, -100);

	return north.clockwiseAngleTo(this);
}

/**
 * Inner angle to other vector from same origin going round clockwise from vector a to vector b
 *
 * @param {Point} _point
 * @returns {Float} The angle in radians
 */
ED.Point.prototype.clockwiseAngleTo = function(_point) { //console.log("cat: ",(this.length() * _point.length()));
	var len = (this.length() * _point.length());
	if (len == 0.0) {
		return 0.0;
	}

	// Floating point errors occasionally produce a number for the acos function greater than 1, causing a NaN error
	var num = this.dotProduct(_point) / len;
	if (num > 1) num = 1;
	var angle = Math.acos(num);
	if (this.crossProduct(_point) < 0) {
		return 2 * Math.PI - angle;
	} else {
		return angle;
	}
}

/**
 * Creates a new point at an angle
 *
 * @param {Float} _r Distance from the origin
 * @param {Float} _phi Angle form the radius to the control point
 * @returns {Point} The control point
 */
ED.Point.prototype.pointAtRadiusAndClockwiseAngle = function(_r, _phi) {
	// Calculate direction (clockwise from north)
	var angle = this.direction();

	// Create point and set length and direction
	var point = new ED.Point(0, 0);
	point.setWithPolars(_r, angle + _phi);

	return point;
}

/**
 * Creates a new point at an angle to and half way along a straight line between this point and another
 *
 * @param {Float} _phi Angle form the radius to the control point
 * @param {Float} _point Point at other end of straight line
 * @returns {Point} A point object
 */
ED.Point.prototype.pointAtAngleToLineToPointAtProportion = function(_phi, _point, _prop) {
	// Midpoint in coordinates as if current point is origin
	var bp = new ED.Point((_point.x - this.x) * _prop, (_point.y - this.y) * _prop);

	// Calculate radius
	r = bp.length();

	// Create new point
	var point = bp.pointAtRadiusAndClockwiseAngle(r, _phi);

	// Shift origin back
	point.x += this.x;
	point.y += this.y;

	return point;
}

/**
 * Clock hour of point on clock face centred on origin
 *
 * @returns {Int} The clock hour
 */
ED.Point.prototype.clockHour = function(_point) {
	var twelvePoint = new ED.Point(0, -100);
	var clockHour = ((twelvePoint.clockwiseAngleTo(this) * 6 / Math.PI) + 12) % 12;

	clockHour = clockHour.toFixed(0);
	if (clockHour == 0) clockHour = 12;

	return clockHour;
}

/**
 * Creates a control point on a tangent to the radius of the point at an angle of phi from the radius
 *
 * @param {Float} _phi Angle form the radius to the control point
 * @returns {Point} The control point
 */
ED.Point.prototype.tangentialControlPoint = function(_phi) {
	// Calculate length of line from origin to point and direction (clockwise from north)
	var r = this.length();
	var angle = this.direction();

	// Calculate length of control point
	var h = r / Math.cos(_phi);

	// Create point and set length and direction
	var point = new ED.Point(0, 0);
	point.setWithPolars(h, angle + _phi);

	return point;
}

/**
 * Creates a new point on a straight line between two points at a proportional distance
 *
 * @param {Float} _percent Percentage distance along line
 * @param {Point} _ep End point
 * @returns {Point} _point Point
 */
ED.Point.prototype.pointAtPercentageFromPointToPoint = function(_percent, _point) {
	// Calculate distances (clockwise from north)
	var xIncrement = (_point.x - this.x) * _percent/100;
	var yIncrement = (_point.y - this.y) * _percent/100;

	// Create point and set length and direction
	var point = new ED.Point(this.x + xIncrement, this.y + yIncrement);

	return point;
}

/**
 * Creates a new point on a cubic Bezier curve at parameter t along curve
 *
 * @param {Float} _t Proportion along curve (0-1)
 * @param {Point} _cp1 Control point 1
 * @param {Point} _cp2 Control point 2
 * @param {Point} _ep End point
 * @returns {Point} _point Point
 */
ED.Point.prototype.bezierPointAtParameter = function(_t, _cp1, _cp2, _ep) {
	// Calculate scalars
	var t2 = _t * _t;
	var t3 = t2 * _t;
	var mt = 1 - _t;
	var mt2 = mt * mt;
	var mt3 = mt2 * mt;

	// Calculate x and y values of point
	var x = this.x * mt3 + 3 * _cp1.x * mt2 * _t + 3 * _cp2.x * mt * t2 + _ep.x * t3;
	var y = this.y * mt3 + 3 * _cp1.y * mt2 * _t + 3 * _cp2.y * mt * t2 + _ep.y * t3;

	// Return point
	return new ED.Point(x, y);
}
/**
 * Returns a point in JSON encoding
 *
 * @returns {String} point in JSON format
 */
ED.Point.prototype.json = function() {
	return "{\"x\":" + this.x.toFixed(2) + ",\"y\":" + this.y.toFixed(2) + "}";
}

/**
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 *
 * OpenEyes is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenEyes is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenEyes.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Represents a range of numerical values
 *
 * @class Range
 * @property {Float} min Minimum value
 * @property {Float} max Maximum value
 * @param {Float} _min
 * @param {Float} _max
 */
ED.Range = function(_min, _max) {
	// Properties
	this.min = _min;
	this.max = _max;
}

/**
 * Set min and max with one function call
 *
 * @param {Float} _min
 * @param {Float} _max
 */
ED.Range.prototype.setMinAndMax = function(_min, _max) {
	// Set properties
	this.min = _min;
	this.max = _max;
}

/**
 * Returns true if the parameter is less than the minimum of the range
 *
 * @param {Float} _num
 * @returns {Bool} True if the parameter is less than the minimum
 */
ED.Range.prototype.isBelow = function(_num) {
	if (_num < this.min) {
		return true;
	} else {
		return false;
	}
}

/**
 * Returns true if the parameter is more than the maximum of the range
 *
 * @param {Float} _num
 * @returns {Bool} True if the parameter is more than the maximum
 */
ED.Range.prototype.isAbove = function(_num) {
	if (_num > this.max) {
		return true;
	} else {
		return false;
	}
}

/**
 * Returns true if the parameter is inclusively within the range
 *
 * @param {Float} _num
 * @returns {Bool} True if the parameter is within the range
 */
ED.Range.prototype.includes = function(_num) {
	if (_num < this.min || _num > this.max) {
		return false;
	} else {
		return true;
	}
}

/**
 * Constrains a value to the limits of the range
 *
 * @param {Float} _num
 * @param {Float} _scaleLevel The drawing scale level.
 * @returns {Float} The constrained value
 */
ED.Range.prototype.constrain = function(_num, _scaleLevel) {

	_scaleLevel = _scaleLevel === undefined ? 1 : _scaleLevel

	var min = this.min * _scaleLevel;
	var max = this.max * _scaleLevel;

	if (_num < min) {
		return min;
	} else if (_num > max) {
		return max;
	} else {
		return _num;
	}
}

/**
 * Returns true if the parameter is within the 'clockface' range represented by the min and max values
 *
 * @param {Float} _angle Angle to test
 * @param {Bool} _isDegrees Flag indicating range is in degrees rather than radians
 * @returns {Bool} True if the parameter is within the range
 */
ED.Range.prototype.includesInAngularRange = function(_angle, _isDegrees) {
	// Arbitrary radius
	var r = 100;

	// Points representing vectos of angles within range
	var min = new ED.Point(0, 0);
	var max = new ED.Point(0, 0);
	var angle = new ED.Point(0, 0);

	// Set points using polar coordinates
	if (!_isDegrees) {
		min.setWithPolars(r, this.min);
		max.setWithPolars(r, this.max);
		angle.setWithPolars(r, _angle);
	} else {
		min.setWithPolars(r, this.min * Math.PI / 180);
		max.setWithPolars(r, this.max * Math.PI / 180);
		angle.setWithPolars(r, _angle * Math.PI / 180);
	}

	return (min.clockwiseAngleTo(angle) <= min.clockwiseAngleTo(max));
}

/**
 * Constrains a value to the limits of the angular range
 *
 * @param {Float} _angle Angle to test
 * @param {Bool} _isDegrees Flag indicating range is in degrees rather than radians
 * @returns {Float} The constrained value
 */
ED.Range.prototype.constrainToAngularRange = function(_angle, _isDegrees) {
	// No point in constraining unless range is less than 360 degrees!
	if ((this.max - this.min) < (_isDegrees ? 360 : (2 * Math.PI))) {
		// Arbitrary radius
		var r = 100;

		// Points representing vectors of angles within range
		var min = new ED.Point(0, 0);
		var max = new ED.Point(0, 0);
		var angle = new ED.Point(0, 0);

		// Set points using polar coordinates
		if (!_isDegrees) {
			min.setWithPolars(r, this.min);
			max.setWithPolars(r, this.max);
			angle.setWithPolars(r, _angle);
		} else {
			min.setWithPolars(r, this.min * Math.PI / 180);
			max.setWithPolars(r, this.max * Math.PI / 180);
			angle.setWithPolars(r, _angle * Math.PI / 180);
		}

		// Return appropriate value depending on relationship to range
		if (min.clockwiseAngleTo(angle) <= min.clockwiseAngleTo(max)) {
			return _angle;
		} else {
			if (angle.clockwiseAngleTo(min) < max.clockwiseAngleTo(angle)) {
				return this.min;
			} else {
				return this.max;
			}
		}
	} else {
		return _angle;
	}
}
/**
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 *
 * OpenEyes is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenEyes is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenEyes.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Squiggles are free-hand lines drawn by the mouse;
 * Points are stored in an array and represent points in the doodle plane
 *
 * @class Squiggle
 * @property {Doodle} doodle The doodle to which this squiggle belongs
 * @property {Colour} colour Colour of the squiggle
 * @property {Int} thickness Thickness of the squiggle in pixels
 * @property {Bool} filled True if squiggle is solid (filled)
 * @property {Array} pointsArray Array of points making up the squiggle
 * @property {Bool} complete True if the squiggle is complete (allows a filled squiggle to appear as a line while being created)
 * @param {Doodle} _doodle
 * @param {Colour} _colour
 * @param {Int} _thickness
 * @param {Bool} _filled
 */
ED.Squiggle = function(_doodle, _colour, _thickness, _filled) {
	this.doodle = _doodle;
	this.colour = _colour;
	this.thickness = _thickness;
	this.filled = _filled;

	this.pointsArray = new Array();
	this.complete = false;
}

/**
 * Adds a point to the points array
 *
 * @param {Point} _point
 */
ED.Squiggle.prototype.addPoint = function(_point) {
	this.pointsArray.push(_point);
}

/**
 * Returns a squiggle in JSON format
 *
 * @returns {String} A JSON encoded string representing the squiggle
 */
ED.Squiggle.prototype.json = function() {
	var s = '{';
	s = s + '"colour":' + this.colour.json() + ',';
	s = s + '"thickness": ' + this.thickness + ',';
	s = s + '"filled": "' + this.filled + '",';

	s = s + '"pointsArray":[';
	for (var i = 0; i < this.pointsArray.length; i++) {
		if (this.pointsArray[i]) {
            s = s + this.pointsArray[i].json();
        } else {
            s = s + '{}';
        }
		if (this.pointsArray.length - i > 1) {
			s = s + ',';
		}
	}
	s = s + ']';
	s = s + '}';

	return s;
}
/**
 * 
 * @author <a href="mailto:bill.aylward@mac.com">Bill Aylward</a>
 * @version 0.9
 *
 * Modification date: 15th June 2012
 * Copyright 2012 OpenEyes
 * 
 * This file is part of OpenEyes.
 * 
 * OpenEyes is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * OpenEyes is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenEyes.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @namespace ED
 * @description Namespace for all EyeDraw classes
 */
if (ED == null || typeof(ED) != "object") {
	var ED = new Object();
}

/**
 * Language specific categories which can be used to take actions following addition of a doodle
 */
ED.Categories = new Object();

/**
 * Complications
 */
ED.Categories['EntrySiteBreak'] = {
	complication: 'Entry site break'
};
ED.Categories['RetinalTouch'] = {
	complication: 'Retinal touch'
};
ED.Categories['IatrogenicBreak'] = {
	complication: 'Iatrogenic break'
};
ED.Categories['SubretinalPFCL'] = {
	complication: 'Subretinal PFCL'
};

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Family Member
 *
 * @class FamilyMember
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.FamilyMember = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "FamilyMember";

	// Special parameters (passed from Pedigree Object)
	this.node = null;

	// Derived parameters
	this.dimension = 32;
	this.gender = 'Male';
	this.drawStub = false;
	this.affected = false;
	this.deceased = false;
	this.isProband = false;
	this.condition = "";

	// Saved parameters (NB not for saving in JSON, but stops controls resetting values)
	this.savedParameterArray = ['gender', 'affected', 'deceased', 'condition'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'gender':'Gender', 'affected':'Affected', 'deceased':'Deceased', 'condition':'Text'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.FamilyMember.prototype = new ED.Doodle;
ED.FamilyMember.prototype.constructor = ED.FamilyMember;
ED.FamilyMember.superclass = ED.Doodle.prototype;

/**
 * Sets default properties
 */
ED.FamilyMember.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['dimension'] = {
		kind: 'derived',
		type: 'int',
		range: new ED.Range(0, 1000),
		animate: true
	};
	this.parameterValidationArray['gender'] = {
		kind: 'derived',
		type: 'string',
		list: ['Male', 'Female', 'Unknown'],
		animate: true
	};
	this.parameterValidationArray['drawStub'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['affected'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['deceased'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['isProband'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['condition'] = {
		kind: 'derived',
		type: 'freeText',
		animate: true
	};
}

/**
 * Sets default parameters
 */
ED.FamilyMember.prototype.setParameterDefaults = function() {

}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.FamilyMember.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'gender':
			if (this.node) this.node.member.gender = _value.charAt(0);
			updateMemberSet(this.node.member.name, 'gender', this.node.member.gender);
			break;
		case 'affected':
			if (this.node) this.node.member.affected = _value == "true"?true:false;
			updateMemberSet(this.node.member.name, 'affected', this.node.member.affected);
			break;
		case 'deceased':
			if (this.node) this.node.member.deceased = _value == "true"?true:false;
			updateMemberSet(this.node.member.name, 'deceased', this.node.member.deceased);
			break;
// 		case 'condition':
// 			if (this.node) this.node.member.condition = _value == "true"?true:false;
// 			updateMemberSet(this.node.member.name, 'deceased', this.node.member.deceased);
// 			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.FamilyMember.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.FamilyMember.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();
	switch (this.gender) {
		case 'Male':
			ctx.rect(-this.dimension, -this.dimension, this.dimension * 2, this.dimension * 2);
			break;
		case 'Female':
			ctx.arc(0, 0, this.dimension, 0, Math.PI * 2, true);
			break;
		case 'Unknown':
			ctx.moveTo(0, -this.dimension);
			ctx.lineTo(-this.dimension, 0);
			ctx.lineTo(0, this.dimension);
			ctx.lineTo(this.dimension, 0);
			ctx.lineTo(0, -this.dimension);
			break;
	}

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "rgba(120,120,120,0.75)";

	// Colour of fill
	if (this.affected) ctx.fillStyle = "rgba(150,150,150,0.75)";
	else ctx.fillStyle = "rgba(255,255,255,0.75)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		if (this.drawStub) {
			ctx.beginPath();
			ctx.moveTo(0, -this.dimension);
			ctx.lineTo(0, -this.dimension * 2);
			ctx.stroke();
		}

		if (this.deceased) {
			var d = this.dimension * 1.2;
			ctx.beginPath();
			ctx.moveTo(-d, d);
			ctx.lineTo(d, -d);
			ctx.stroke();
		}

		if (this.isProband) {
			var d = this.dimension * 1.3;
			var l = 5;
			ctx.beginPath();
			ctx.moveTo(-l, d);
			ctx.lineTo(l, d);
			ctx.lineTo(0, d - l);
			ctx.closePath()
			ctx.fillStyle = "rgba(150,150,150,0.75)";
			ctx.fill();
			ctx.stroke();
		}

		// Draw condition
		ctx.font = "24px sans-serif";
		ctx.fillStyle = "rgba(100,100,100,0.75)";
		var width = ctx.measureText(this.condition).width + 10 * 2;
		ctx.fillText(this.condition, -width / 2 + 10, 64);
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Sets characteristics of the member from the node
 *
 * @returns {String} Description of doodle
 */
ED.FamilyMember.prototype.setNode = function(_node) {
	this.node = _node;
	if (this.node.type == PD.NodeType.Female) this.gender = 'Female';
	if (this.node.type == PD.NodeType.Male) this.gender = 'Male';
	if (this.node.type == PD.NodeType.Unknown) this.gender = 'Unknown';

	this.isProband = this.node.member.isProband;
	this.affected = this.node.member.affected;
	this.deceased = this.node.member.deceased;
	this.condition = this.node.member.condition;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Freehand drawing
 *
 * @class Freehand
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Freehand = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Freehand";

	// Private parameters
	this.labelWidth = 0;
	this.labelHeight = 80;
	this.labelFont = "60px sans-serif";

	// Derived parameters
	this.colourString = "00FF00FF";
	this.filled = true;
	this.thickness = 'Thin';
	this.labelText = "";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'colourString', 'filled', 'thickness', 'labelText'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'colourString':'Colour', 'filled':'Fill', 'thickness':'Thickness', 'labelText':'Label'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Freehand.prototype = new ED.Doodle;
ED.Freehand.prototype.constructor = ED.Freehand;
ED.Freehand.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Freehand.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, true);
}

/**
 * Sets default dragging attributes
 */
ED.Freehand.prototype.setPropertyDefaults = function() {
	this.isDrawable = true;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['colourString'] = {
		kind: 'derived',
		type: 'colourString',
		list: ['FF0000FF', '00FF00FF', '0000FFFF'],
		animate: true
	};
	this.parameterValidationArray['filled'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['thickness'] = {
		kind: 'derived',
		type: 'string',
		list: ['Thin', 'Medium', 'Thick'],
		animate: true
	};
	this.parameterValidationArray['labelText'] = {
		kind: 'derived',
		type: 'freeText',
		animate: true
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Freehand.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(0, 100);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Freehand.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Freehand.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Freehand drawing area
	var halfWidth = 200;
	ctx.rect(-halfWidth, -halfWidth, halfWidth * 2, halfWidth * 2);

	// Close path
	ctx.closePath();

	// Create colour object for squiggle
	var colourObject = new ED.Colour(0, 0, 0, 1);
	colourObject.setWithHexString(this.colourString);

	// Set attributes for border (colour changes to indicate drawing mode)
	ctx.lineWidth = 2;
	this.isFilled = false;
	ctx.strokeStyle = "rgba(255, 255, 255, 0)";
	if (this.isSelected) ctx.strokeStyle = "gray";
	if (this.isForDrawing) ctx.strokeStyle = "blue";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Iterate through squiggles, drawing them
		for (var i = 0; i < this.squiggleArray.length; i++) {
			var squiggle = this.squiggleArray[i];

			// New path for squiggle
			ctx.beginPath();

			// Squiggle attributes
			ctx.lineWidth = squiggle.thickness;
			ctx.strokeStyle = squiggle.colour.rgba();
			ctx.fillStyle = squiggle.colour.rgba();

			// Iterate through squiggle points
			for (var j = 0; j < squiggle.pointsArray.length; j++) {
				ctx.lineTo(squiggle.pointsArray[j].x, squiggle.pointsArray[j].y);
			}

			// Draw squiggle
			ctx.stroke();

			// Optionally fill if squiggle is complete (stops filling while drawing)
			if (squiggle.filled && squiggle.complete) ctx.fill();
		}

		// Draw optional label
		if (this.labelText.length > 0) {
			// Draw text
			ctx.font = this.labelFont;
			this.labelWidth = ctx.measureText(this.labelText).width;
			ctx.fillStyle = "black";
			ctx.fillText(this.labelText, -this.labelWidth / 2, this.labelHeight / 6);
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(halfWidth, -halfWidth));

	// Draw handles if selected but not if for drawing
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}


/**
 *	Mouse test - used for testing detection of mouse pointer
 *
 * @class  MouseTest
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.MouseTest = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "MouseTest";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.MouseTest.prototype = new ED.Doodle;
ED.MouseTest.prototype.constructor = ED.MouseTest;
ED.MouseTest.superclass = ED.Doodle.prototype;

/**
 * Sets default properties
 */
ED.MouseTest.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.MouseTest.prototype.draw = function(_point) {
	//if (_point) console.log(_point.x, _point.y);

	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.MouseTest.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Square
	var width = 200;
	ctx.rect(-width / 2, -width / 2, width, width);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 1;
	ctx.fillStyle = "white"
	ctx.strokeStyle = "blue";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	if (this.isClicked) console.log(_point.x, _point.y);

	// Non boundary paths here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * GraphAxes
 *
 * @class GraphAxes
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.GraphAxes = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "GraphAxes";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.GraphAxes.prototype = new ED.Doodle;
ED.GraphAxes.prototype.constructor = ED.GraphAxes;
ED.GraphAxes.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.GraphAxes.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.GraphAxes.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.GraphAxes.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Axes
	var l = 400;
	ctx.moveTo(0, -l);
	ctx.lineTo(0, l);
	ctx.moveTo(-l, 0);
	ctx.lineTo(l, 0);
	ctx.moveTo(0, -l);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Axis markers
		ctx.beginPath();

		for (var y = -l; y <= l; y = y + 100) {
			if (y != 0) {
				ctx.moveTo(-20, y);
				ctx.lineTo(20, y);
			}
		}

		for (var x = -l; x <= l; x = x + 100) {
			if (x != 0) {
				ctx.moveTo(x, -20);
				ctx.lineTo(x, 20);
			}
		}

		ctx.stroke();

		// Labels
		ctx.font = "80px sans-serif";
		ctx.fillStyle = "gray";
		ctx.textAlign = 'center'
		ctx.fillText("+Sph", 0, -440);
		ctx.fillText("-Sph", 0, 480);
		ctx.fillText("+Cyl", 400, -40);
		ctx.fillText("-Cyl", -400, -40);
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Label
 *
 * @class Label
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Label = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Label";

	// Private parameters
	this.labelText = "";
	this.lastOriginX = 0;
	this.lastOriginY = 0;

	// Label width and height
	this.labelWidth = 0;
	this.labelHeight = 80;

	// attempt at scaling the font correctly:
	var scale = 1;
	if (_drawing.globalScaleFactor) {
		scale = _drawing.globalScaleFactor;
	}
	var fontSize = 60 * (1/scale);
	// Label font
	this.labelFont = fontSize.toString() + "px sans-serif";

	// Horizontal padding between label and boundary path
	this.padding = 10;

	// Maximum length
	this.maximumLength = 20;

	// Flag to indicate first edit
	this.isEdited = false;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexX', 'apexY', 'labelText', 'lastOriginX', 'lastOriginY'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'labelText':'Text'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Label.prototype = new ED.Doodle;
ED.Label.prototype.constructor = ED.Label;
ED.Label.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Label.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.Label.prototype.setPropertyDefaults = function() {

	this.parameterValidationArray['apexX']['range'].setMinAndMax(-1000, +1000);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-1000, +1000);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['labelText'] = {
		kind: 'derived',
		type: 'freeText',
		animate: false,
		// We use a callback function because the validity of the input value is
		// based on scaleLevel which can be changed at runtime.
		validate: this.validateValue.bind(this)
	};

	this.storeOriginalParams();
};

/**
 * Ensure the input value's text length is not longer than the canvas width.
 * @param  {String} _value The input value.
 */
ED.Label.prototype.validateValue = function(_value) {

	// This accommodates a scenario where a user might zooms out, adds a
	// max-length label, then zooms in, then attempt to delete some text.
	if (_value.length < this.labelText.length) return true;

	var ctx = this.drawing.context;
	ctx.font = this.labelFont;

	// NOTE: for now, we're restricting the max-length of the label to be at 1x scaleLevel.
	// var scaleLevel = this.scaleLevel;
	var scaleLevel = 1;

	// Calculate the text width
	var width = ((ctx.measureText(_value).width + this.padding * 2) * this.drawing.scale) * scaleLevel;

	return (width <= this.drawing.canvas.width)
};


/**
 * Store the original param values.
 * We store these values so we can re-set them when the scale level
 * changes. Unlike other doodles, we want to set the bounds to be the same as
 * the dimensions of the canvas element.
 * @return {Object} [description]
 */
ED.Label.prototype.storeOriginalParams = function() {
	this.originalParams = {
		originX: {
			min: this.parameterValidationArray['originX'].range.min,
			max: this.parameterValidationArray['originX'].range.max
		},
		originY: {
			min: this.parameterValidationArray['originY'].range.min,
			max: this.parameterValidationArray['originY'].range.max
		}
	};
};

/**
 * Override the setScaleLevel method to adjust the origin ranges to allow
 * the label to be dragged to the boundary of the canvas element.
 * @param {Number} _newLevel The new scale level.
 */
ED.Label.prototype.setScaleLevel = function(_newLevel) {
	// Call super method.
	ED.Doodle.prototype.setScaleLevel.apply(this, arguments);

	var minX = this.originalParams.originX.min / this.scaleLevel;
	var maxX = this.originalParams.originX.max / this.scaleLevel;

	var minY = this.originalParams.originY.min / this.scaleLevel;
	var maxY = this.originalParams.originY.max / this.scaleLevel;

	this.parameterValidationArray['originX']['range'].setMinAndMax(minX, maxX);
	this.parameterValidationArray['originY']['range'].setMinAndMax(minY, maxY);
};

/**
 * Sets default parameters
 */
ED.Label.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(0, -100);
	this.lastOriginX = this.originX;
	this.lastOriginY = this.originY;
	this.apexX = +100;
	this.apexY = -150;
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.Label.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	// This code is used to prevent the handle from moving.
	switch (_parameter) {
		case 'originX':
			returnArray['apexX'] = this.apexX - (_value - this.lastOriginX);
			this.lastOriginX = _value;
			break;
		case 'originY':
			returnArray['apexY'] = this.apexY - (_value - this.lastOriginY);
			this.lastOriginY = _value;
			break;
	}

	return returnArray;
}

/**
 * Override the addBinding method to validate the input value oninput.
 */
ED.Label.prototype.addBinding = function(_parameter, _fieldParameters) {

	ED.Doodle.prototype.addBinding.apply(this, arguments);

	var drawing = this.drawing;
	var id = this.id;
	var className = this.className;
	var element = document.getElementById(_fieldParameters['id']);

	if (_parameter === 'labelText') {
		element.addEventListener('input', function(event) {
			drawing.eventHandler('oninput', id, className, this.id, this.value);
		}, false);
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Label.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Label.superclass.draw.call(this, _point);

	// Set font
	ctx.font = this.labelFont;

	// Calculate pixel width of text with padding
	this.labelWidth = ctx.measureText(this.labelText).width + this.padding * 2;

	// Boundary path
	ctx.beginPath();

	// label boundary
	ctx.rect(-this.labelWidth / 2, -this.labelHeight / 2, this.labelWidth, this.labelHeight);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 2;
	this.isFilled = false;
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";
	if (this.isSelected) ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Draw text
		ctx.fillText(this.labelText, -this.labelWidth / 2 + this.padding, this.labelHeight / 6);

		// Coordinate of start of arrow
		var arrowStart = new ED.Point(0, 0);

		// Calculation of which quadrant arrowEnd is in
		var q;
		if (this.apexX == 0) q = 2;
		else q = Math.abs(this.apexY / this.apexX);

		// Set start
		if (this.apexY <= 0 && q >= 1) {
			arrowStart.x = 0;
			arrowStart.y = -this.labelHeight / 2;
		}
		if (this.apexX <= 0 && q < 1) {
			arrowStart.x = -this.labelWidth / 2;
			arrowStart.y = 0;
		}
		if (this.apexY > 0 && q >= 1) {
			arrowStart.x = 0;
			arrowStart.y = this.labelHeight / 2;
		}
		if (this.apexX > 0 && q < 1) {
			arrowStart.x = this.labelWidth / 2;
			arrowStart.y = 0;
		}

		// Coordinates of end of arrow
		var arrowEnd = new ED.Point(this.apexX, this.apexY);

		// Draw arrow
		ctx.beginPath();
		ctx.moveTo(arrowStart.x, arrowStart.y);
		ctx.lineTo(arrowEnd.x, arrowEnd.y);
		ctx.strokeStyle = "Gray";
		ctx.lineWidth = 4;
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Runs when doodle is selected by the user
 */
ED.Label.prototype.onSelection = function() {
	// Call method in superclass
	ED.Label.superclass.onSelection.call(this);

	// Set focus to control to allow immediate typing
	document.getElementById(this.parameterControlElementId('labelText')).focus();
}

/**
 * Adds a letter to the label text
 *
 * @param {Int} _keyCode Keycode of pressed key
 */
// ED.Label.prototype.addLetter = function(_keyCode) {
// 	// Need code here to convert to character
// 	var character = String.fromCharCode(_keyCode);
//
// 	if (!this.isEdited) {
// 		this.labelText = "";
// 		this.isEdited = true;
// 	}
//
// 	// Use backspace to edit
// 	if (_keyCode == 8) {
// 		if (this.labelText.length > 0) this.labelText = this.labelText.substring(0, this.labelText.length - 1);
// 	} else {
// 		if (this.labelText.length < this.maximumLength) this.labelText += character;
// 	}
//
// 	// Save changes by triggering parameterChanged method in controller
// 	if (this.isEdited) {
// 		// Create notification message
// 		var object = new Object;
// 		object.doodle = this;
//
// 		// Trigger notification
// 		this.drawing.notify('parameterChanged', object);
// 	}
// }

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Family Member
 *
 * @class MemberConnector
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.MemberConnector = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "MemberConnector";

	// Special parameters (passed from Pedigree Object)
	this.node = null;

	// Derived parameters
	this.length = 0;
	this.type = "Pair";

	// Saved parameters
	//this.savedParameterArray = ['rotation', 'gender'];

	// Parameters in doodle control bar (parameter name: parameter label)
	//this.controlParameterArray = {'gender':'Gender'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.MemberConnector.prototype = new ED.Doodle;
ED.MemberConnector.prototype.constructor = ED.MemberConnector;
ED.MemberConnector.superclass = ED.Doodle.prototype;

/**
 * Sets default properties
 */
ED.MemberConnector.prototype.setPropertyDefaults = function() {
	//this.gridSpacing = 120;
	//this.snapToGrid = true;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['length'] = {
		kind: 'derived',
		type: 'int',
		range: new ED.Range(0, 1000),
		animate: true
	};
	this.parameterValidationArray['type'] = {
		kind: 'derived',
		type: 'string',
		list: ['Pair', 'Sibling'],
		animate: true
	};
}

/**
 * Sets default parameters
 */
ED.MemberConnector.prototype.setParameterDefaults = function() {
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.MemberConnector.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.MemberConnector.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();
	switch (this.type) {
		case 'Pair':
			ctx.moveTo(-this.length/2, 0);
			ctx.lineTo(this.length/2, 0);
			ctx.moveTo(0,0);
			ctx.lineTo(0, this.length);
			break;
		case 'Sibling':
			ctx.moveTo(-this.length/2, 0);
			ctx.lineTo(this.length/2, 0);
			break;
	}

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "rgba(120,120,120,0.75)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */
 
/**
 *	OperatingTable
 *
 * @class  OperatingTable
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.OperatingTable = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "OperatingTable";

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.OperatingTable.prototype = new ED.Doodle;
ED.OperatingTable.prototype.constructor = ED.OperatingTable;
ED.OperatingTable.superclass = ED.Doodle.prototype;

/**
 * Sets default properties
 */
ED.OperatingTable.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.OperatingTable.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.OperatingTable.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Head
	ctx.arc(0, -0, 60, 0, Math.PI * 2, true);

	// Set Attributes
	ctx.lineWidth = 30;
	ctx.strokeStyle = "rgba(120,120,120,1)";
	ctx.fillStyle = "rgba(220,220,220,1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		// Bed
		ctx.rect(-100, 20, 200, 400);

		// Set Attributes
		ctx.lineWidth = 8;
		ctx.strokeStyle = "rgba(120,120,120,1)";
		ctx.fillStyle = "rgba(220,220,220,1)";

		ctx.fill();
		ctx.stroke();
	}

	// Return value indicating successful hittest
	return this.isClicked;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */
 
/**
 * Patient
 *
 * @class patient
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Patient = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Patient";
	
	// Derived parameters
	this.recliningAngle = 0;
	
	// Saved parameters
	this.savedParameterArray = ['rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Patient.prototype = new ED.Doodle;
ED.Patient.prototype.constructor = ED.Patient;
ED.Patient.superclass = ED.Doodle.prototype;


/**
 * Sets default properties
 */
ED.Patient.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.isScaleable = false;
	this.isMoveable = false;
	this.isDeletable = false;
	this.willStaySelected = false;
	//this.snapToAngles = true
	
	// Adjust ranges for simple parameters
	this.parameterValidationArray['rotation']['range'] = new ED.Range(270 * Math.PI / 180, 360 * Math.PI/180);
	
	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['recliningAngle'] = {
		kind: 'derived',
		type: 'mod',
		range: new ED.Range(0, 91),
		clock: 'bottom',
		animate: true
	};
	
	// Array of angles to snap to
// 	var phi = Math.PI / 6;
// 	this.anglesArray = [phi * 9, phi * 10, phi * 11, phi * 12];
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Patient.prototype.setParameterDefaults = function() {
	this.scaleX = 0.65;
	this.scaleY = 0.7;
	this.recliningAngle = 0
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.Patient.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'rotation':
			// Watch for edge conditions from over-rotating
			var angle = 360 - _value * 180/Math.PI;
			if (angle > 300) { angle = 0; }
			if (angle > 90) { angle = 90; }
			returnArray['recliningAngle'] = angle;
			break;

		case 'recliningAngle':
			var angle = (360 - _value) * Math.PI / 180;
			returnArray['rotation'] = angle;
			break;
	}

	return returnArray;
}


/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Patient.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Patient.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();
	
	ctx.moveTo(-642,41);
	ctx.bezierCurveTo(-653,-91,-522,-146,-496,-148);
	ctx.bezierCurveTo(-470,-150,-221,-159,-199,-166);
	ctx.bezierCurveTo(-177,-174,-168,-201,-126,-221);
	ctx.bezierCurveTo(-95,-232,-71,-223,-54,-214);
	ctx.bezierCurveTo(-38,-205,-32,-170,-16,-168);
	ctx.bezierCurveTo(1,-166,21,-184,37,-166);
	ctx.bezierCurveTo(54,-148,21,-137,36,-126);
	ctx.bezierCurveTo(50,-115,58,-130,83,-122);
	ctx.bezierCurveTo(109,-115,169,-91,190,-82);
	ctx.bezierCurveTo(210,-73,232,-64,270,-67);
	ctx.bezierCurveTo(309,-71,301,-87,318,-106);
	ctx.bezierCurveTo(334,-124,316,-130,343,-155);
	ctx.bezierCurveTo(362,-170,395,-166,395,-166);
	ctx.lineTo(406,-177);
	ctx.lineTo(420,-168);
	ctx.lineTo(441,-175);
	ctx.bezierCurveTo(441,-175,441,-201,453,-203);
	ctx.bezierCurveTo(466,-205,492,-170,510,-168);
	ctx.bezierCurveTo(529,-166,508,-181,538,-181);
	ctx.bezierCurveTo(567,-181,617,-150,640,-137);
	ctx.bezierCurveTo(662,-108,651,-120,662,-90);
	ctx.bezierCurveTo(673,-60,677,-16,666,12);
	ctx.bezierCurveTo(655,39,642,52,618,61);
	ctx.bezierCurveTo(595,70,529,74,549,74);
	ctx.bezierCurveTo(569,74,442,74,463,72);
	ctx.bezierCurveTo(371,79,389,78,365,100);
	ctx.bezierCurveTo(342,122,354,158,336,191);
	ctx.bezierCurveTo(318,224,305,228,266,253);
	ctx.bezierCurveTo(125,279,-56,336,-106,296);
	ctx.bezierCurveTo(-122,270,-118,266,-139,224);
	ctx.bezierCurveTo(-175,221,-357,234,-446,236);
	ctx.bezierCurveTo(-536,239,-631,173,-642,41);

	// Close path
	ctx.closePath();

	// Set Attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "rgba(120,120,120,1)";

	// Set light blue for surgeon's gown
	var colour = new ED.Colour(0, 0, 0, 1);
	colour.setWithHexString('3AFEFA');
	ctx.fillStyle = colour.rgba();
	
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 *
 *
 * @class Signature
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Signature = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Signature";

	this.colourString = "00FF00FF";


	// Saved parameters
	this.savedParameterArray = [];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Signature.prototype = new ED.Doodle;
ED.Signature.prototype.constructor = ED.Signature;
ED.Signature.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Signature.prototype.setHandles = function() {
}

/**
 * Sets default dragging attributes
 */
ED.Signature.prototype.setPropertyDefaults = function() {
	this.isDrawable = true;
	this.isMoveable = false;
	this.isRotatable = false;
	this.isFilled = false;
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Signature.prototype.setParameterDefaults = function() {
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Signature.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Signature.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Draw invisible boundary around whole canvas for signature drawing area
	var height = this.drawing.canvas.height / this.drawing.scale *0.99;
	var width = this.drawing.canvas.width / this.drawing.scale *0.99;
	var halfWidth = width/2;
	var halfHeight = height/2;
	ctx.rect(-halfWidth, -halfHeight, width, height);

	// Close path
	ctx.closePath();
	
	// Set attributes for border (colour changes to indicate drawing mode)
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgba(255, 255, 255, 0)";
	

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		
		// Calculated no. dashes in line proportional to canvas size
		var d = 40;
		var n = parseInt(width*0.85/d);
		
		ctx.beginPath();
		// Draw cross
		ctx.moveTo(-halfWidth*0.85, halfHeight*0.75 - 40);
		ctx.lineTo(-halfWidth*0.85 + 50, halfHeight*0.75 + 10);
		ctx.moveTo(-halfWidth*0.85, halfHeight*0.75 + 10);
		ctx.lineTo(-halfWidth*0.85 + 50, halfHeight*0.75 - 40);
		
		// Draw dashed line
		for (var h=2; h<n; h++) { // start at 2 to allow for space at beginning
			ctx.moveTo(-halfWidth*0.85 + h*d, halfHeight*0.75);
			ctx.lineTo(-halfWidth*0.85 + h*d + 0.5*d, halfHeight*0.75);
		}
		
		ctx.lineWidth = 6;
		ctx.strokeStyle = "gray";
		if (this.isForDrawing && this.isSelected) ctx.strokeStyle = "blue";
// 		else if (this.isSelected) ctx.strokeStyle = "gray";
		
		ctx.stroke();
		
		// Iterate through squiggles, drawing them
		for (var i = 0; i < this.squiggleArray.length; i++) {
			var squiggle = this.squiggleArray[i];

			// New path for squiggle
			ctx.beginPath();

			// Squiggle attributes
			ctx.lineWidth = 6;
			ctx.strokeStyle = "black";

			// Iterate through squiggle points
			for (var j = 0; j < squiggle.pointsArray.length; j++) {
				ctx.lineTo(squiggle.pointsArray[j].x, squiggle.pointsArray[j].y);
			}

			// Draw squiggle
			ctx.stroke();
			
		}
	}

	// Return value indicating successful hittest
	return this.isClicked;
}
/**
 * Slider2D
 *
 * @class Slider2D
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Slider2D = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Slider2D";

	// Derived parameters
	this.sphereSign = ' ';
	this.sphereInteger = 0;
	this.sphereFractional = 0;
	this.cylinderSign = ' ';
	this.cylinderInteger = 0;
	this.cylinderFractional = 0;

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Slider2D.prototype = new ED.Doodle;
ED.Slider2D.prototype.constructor = ED.Slider2D;
ED.Slider2D.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.Slider2D.prototype.setPropertyDefaults = function() {
	this.snapToGrid = true;
	this.gridSpacing = 5;
	this.isShowHighlight = false;

	// Update component of validation array for simple parameters (enable 2D control by adding -50, +50 apexX range
	this.parameterValidationArray['originX']['range'].setMinAndMax(-400, +400);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-400, +400);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['sphereSign'] = {
		kind: 'derived',
		type: 'string',
		list: ['+', '=', '-'],
		animate: true
	};
	this.parameterValidationArray['sphereInteger'] = {
		kind: 'derived',
		type: 'int',
		range: new ED.Range(0, +20),
		animate: true
	};
	this.parameterValidationArray['sphereFractional'] = {
		kind: 'derived',
		type: 'string',
		list: ['.00', '.25', '.50', '.75'],
		animate: true
	};
	this.parameterValidationArray['cylinderSign'] = {
		kind: 'derived',
		type: 'string',
		list: ['+', '=', '-'],
		animate: true
	};
	this.parameterValidationArray['cylinderInteger'] = {
		kind: 'derived',
		type: 'int',
		range: new ED.Range(0, +20),
		animate: true
	};
	this.parameterValidationArray['cylinderFractional'] = {
		kind: 'derived',
		type: 'string',
		list: ['.00', '.25', '.50', '.75'],
		animate: true
	};
}

/**
 * Sets default parameters
 */
ED.Slider2D.prototype.setParameterDefaults = function() {
	this.setParameterFromString('sphereSign', '=');
	this.setParameterFromString('sphereInteger', '0');
	this.setParameterFromString('sphereFractional', '.00');
	this.setParameterFromString('cylinderSign', '=');
	this.setParameterFromString('cylinderInteger', '0');
	this.setParameterFromString('cylinderFractional', '.00');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.Slider2D.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'sphereSign':
			switch (_value) {
				case '+':
					returnArray['originY'] = -1 * Math.abs(this.originY);
					break;

				case '=':
					returnArray['originY'] = 0;
					break;

				case '-':
					returnArray['originY'] = Math.abs(this.originY);
					break;
			}
			break;

		case 'sphereInteger':
			returnArray['originY'] = (20 * (parseInt(_value) + parseFloat(this.sphereFractional))) * (this.sphereSign == '-' ? 1 : -1);
			break;

		case 'sphereFractional':
			returnArray['originY'] = (20 * (this.sphereInteger + parseFloat(_value))) * (this.sphereSign == '-' ? 1 : -1);
			break;

		case 'cylinderSign':
			switch (_value) {
				case '+':
					returnArray['originX'] = Math.abs(this.originX);
					break;

				case '=':
					returnArray['originX'] = 0;
					break;

				case '-':
					returnArray['originX'] = -1 * Math.abs(this.originX);
					break;
			}
			break;

		case 'cylinderInteger':
			returnArray['originX'] = (20 * (parseInt(_value) + parseFloat(this.sphereFractional))) * (this.sphereSign == '-' ? -1 : 1);
			break;

		case 'cylinderFractional':
			returnArray['originX'] = (20 * (this.sphereInteger + parseFloat(_value))) * (this.sphereSign == '-' ? -1 : 1);
			break;

		case 'originY':
			// Sign
			if (_value > 0) returnArray['sphereSign'] = '-';
			else if (_value < 0) returnArray['sphereSign'] = '+';
			else returnArray['sphereSign'] = '=';

			// Integer
			returnArray['sphereInteger'] = Math.floor(Math.abs(_value / 20));

			// Fractional
			var diff = Math.abs(_value / 20) - Math.floor(Math.abs(_value / 20));
			if (diff == 0) returnArray['sphereFractional'] = '.00';
			if (diff == 0.25) returnArray['sphereFractional'] = '.25';
			if (diff == 0.5) returnArray['sphereFractional'] = '.50';
			if (diff == 0.75) returnArray['sphereFractional'] = '.75';
			break;

		case 'originX':
			// Sign
			if (_value < 0) returnArray['cylinderSign'] = '-';
			else if (_value > 0) returnArray['cylinderSign'] = '+';
			else returnArray['cylinderSign'] = '=';

			// Integer
			returnArray['cylinderInteger'] = Math.floor(Math.abs(_value / 20));

			// Fractional
			var diff = Math.abs(_value / 20) - Math.floor(Math.abs(_value / 20));
			if (diff == 0) returnArray['cylinderFractional'] = '.00';
			if (diff == 0.25) returnArray['cylinderFractional'] = '.25';
			if (diff == 0.5) returnArray['cylinderFractional'] = '.50';
			if (diff == 0.75) returnArray['cylinderFractional'] = '.75';
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Slider2D.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Slider2D.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Slider shape
	var d = 30;
	var w = 80;
	ctx.moveTo(0, -w - d);
	ctx.lineTo(d, -w);
	ctx.lineTo(w, -w);
	ctx.lineTo(w, -d);
	ctx.lineTo(w + d, 0);
	ctx.lineTo(w, d);
	ctx.lineTo(w, w);
	ctx.lineTo(d, w);
	ctx.lineTo(0, w + d);
	ctx.lineTo(-d, w);
	ctx.lineTo(-w, w);
	ctx.lineTo(-w, d);
	ctx.lineTo(-w - d, 0);
	ctx.lineTo(-w, -d);
	ctx.lineTo(-w, -w);
	ctx.lineTo(-d, -w);
	ctx.closePath();
	//ctx.rect(-50, -50, 100, 100);

	// Set line attributes
	ctx.lineWidth = 2;
	ctx.strokeStyle = "blue";

	// Vertical gradient fill
	var bottomColour = "rgba(130, 205, 205, 0.5)";
	var topColour = "rgba(170, 225, 225, 0.5)";
	var gradient = ctx.createLinearGradient(0, -25, 0, 25);
	gradient.addColorStop(0, topColour);
	gradient.addColorStop(1, bottomColour);
	ctx.fillStyle = gradient;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Axes
		ctx.beginPath();

		// Axes
		var l = 100;
		ctx.moveTo(0, -l);
		ctx.lineTo(0, l);
		ctx.moveTo(-l, 0);
		ctx.lineTo(l, 0);
		ctx.moveTo(0, -l);

		ctx.strokeStyle = "gray";
		ctx.stroke();
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Surgeon
 *
 * @class Surgeon
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Surgeon = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Surgeon";

	// Derived parameters
	this.surgeonPosition = 'Temporal';

	// Saved parameters
	this.savedParameterArray = ['surgeonPosition'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
};

/**
 * Sets superclass and constructor
 */
ED.Surgeon.prototype = new ED.Doodle;
ED.Surgeon.prototype.constructor = ED.Surgeon;
ED.Surgeon.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.Surgeon.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.snapToAngles = true;
	this.willStaySelected = false;
	this.isUnique = true;
	this.isDeletable = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(+100, +500);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['surgeonPosition'] = {
		kind: 'derived',
		type: 'string',
		list: ['Superior', 'Supero-temporal', 'Temporal', 'Infero-temporal', 'Inferior', 'Infero-nasal', 'Nasal', 'Supero-nasal'],
		animate: true
	};

	// Array of angles to snap to
	var phi = Math.PI / 4;
	this.anglesArray = [0, phi, phi * 2, phi * 3, phi * 4, phi * 5, phi * 6, phi * 7];
};

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Surgeon.prototype.setParameterDefaults = function() {
	this.rotation = 0;
	this.setParameterFromString('surgeonPosition', 'Temporal');
};

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.Surgeon.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = {};

	var isRE = (this.drawing.eye == ED.eye.Right);
	var dial = 2 * Math.PI;

	switch (_parameter) {
		// Surgeon position
		case 'rotation':
			if (isRE) {
				if (_value < dial / 16) {
					returnArray['surgeonPosition'] = 'Superior';
				} else if (_value < 3 * dial / 16) {
					returnArray['surgeonPosition'] = 'Supero-nasal';
				} else if (_value < 5 * dial / 16) {
					returnArray['surgeonPosition'] = 'Nasal';
				} else if (_value < 7 * dial / 16) {
					returnArray['surgeonPosition'] = 'Infero-nasal';
				} else if (_value < 9 * dial / 16) {
					returnArray['surgeonPosition'] = 'Inferior';
				} else if (_value < 11 * dial / 16) {
					returnArray['surgeonPosition'] = 'Infero-temporal';
				} else if (_value < 13 * dial / 16) {
					returnArray['surgeonPosition'] = 'Temporal';
				} else if (_value < 15 * dial / 16) {
					returnArray['surgeonPosition'] = 'Supero-temporal';
				} else {
					returnArray['surgeonPosition'] = 'Superior';
				}
			} else {
				if (_value < dial / 16) {
					returnArray['surgeonPosition'] = 'Superior';
				} else if (_value < 3 * dial / 16) {
					returnArray['surgeonPosition'] = 'Supero-temporal';
				} else if (_value < 5 * dial / 16) {
					returnArray['surgeonPosition'] = 'Temporal';
				} else if (_value < 7 * dial / 16) {
					returnArray['surgeonPosition'] = 'Infero-temporal';
				} else if (_value < 9 * dial / 16) {
					returnArray['surgeonPosition'] = 'Inferior';
				} else if (_value < 11 * dial / 16) {
					returnArray['surgeonPosition'] = 'Infero-nasal';
				} else if (_value < 13 * dial / 16) {
					returnArray['surgeonPosition'] = 'Nasal';
				} else if (_value < 15 * dial / 16) {
					returnArray['surgeonPosition'] = 'Supero-nasal';
				} else {
					returnArray['surgeonPosition'] = 'Superior';
				}
			}
			break;

		case 'surgeonPosition':
			switch (_value) {
				case 'Superior':
					returnArray['rotation'] = 0;
					break;
				case 'Supero-temporal':
					returnArray['rotation'] = isRE ? 7 * Math.PI / 4 : 1 * Math.PI / 4;
					break;
				case 'Temporal':
					returnArray['rotation'] = isRE ? 6 * Math.PI / 4 : 2 * Math.PI / 4;
					break;
				case 'Infero-temporal':
					returnArray['rotation'] = isRE ? 5 * Math.PI / 4 : 3 * Math.PI / 4;
					break;
				case 'Inferior':
					returnArray['rotation'] = Math.PI;
					break;
				case 'Infero-nasal':
					returnArray['rotation'] = isRE ? 3 * Math.PI / 4 : 5 * Math.PI / 4;
					break;
				case 'Nasal':
					returnArray['rotation'] = isRE ? 2 * Math.PI / 4 : 6 * Math.PI / 4;
					break;
				case 'Supero-nasal':
					returnArray['rotation'] = isRE ? 1 * Math.PI / 4 : 7 * Math.PI / 4;
					break;
			}
			break;
	}

	return returnArray;
};

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Surgeon.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Surgeon.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Scaling factor
	var s = 0.2;

	// Shift up y-axis
	var y = -300;

	// Surgeon
	ctx.moveTo(0 * s, y - 200 * s);
	ctx.bezierCurveTo(-100 * s, y - 250 * s, -145 * s, y - 190 * s, -200 * s, y - 180 * s);
	ctx.bezierCurveTo(-310 * s, y - 160 * s, -498 * s, y - 75 * s, -500 * s, y + 0 * s);
	ctx.bezierCurveTo(-500 * s, y + 50 * s, -500 * s, y + 460 * s, -470 * s, y + 700 * s);
	ctx.bezierCurveTo(-470 * s, y + 710 * s, -500 * s, y + 770 * s, -500 * s, y + 810 * s);
	ctx.bezierCurveTo(-500 * s, y + 840 * s, -440 * s, y + 850 * s, -420 * s, y + 840 * s);
	ctx.bezierCurveTo(-390 * s, y + 830 * s, -380 * s, y + 710 * s, -380 * s, y + 700 * s);
	ctx.bezierCurveTo(-370 * s, y + 700 * s, -360 * s, y + 780 * s, -350 * s, y + 780 * s);
	ctx.bezierCurveTo(-330 * s, y + 780 * s, -340 * s, y + 730 * s, -340 * s, y + 700 * s);
	ctx.bezierCurveTo(-340 * s, y + 690 * s, -350 * s, y + 680 * s, -350 * s, y + 670 * s);
	ctx.bezierCurveTo(-350 * s, y + 590 * s, -385 * s, y + 185 * s, -300 * s, y + 100 * s);

	ctx.bezierCurveTo(-150 * s, y + 140 * s, -250 * s, y + 200 * s, 0 * s, y + 300 * s);

	ctx.bezierCurveTo(250 * s, y + 200 * s, 150 * s, y + 140 * s, 300 * s, y + 100 * s);
	ctx.bezierCurveTo(380 * s, y + 180 * s, 350 * s, y + 590 * s, 350 * s, y + 670 * s);
	ctx.bezierCurveTo(350 * s, y + 680 * s, 340 * s, y + 690 * s, 340 * s, y + 700 * s);
	ctx.bezierCurveTo(340 * s, y + 730 * s, 330 * s, y + 780 * s, 350 * s, y + 780 * s);
	ctx.bezierCurveTo(360 * s, y + 780 * s, 370 * s, y + 700 * s, 380 * s, y + 700 * s);
	ctx.bezierCurveTo(380 * s, y + 710 * s, 390 * s, y + 830 * s, 420 * s, y + 840 * s);
	ctx.bezierCurveTo(430 * s, y + 845 * s, 505 * s, y + 840 * s, 505 * s, y + 810 * s);
	ctx.bezierCurveTo(505 * s, y + 760 * s, 470 * s, y + 710 * s, 470 * s, y + 700 * s);
	ctx.bezierCurveTo(500 * s, y + 460 * s, 499 * s, y + 45 * s, 500 * s, y + 0 * s);
	ctx.bezierCurveTo(498 * s, y - 78 * s, 308 * s, y - 164 * s, 200 * s, y - 182 * s);
	ctx.bezierCurveTo(145 * s, y - 190 * s, 100 * s, y - 250 * s, 0 * s, y - 200 * s);

	// Set Attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "rgba(120,120,120,1)";

	// Set light blue for surgeon's gown
	var colour = new ED.Colour(0, 0, 0, 1);
	colour.setWithHexString('3AFEFA');
	ctx.fillStyle = colour.rgba();

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Head
		ctx.beginPath();

		ctx.moveTo(0 * s, y - 250 * s);
		ctx.bezierCurveTo(-100 * s, y - 250 * s, -180 * s, y - 200 * s, -200 * s, y - 170 * s);
		ctx.bezierCurveTo(-209 * s, y - 157 * s, -220 * s, y - 100 * s, -230 * s, y - 50 * s);
		ctx.bezierCurveTo(-260 * s, y - 70 * s, -260 * s, y - 20 * s, -260 * s, y + 0 * s);
		ctx.bezierCurveTo(-260 * s, y + 20 * s, -260 * s, y + 80 * s, -230 * s, y + 60 * s);
		ctx.bezierCurveTo(-230 * s, y + 90 * s, -220 * s, y + 141 * s, -210 * s, y + 160 * s);
		ctx.bezierCurveTo(-190 * s, y + 200 * s, -100 * s, y + 280 * s, -40 * s, y + 300 * s);
		ctx.bezierCurveTo(-34 * s, y + 303 * s, -20 * s, y + 350 * s, 0 * s, y + 350 * s);
		ctx.bezierCurveTo(20 * s, y + 350 * s, 34 * s, y + 300 * s, 40 * s, y + 300 * s);
		ctx.bezierCurveTo(100 * s, y + 280 * s, 190 * s, y + 200 * s, 210 * s, y + 160 * s);
		ctx.bezierCurveTo(218 * s, y + 143 * s, 230 * s, y + 90 * s, 230 * s, y + 60 * s);
		ctx.bezierCurveTo(260 * s, y + 80 * s, 260 * s, y + 20 * s, 260 * s, y + 0 * s);
		ctx.bezierCurveTo(260 * s, y - 20 * s, 260 * s, y - 70 * s, 230 * s, y - 50 * s);
		ctx.bezierCurveTo(220 * s, y - 100 * s, 208 * s, y - 158 * s, 200 * s, y - 170 * s);
		ctx.bezierCurveTo(180 * s, y - 200 * s, 100 * s, y - 250 * s, 0 * s, y - 250 * s);

		ctx.fill();
		ctx.stroke();
	}

	// Return value indicating successful hittest
	return this.isClicked;
};
/**
 * 
 * @author <a href="mailto:bill.aylward@mac.com">Bill Aylward</a>
 * @version 0.9
 *
 * Modification date: 15th June 2012
 * Copyright 2012 OpenEyes
 *
 * This file is part of OpenEyes.
 *
 * OpenEyes is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenEyes is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenEyes.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @namespace ED
 * @description Namespace for all EyeDraw classes
 */
if (ED == null || typeof(ED) != "object") {
	var ED = new Object();
}

/**
 * Language specific translations. Mostly used for doodle descriptions.
 *
 * In order to display UTF.8 characters, this file should be loaded with the 'charset="utf-8"' attribute.
 * This currently cannot be done with the Yii registerScriptFile method, so should be loaded using a tag in the view file;
 * <script src="js/Misc/Translations.js" type="text/javascript" charset="utf-8"></script>
 */
ED.trans = new Object();

// For UTF.8, this file should be loaded with the 'charset="utf-8"' attribute. This currently cannot be done with the Yii registerScriptFile method
ED.trans['ACIOL'] = 'Drag to move<br/>Drag the handle to rotate';
ED.trans['ACMaintainer'] = 'Drag to move';
ED.trans['AngleGradeEast'] = 'Drag handle to adjust amount of angle obscure by iris';
ED.trans['AngleGradeNorth'] = 'Drag handle to adjust amount of angle obscure by iris';
ED.trans['AngleGradeSouth'] = 'Drag handle to adjust amount of angle obscure by iris';
ED.trans['AngleGradeWest'] = 'Drag handle to adjust amount of angle obscure by iris';
ED.trans['AngleNV'] = 'Drag to move around angle<br/>Drag handles to change extent';
ED.trans['AngleRecession'] = 'Drag to move around angle<br/>Drag handles to change extent';
ED.trans['AntSeg'] = 'Drag the handle to resize the pupil<br/><br/>The iris is semi-transparent so that IOLs, and<br/>other structures can be seen behind it';
ED.trans['AntSegCrossSection'] = '';
ED.trans['AntSynech'] = 'Drag to move around angle<br/>Drag handles to change extent';
ED.trans['ArcuateKeratotomy'] = 'Drag to rotate<br/>Drag end handle to increase extent<br/>Drag middle handle to change radius';
ED.trans['ArcuateScotoma'] = 'Drag handle to change size';
ED.trans['BiopsySite'] = 'Drag to position';
ED.trans['Bleb'] = 'Drag to move around the limbus<br/>Drag handle to change size';
ED.trans['BlotHaemorrhage'] = 'Drag to position<br/>Drag the handle to change size';
ED.trans['BuckleSuture'] = 'Drag to position';
ED.trans['BusaccaNodule'] = 'Drag to move around the iris';
ED.trans['CapsularTensionRing'] = 'This cannot be selected directly since it is behind the iris<br/>Select the iris first<br/>Then move the scroll wheel until the ring is selected<br/>Click the \'Move to front\' button<br/>Err.. of course if you are seeing this tooltip you have already done it';
ED.trans['ChandelierSingle'] = 'Drag to rotate around centre<br/>';
ED.trans['ChandelierDouble'] = 'Drag to rotate around centre<br/>';
ED.trans['ChoroidalHaemorrhage'] = 'Drag to move around eye<br/>Drag outer handles to change size</br>Drag middle handle to change posterior extent';
ED.trans['ChoroidalNaevus'] = 'Drag to position<br/>Drag outer handles to change shape<br/>Drag outer ring of top handles to rotate<br/>Drag middle handle to add drusen';
ED.trans['CiliaryInjection'] = 'Drag to rotate around centre<br/>Drag handles to change extent';
ED.trans['Circinate'] = 'Drag to position<br/>Drag handle to change size';
ED.trans['CircumferentialBuckle'] = 'Drag to position<br/>Drag outer handles to change extent<br/>Drag middle handle to change width';
ED.trans['ConjunctivalFlap'] = 'Drag to move around the limbus<br/>Drag handles to change size and depth';
ED.trans['CornealAbrasion'] = 'Drag to position<br/>Drag handle to change size';
ED.trans['CorneaCrossSection'] = '';
ED.trans['CornealErosion'] = 'Drag to position<br/>Drag handle to change size';
ED.trans['CornealGraft'] = 'Drag handle to change size';
ED.trans['CornealInlay'] = '';
ED.trans['CornealOedema'] = 'Drag to position<br/>Drag handle to change size';
ED.trans['CornealStriae'] = '';
ED.trans['CornealScar'] = 'Drag outer handle to change shape<br/>Drag inner handle to change density';
ED.trans['CornealSuture'] = 'Drag to move';
ED.trans['CornealLaceration'] = 'Please click to draw each point of the laceration.<br />Double click to complete.';
ED.trans['CorticalCataract'] = 'Drag to move<br/>Drag handle to change density';
ED.trans['CottonWoolSpot'] = 'Drag to position<br/>Drag handle to change shape and size';
ED.trans['CNV'] = 'Drag to move<br/>Drag handle to scale';
ED.trans['CutterPI'] = 'Drag to move around the iris';
ED.trans['CystoidMacularOedema'] = 'Drag handle to change size';
ED.trans['DiabeticNV'] = 'Drag to position<br/>Drag handle to change size';
ED.trans['DiscHaemorrhage'] = 'Drag to position';
ED.trans['DiscPallor'] = 'Drag to position<br/>Drag handles to adjust extent';
ED.trans['DrainageRetinotomy'] = 'Drag to position';
ED.trans['DrainageSite'] = 'Drag to change position';
ED.trans['EncirclingBand'] = 'Drag to change orientation of Watzke sleeve';
ED.trans['EntrySiteBreak'] = 'Drag to position<br/>Drag either end handle to increase extent';
ED.trans['EpiretinalMembrane'] = 'Drag inner handle to change shape and size<br/>Drag outer handle to rotate';
ED.trans['FibrousProliferation'] = 'Drag to position<br/>Drag inner handle to change shape and size<br/>Drag outer handle to rotate';
ED.trans['FibrovascularScar'] = 'Drag to move<br/>Drag handle to scale';
ED.trans['FocalLaser'] = 'Drag the handle for a bigger area with more burns';
ED.trans['Freehand'] = 'Double-click to start drawing<br/>Drag inner handle to change size<br/>Drag outer handle to rotate<br/><br/>Adjust colours and settings in tool bar';
ED.trans['Fundus'] = '';
ED.trans['Fuchs'] = 'Drag handle to change shape';
ED.trans['Geographic'] = 'Drag middle handle to alter size of remaining central island of RPE<br/>Drag outside handle to scale';
ED.trans['Gonioscopy'] = 'Drag top left handle up and down to alter pigment density<br/>Drag top left handle left and right to alter pigment homogeneity';
ED.trans['HardDrusen'] = 'Drag middle handle up and down to alter density of drusen<br/>Drag outside handle to scale';
ED.trans['HardExudate'] = 'Drag to position';
ED.trans['Hyphaema'] = 'Drag handle vertically to change size<br/>Drag handle horizontally to change density';
ED.trans['Hypopyon'] = 'Drag handle vertically to change size';
ED.trans['IatrogenicBreak'] = 'Drag to position<br/>Drag inner handle to change size<br/>Drag outer handle to rotate';
ED.trans['ILMPeel'] = 'Drag to position<br/>Drag handle to change size';
ED.trans['InjectionSite'] = 'Drag to position<br/>Drag handle to adjust distance from limbus';
ED.trans['ICL'] = 'Drag to move<br/>Drag handle to scale and rotate';
ED.trans['IOL'] = 'Drag to move<br/>Drag handle to scale and rotate';
ED.trans['IrisHook'] = 'Drag to move around the clock<br/><br/>The hook will match the size of the pupil as it changes<br/>Subsequent hooks are added to the next quadrant';
ED.trans['IrisNaevus'] = 'Drag to move<br/>Drag handle to change size';
ED.trans['IRMA'] = 'Drag to move<br/>Drag inner handle to change size<br/>Drag outer handle to rotate';
ED.trans['KeraticPrecipitates'] = 'Drag middle handle up and down to alter density<br/>Drag middle handle left and right to alter size<br/>Drag outside handle to scale';
ED.trans['KoeppeNodule'] = 'Drag to move around the iris';
ED.trans['KrukenbergSpindle'] = 'Drag to move</br>Drag outer handle to change shape';
ED.trans['Label'] = 'Drag to move label, type text to edit<br/>Drag handle to move pointer';
ED.trans['LaserCircle'] = 'Drag handle to change shape';
ED.trans['LaserDemarcation'] = 'Drag to rotate<br/>Drag each end handle to increase extent<br/>Drag the middle handle to move line more posteriorly';
ED.trans['LaserSpot'] = 'Drag to position<br/>Drag the handle to change size';
ED.trans['LasikFlap'] = 'Drag to rotate<br/>Drag the handle to scale';
ED.trans['Lens'] = 'Drag to move<br/>Edit properties when selected<br/>Delete to remove';
ED.trans['LensCrossSection'] = '';
ED.trans['LimbalRelaxingIncision'] = 'Drag to move';
ED.trans['Macroaneurysm'] = 'Drag to move';
ED.trans['MacularDystrophy'] = 'Drag outer handle to change size<br/>Drag middle handle to change type';
ED.trans['MacularGrid'] = 'Drag the handle to scale';
ED.trans['MacularHole'] = 'Drag the handle to scale';
ED.trans['MacularThickening'] = 'Drag to position<br/>Drag handle to change size';
ED.trans['MattressSuture'] = 'Drag to move';
ED.trans['Microaneurysm'] = 'Drag to position';
ED.trans['NerveFibreDefect'] = 'Drag to position<br/>Drag handles to change size';
ED.trans['NuclearCataract'] = 'Drag to move<br/>Drag handle to change density';
ED.trans['OperatingTable'] = '';
ED.trans['OpticDisc'] = 'Basic mode: Drag handle to adjust cup/disc ratio<br/>Expert mode: Drag handles to re-shape disc';
ED.trans['OpticDiscPit'] = 'Drag to position<br/>Drag handle to change shape';
ED.trans['Patch'] = 'Drag to position<br/>Drag handle to change size';
ED.trans['Papilloedema'] = '';
ED.trans['PCIOL'] = 'Drag to move<br/>Drag the handle to rotate';
ED.trans['PeripapillaryAtrophy'] = 'Drag to rotate<br/>Drag handles to change extent';
ED.trans['PeripheralRetinectomy'] = 'Drag to rotate<br/>Drag each end handle to increase extent<br/>Drag the middle handle to move posterior limit';
ED.trans['PeripheralRRD'] = 'Drag to rotate<br/>Drag each end handle to increase extent<br/>Drag the middle handle to move posterior limit';
ED.trans['PhakoIncision'] = 'Drag end handle to change length<br/>Drag the middle handle to change section type<br/>Drag the incision itself to move';
ED.trans['PI'] = 'Drag to move around the iris';
ED.trans['PosteriorCapsule'] = '';
ED.trans['PosteriorEmbryotoxon'] = '';
ED.trans['PosteriorRetinectomy'] = 'Drag to position<br/>Drag the handle to change size';
ED.trans['PosteriorSynechia'] = 'Drag to rotate around centre<br/>Drag handles to increase extent';
ED.trans['PostPole'] = 'The disc cup can be edited by clicking on the disc, and dragging the yellow handle<br/>The gray circle marks one disc diameter from the fovea';
ED.trans['PostSubcapCataract'] = 'Drag handle to change size';
ED.trans['PreRetinalHaemorrhage'] = 'Drag to position<br/>Drag handles to change shape and size';
ED.trans['PRPPostPole'] = '';
ED.trans['PTK'] = 'Drag handle to change size';
ED.trans['RadialSponge'] = 'Drag to change position';
ED.trans['RetinalArteryOcclusionPostPole'] = 'Drag to position<br/>Drag handles to change extent<br/>Drag central handle to alter macular involvement';
ED.trans['RetinalTouch'] = 'Drag to change position';
ED.trans['RetinalVeinOcclusionPostPole'] = 'Drag to position<br/>Drag handles to change extent<br/>Drag central handle to alter macular involvement';
ED.trans['RK'] = 'Drag to rotate<br/>Drag outer handle to resize<br/>Drag inner handle to adjust central extent';
ED.trans['RoundHole'] = '';
ED.trans['RPEAtrophy'] = 'Drag to position<br/>Drag the handle to change size';
ED.trans['RPEDetachment'] = 'Drag to position<br/>Drag handles to change shape<br/>Drag to position<br/>Drag outer ring of top handles to rotate';
ED.trans['RetinalHaemorrhage'] = 'Drag to position<br/>Drag the handle to change size';
ED.trans['RPEHypertrophy'] = 'Drag to position<br/>Drag the handle to change size';
ED.trans['RPERip'] = 'Drag to move<br/>Drag large handle to resize and rotate<br/>Drag other handles to adjust shape';
ED.trans['RRD'] = 'Drag to move around eye<br/>Drag outer handles to change size</br>Drag middle handle to change posterior extent';
ED.trans['Rubeosis'] = 'Drag to rotate around centre<br/>Drag handles to increase extent';
ED.trans['SectorPRP'] = 'Drag to rotate around centre<br/>Drag each end handle to increase extent';
ED.trans['SectorPRPPostPole'] = 'Drag to rotate around centre<br/>Drag each end handle to increase extent';
ED.trans['ScleralIncision'] = 'Drag to move around the sclera';
ED.trans['SectorIridectomy'] = 'Drag to position<br/>Drag handles to adjust extent';
ED.trans['Sclerostomy'] = 'Drag to rotate around centre<br/>Drag each handle to alter gauge<br/>Click suture button to toggle suture';
ED.trans['SidePort'] = 'Drag to move';
ED.trans['SMILE'] = 'Drag to handle to change size';
ED.trans['SubretinalFluid'] = 'Drag to position<br/>Drag handles to change shape<br/>Drag to position<br/>Drag outer ring of top handles to rotate';
ED.trans['SubretinalPFCL'] = 'Drag to position<br/>Drag handle to change size';
ED.trans['Supramid'] = 'Drag handle to move conjunctival end of suture';
ED.trans['Surgeon'] = '';
ED.trans['SwollenDisc'] = '';
ED.trans['Telangiectasis'] = 'Drag middle handle to add pigment and exudate';
ED.trans['ToricPCIOL'] = 'Drag to move<br/>Drag the handle to rotate';
ED.trans['Trabectome'] = 'Drag to position<br/>Drag either end handle to adjust extent';
ED.trans['TrabyConjIncision'] = 'Drag to position<br/>Drag end handle to adjust extent';
ED.trans['TrabyFlap'] = 'Drag to position<br/>Drag either end handle to adjust size</br>Drag middle handle to change sclerostomy';
ED.trans['TrabySuture'] = 'Drag to position<br/>Drag corner handle to adjust orientation</br>Drag lower handle to change suture type';
ED.trans['TractionRetinalDetachment'] = 'Drag to position<br/>Drag inner handle to change shape and size<br/>Drag outer handle to rotate';
ED.trans['TransilluminationDefect'] = 'Drag to rotate around centre<br/>Drag each end handle to alter extent';
ED.trans['Tube'] = 'Drag to change quadrant<br/>Drag handle to move end of tube';
ED.trans['TubeExtender'] = 'Drag to change quadrant<br/>Drag handle to move end of tube';
ED.trans['TubeLigation'] = 'Drag to change position';
ED.trans['UTear'] = '';
ED.trans['ViewObscured'] = 'Drag handle to change opacity';
ED.trans['VitreousOpacity'] = 'Drag to move<br/>Drag the inner handle up and down to alter opacity<br/>Drag the outer handle to scale';

// ENT
ED.trans['Grommet'] = 'Drag to position';
ED.trans['Perforation'] = 'Drag to move<br/>Drag handle to change size';

// Cardiology
ED.trans['Crepitations'] = 'Drag to move<br/>Drag handle to resize';
ED.trans['Stenosis'] = 'Drag to move<br/>Drag handle up and down to change degree<br/>Drag handle to left and right to change type';
ED.trans['Wheeze'] = 'Drag to move';
ED.trans['Effusion'] = 'Drag handle to move up';
ED.trans['LeftCoronaryArtery'] = 'Drag handle to move origin and make anomolous';
ED.trans['DrugStent'] = 'Drag to move';
ED.trans['MetalStent'] = 'Drag to move';
ED.trans['Bypass'] = 'Drag handle to alter destination';
ED.trans['Bruit'] = 'Drag to move';
ED.trans['Bruising'] = 'Drag to move<br/>Drag handle to resize';
ED.trans['Haematoma'] = 'Drag to move<br/>Drag handle to resize';

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Agent Duration
 *
 * @class AgentDose
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AgentDose = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AgentDose";

	// Derived parameters
	//this.value = '0';

	// Private parameters
	this.halfWidth = 50;
	this.halfHeight = 20;
	this.minimumWidth = 40;

	this.valueString = "200mg";

	// Saved parameters
	//this.savedParameterArray = ['originX', 'originY', 'value'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.AgentDose.prototype = new ED.Doodle;
ED.AgentDose.prototype.constructor = ED.AgentDose;
ED.AgentDose.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AgentDose.prototype.setHandles = function() {
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.AgentDose.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;

	// Add complete validation arrays for derived parameters
// 	this.parameterValidationArray['value'] = {
// 		kind: 'derived',
// 		type: 'int',
// 		range: new ED.Range(0, 240),
// 		animate: false
// 	};
	// Update component of validation array for simple parameters
	//this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 6, Math.PI * 2);
	this.parameterValidationArray['originX']['range'].setMinAndMax(-1000 + this.halfWidth, +900);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-this.halfWidth + this.minimumWidth, +1500);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-0, +0);
}

/**
 * Sets default parameters (only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.AgentDose.prototype.setParameterDefaults = function() {
	this.apexX = 100;
//
// 	var lastAgentDose = this.drawing.lastDoodleOfClass('AgentDose');
// 	if (lastAgentDose) {
// 		this.setParameterFromString('value', lastAgentDose.value.toString());
// 	}
// 	else {
// 		this.setParameterFromString('value', '80');
// 	}

	// Get x separation of drawing
// 	var recordGrid = this.drawing.lastDoodleOfClass('RecordGrid');
// 	if (recordGrid) {
// 		var xd = this.drawing.doodlePlaneWidth/recordGrid.numberCellsHorizontal;
// 		this.originX = recordGrid.firstCoordinate + recordGrid.index * xd;
// 		this.parameterValidationArray['originX']['range'].setMinAndMax(this.originX, this.originX);
// 	}
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
// ED.AgentDose.prototype.dependentParameterValues = function(_parameter, _value) {
// 	var returnArray = new Array();
//
// 	switch (_parameter) {
// 		case 'originY':
// 			returnArray['value'] = Math.round(240 * (this.drawing.doodlePlaneHeight/2 - _value)/this.drawing.doodlePlaneHeight);
// 			break;
//
// 		case 'value':
// 			returnArray['originY'] = - (_value * this.drawing.doodlePlaneHeight/240) + this.drawing.doodlePlaneHeight/2;
// 			break;
// 	}
//
// 	return returnArray;
// }

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AgentDose.prototype.draw = function(_point) { //console.log(this.originX);
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AgentDose.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Boundary
	var d = 5;
	var f = 1.5;
	this.halfWidth = ctx.measureText(this.valueString).width * f;

	ctx.moveTo(-this.halfWidth, -this.halfHeight + d);
	ctx.lineTo(-d, -this.halfHeight + d);
	ctx.lineTo(0, -this.halfHeight);
	ctx.lineTo(d, -this.halfHeight + d);
	ctx.lineTo(this.halfWidth, -this.halfHeight + d);
	ctx.lineTo(this.halfWidth, this.halfHeight - d);
	ctx.lineTo(d, this.halfHeight - d);
	ctx.lineTo(0, this.halfHeight);
	ctx.lineTo(-d, this.halfHeight - d);
	ctx.lineTo(-this.halfWidth, this.halfHeight - d);

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "rgba(50,50,50,1)";
	ctx.fillStyle =  "white";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Text properties
		ctx.font = "24px sans-serif";
		ctx.strokeStyle = "gray";
		ctx.fillStyle = "gray";

		// Draw text centred on grid line
		var textWidth = ctx.measureText(this.valueString).width;
		ctx.fillText(this.valueString, - textWidth/2, 8);
	}

	// Coordinates of handles (in canvas plane)
	//this.handleArray[3].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	//if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Draws extra items if the doodle is highlighted
 */
// ED.AgentDose.prototype.drawHighlightExtras = function() {
// 	// Get context
// 	var ctx = this.drawing.context;
//
// 	// Draw text description of gauge
// 	ctx.lineWidth = 1;
// 	ctx.font = "64px sans-serif";
// 	ctx.strokeStyle = "blue";
// 	ctx.fillStyle = "blue";
// 	ctx.fillText(this.value, +40, +20);
// }


/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Agent Duration
 *
 * @class AgentDuration
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AgentDuration = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AgentDuration";

	// Derived parameters
	this.unit = 'mg';
	this.type = 'range';

	// Private parameters
	this.halfHeight = 20;
	this.minimumWidth = 40;
	this.dose = '';

	// Saved parameters
	this.savedParameterArray = ['originX', 'apexX', 'unit', 'type', 'dose'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.AgentDuration.prototype = new ED.Doodle;
ED.AgentDuration.prototype.constructor = ED.AgentDuration;
ED.AgentDuration.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AgentDuration.prototype.setHandles = function() {
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.AgentDuration.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['unit'] = {
		kind: 'derived',
		type: 'string',
		list: ['mg', 'mls', 'ug', 'mg/kg/hr', 'ug/kg/hr', 'drops', 'IU'],
		animate: true
	};
	this.parameterValidationArray['type'] = {
		kind: 'derived',
		type: 'string',
		list: ['range', 'fixed'],
		animate: true
	};

	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-500, +900);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(this.minimumWidth, +1500);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-0, +0);
}

/**
 * Sets default parameters (only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.AgentDuration.prototype.setParameterDefaults = function() {
	this.apexX = this.minimumWidth;
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.AgentDuration.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'type':
			if (_value == 'range') this.apexX = 200;
			else this.apexX = 40;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AgentDuration.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AgentDuration.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Boundary
	var offset = this.minimumWidth/2;
	if (this.type == 'range') offset = 0;
	ctx.rect(0 - offset, -this.halfHeight, this.apexX, this.halfHeight * 2);

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 1;
	ctx.strokeStyle = "rgba(125,125,125,0)";
	ctx.fillStyle =  "rgba(125,125,125,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		if (this.type == 'range') {
			// Draw line with end bars
			ctx.moveTo(0 - offset, -this.halfHeight);
			ctx.lineTo(0 - offset, this.halfHeight);
			ctx.moveTo(0 - offset, 0);
			ctx.lineTo(this.apexX - offset, 0);
			ctx.moveTo(this.apexX - offset, -this.halfHeight);
			ctx.lineTo(this.apexX - offset, this.halfHeight);
		}
		else {
			// Draw diamond
			ctx.moveTo(-offset, 0);
			ctx.lineTo(0, this.halfHeight);
			ctx.lineTo(offset, 0);
			ctx.lineTo(0, -this.halfHeight);
			ctx.closePath();
		}

		// Set attributes
		ctx.lineWidth = 4;
		ctx.strokeStyle = "rgba(50,50,50,1)";

		// Draw
		ctx.stroke();

		// Draw dose
		ctx.lineWidth = 1;
		ctx.font = "24px sans-serif";
		ctx.strokeStyle = "blue";
		ctx.fillStyle = "blue";
		var text = String(this.dose);
		if (text.length > 0) text = text + ' ' + this.unit;
		var textWidth = ctx.measureText(text).width;
		var padding = 10;
		ctx.fillText(text, offset + padding, -8);
	}

	// Only draw handle for range, not fixed
	if (this.type == 'range') {
		// Coordinates of handles (in canvas plane)
		this.handleArray[3].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

		// Draw handles if selected
		if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Draws extra items if the doodle is highlighted
 */
ED.AgentDuration.prototype.drawHighlightExtras = function() {
	// Get context
	var ctx = this.drawing.context;

	// Repeat Boundary
	ctx.beginPath();
	var offset = this.minimumWidth/2;
	if (this.type == 'range') offset = 0;

	var margin = 3;
	ctx.rect(0 - offset - margin, -this.halfHeight - margin, this.apexX + margin * 2, this.halfHeight * 2 + margin * 2);

	// Set attributes
	ctx.lineWidth = 3;
	ctx.strokeStyle = "yellow";

	// Draw
	ctx.stroke();
}


/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * RecordGrid
 *
 * @class RecordGrid
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RecordGrid = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RecordGrid";

	// Private parameters
	this.values = {'sys':160, 'dia':80, 'pul':60, 'res':30, 'oxi':100};		// Default values
	this.minutesPerCell = 5;					// 'Width' of each cell in minutes (default: 5 - try 1 for demo)
	this.minutesLabelArray = [0, 30];			// Labels for these minutes past the hour
	this.totalMinutes = 180;						// Total duration of record (default: 180 - try 30 for demo)
	this.numberCellsHorizontal = Math.round(this.totalMinutes/this.minutesPerCell) + 2;
	this.numberCellsVertical = 12;
	this.separationOfVerticalGridLines = _drawing.doodlePlaneWidth/this.numberCellsHorizontal;	
	this.index = 0;								// Index property is the number of the vertical line where a reading is entered
	this.firstCoordinate = - _drawing.doodlePlaneWidth/2;
	
	this.startDate = new Date();				// Starting date 2013,2,1,10,35
	this.gridStartDate = new Date();			// Starting date rounded to nearest minutesPerCell
	this.nowDate = new Date();					// The current date set by a timer
	this.setGridStartDate(this.startDate);		// Date of left hand edge of grid
	
	// Saved parameters
	this.savedParameterArray = ['startDate'];
	
	// Date objects need to be flagged to save and load properly
	this.parameterObjectTypeArray = {startDate:'date', gridStartDate:'date'};
	
	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RecordGrid.prototype = new ED.Doodle;
ED.RecordGrid.prototype.constructor = ED.RecordGrid;
ED.RecordGrid.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.RecordGrid.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isShowHighlight = false;
	this.isSelectable = false;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RecordGrid.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RecordGrid.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();
	var xs = -this.drawing.doodlePlaneWidth/2;
	var ys = -this.drawing.doodlePlaneHeight/2;
	var xd = this.drawing.doodlePlaneWidth/this.numberCellsHorizontal;
	var yd = this.drawing.doodlePlaneHeight/this.numberCellsVertical;
	ctx.rect(xs, ys, this.drawing.doodlePlaneWidth, this.drawing.doodlePlaneHeight);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "gray";
	ctx.fillStyle = "rgba(255,255,255,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		// Horizontal grid lines
		for (var j = 0; j < this.numberCellsVertical; j++) {
			ctx.moveTo(xs, ys + j * yd);
			ctx.lineTo(xs + this.drawing.doodlePlaneWidth, ys + j * yd);
		}

		// Vertical grid lines
		for (var i = 0; i < this.numberCellsHorizontal; i++) {
			ctx.moveTo(xs + i * xd, ys);
			ctx.lineTo(xs + i * xd, ys + this.drawing.doodlePlaneHeight);
		}
		
		// Set line attributes
		ctx.lineWidth = 4;
		ctx.strokeStyle = "rgba(200,200,200,1)";

		// Draw grid lines
		ctx.stroke();
		
		// Draw timeLine in red
		var ms = this.nowDate - this.gridStartDate;
		this.timeLineX = this.firstCoordinate + (this.drawing.doodlePlaneWidth/this.numberCellsHorizontal) * ms/(60 * 1000 * this.minutesPerCell);
		ctx.beginPath();
		ctx.moveTo(this.timeLineX, ys);
		ctx.lineTo(this.timeLineX,  ys + this.drawing.doodlePlaneHeight);
		ctx.lineWidth = 4;
		ctx.strokeStyle = "red";
		ctx.stroke();

		// Draw time values at top, but leave out edges
		for (var i = 1; i < this.numberCellsHorizontal; i++) {
			// Calculate date of line
			dateOfGridLine = new Date(this.gridStartDate.getTime() + i * this.minutesPerCell * 60000);
			var hour = dateOfGridLine.getHours();
			var minutes = dateOfGridLine.getMinutes();

			// Only put in markers for major timepoints		
			if (this.minutesLabelArray.indexOf(minutes) >= 0) {
				// Text of time display
				var hourText = hour.toString();
				if (hourText.length < 2) hourText = '0' + hourText;
				var minutesText = minutes.toString();
				if (minutesText.length < 2) minutesText = '0' + minutesText;
				var text = hourText + ':' + minutesText;
				
				// Text properties
				ctx.lineWidth = 1;
				ctx.font = "48px sans-serif";
				ctx.strokeStyle = "gray";
				ctx.fillStyle = "gray";
			
				// Draw text centred on grid line
				var textWidth = ctx.measureText(text).width;
				ctx.fillText(text, xs + i * xd - textWidth/2, ys + 50);
			}
		}
	}

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns an array of the values of the last entry if present
 *
 * @param {String} _type Type of readings
 * @return {Mixed} The last value if present, otherwise false
 */
ED.RecordGrid.prototype.getNextValues = function(_type) {
	// Get array of all the BPReading doodles (of both 'sys' and 'dia' stolic types
	var readingArray = this.drawing.allDoodlesOfClass('RecordReading');
	
	// Set default to beyond left border
	var lastX = -2000;
	
	// Set values to that of last entry
	for (var i = 0; i < readingArray.length; i++) {
		if (readingArray[i].type == _type) {
			this.values[_type] = readingArray[i].value;
			lastX = readingArray[i].originX;
			break;
		}
	}
	
	// Get current x coordinate for the time point
	var x = this.getGridX();
	
	// If its different from the last entry, then return the next values
	if (x > lastX) {
		return {'value':this.values[_type], 'originX':x};
	}
	else {
		return false;
	}
}

/**
 * Sets date properties so that a time may be displayed clearly
 *
 * @param {Date} _date Date object representing the date of the record grid start
 */
ED.RecordGrid.prototype.setGridStartDate = function(_date) {
	// Determine time coordinate of start of grid
	var nearestGridLine = Math.round(_date.getMinutes()/this.minutesPerCell) * this.minutesPerCell;
	var nearestGridLineBefore = Math.floor(_date.getMinutes()/this.minutesPerCell) * this.minutesPerCell;
	
	// Set grid start date to allow first reading to be on first line to right of left hand edge
	this.gridStartDate = _date;
	this.gridStartDate.setMinutes(nearestGridLineBefore);
	
	// Shave off one grid width if label is on left hand edge
	if (nearestGridLine == nearestGridLineBefore) {
		this.gridStartDate = new Date(this.gridStartDate.getTime() - this.minutesPerCell * 60000);
	}
		
	// Zero seconds
	this.gridStartDate.setSeconds(0);
}

/**
 * Gets X coordinate of nearest vertical grid line to current time
 */
ED.RecordGrid.prototype.getGridX = function() {
	// Get time diff in milliseconds from start of grid until now
	var ms = this.nowDate - this.gridStartDate;
	
	// Set index
	this.index = Math.round(ms/(60 * 1000 * this.minutesPerCell));
	
	// Return integer pixel value to allow reliable test of whether reading is already there
	return Math.round(this.firstCoordinate + this.index * this.separationOfVerticalGridLines);
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Blood pressure reading
 *
 * @class RecordReading
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RecordReading = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RecordReading";

	// Private parameters
	this.type = 'sys';			// Can be either 'sys', 'dia', 'pul', 'res', 'oxi'

	// Derived parameters
	this.value = '0';			// Numerical value of reading

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'value', 'type'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RecordReading.prototype = new ED.Doodle;
ED.RecordReading.prototype.constructor = ED.RecordReading;
ED.RecordReading.superclass = ED.Doodle.prototype;

/**
 * Sets default properties
 */
ED.RecordReading.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['value'] = {
		kind: 'derived',
		type: 'int',
		range: new ED.Range(0, 240),
		animate: false
	};
	this.parameterValidationArray['type'] = {
		kind: 'derived',
		type: 'string',
		list: ['sys', 'dia', 'pul', 'res', 'oxi'],
		animate: false
	};
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.RecordReading.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'originY':
			returnArray['value'] = Math.round(240 * (this.drawing.doodlePlaneHeight/2 - _value)/this.drawing.doodlePlaneHeight);
			break;

		case 'value':
			returnArray['originY'] = - (_value * this.drawing.doodlePlaneHeight/240) + this.drawing.doodlePlaneHeight/2;
			break;

		case 'originX':
			// When originX is set, ensure user cannot move doodle to left and right
			this.parameterValidationArray['originX']['range'].setMinAndMax(this.originX, this.originX);
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RecordReading.prototype.draw = function(_point) { //console.log(this.originX);
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RecordReading.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Width and half height
	var w = 56;
	var h = 30;

	switch (this.type) {
		case 'sys':
			ctx.rect(-w/2, -h, w, h);
			break;
		case 'dia':
			ctx.rect(-w/2, 0, w, h);
			break;
		case 'pul':
			ctx.arc(0, 0, h, 0, Math.PI * 2, true);
			break;
		case 'res':
			ctx.arc(0, 0, h, 0, Math.PI * 2, true);
			break;
		case 'oxi':
			ctx.rect(-w/2, -h/2, w, h);
			break;
	}

	// Close path
	ctx.closePath();

	// Transparent stroke and fill
	ctx.strokeStyle = "rgba(255,255,255,0)";
	ctx.fillStyle = "rgba(255,255,255,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		switch (this.type) {
			case 'sys':
				ctx.moveTo(-w/2, -h);
				ctx.lineTo(0, 0);
				ctx.lineTo(w/2, -h);
				break;
			case 'dia':
				ctx.moveTo(-w/2, h);
				ctx.lineTo(0, 0);
				ctx.lineTo(w/2, h);
				break;
			case 'pul':
				ctx.arc(0, 0, 20, 0, Math.PI * 2, true);
				break;
			case 'res':
				ctx.arc(0, 0, 20, 0, Math.PI * 2, true);
				break;
			case 'oxi':
				ctx.rect(-w/2, -h/2, w, h);
				break;
		}

		// Set line attributes
		ctx.lineWidth = 8;
		ctx.lineJoin = 'round';
		ctx.lineCap = 'round';
		ctx.strokeStyle = "gray";
		ctx.fillStyle= ctx.strokeStyle;

		// Draw symbol
		ctx.stroke();
		if (this.type == 'pul') ctx.fill();
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Draws extra items if the doodle is highlighted
 */
ED.RecordReading.prototype.drawHighlightExtras = function() {
	// Get context
	var ctx = this.drawing.context;

	// Draw value
	ctx.lineWidth = 1;
	ctx.font = "64px sans-serif";
	ctx.strokeStyle = "blue";
	ctx.fillStyle = "blue";
	ctx.fillText(this.value, +40, +20);
}


/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 *
 * @author <a href="mailto:bill.aylward@mac.com">Bill Aylward</a>
 * @version 0.8
 *
 * Modification date: 28th Ootober 2011
 * Copyright 2011 OpenEyes
 *
 * This file is part of OpenEyes.
 *
 * OpenEyes is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenEyes is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenEyes.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @namespace
 * @borrows ED as ED
 */
if (ED == null || typeof(ED) != "object") {
	var ED = new Object();
}

/**
 * Heart
 *
 * @class Heart
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Heart = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Heart";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Heart.prototype = new ED.Doodle;
ED.Heart.prototype.constructor = ED.Heart;
ED.Heart.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Heart.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.Heart.prototype.setPropertyDefaults = function() {
	//this.isDeletable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-460, -420);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-460, -400);
}

/**
 * Sets default parameters
 */
ED.Heart.prototype.setParameterDefaults = function() {
	this.apexX = -460;
	this.apexY = -460;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Heart.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Heart.superclass.draw.call(this, _point);

	// Calculate parameters for arcs
	var arcStart = 0;
	var arcEnd = 2 * Math.PI;

	// Boundary path
	ctx.beginPath();

	// Do a 360 arc
	ctx.arc(0, 0, 400, arcStart, arcEnd, true);

	// Set line attributes
	ctx.lineWidth = 15;
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "rgba(200, 200, 200, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		ctx.moveTo(-287, -51);

		ctx.bezierCurveTo(-344, 53, -346, 243, -116, 209);
		ctx.bezierCurveTo(5, 297, 269, 341, 312, 268);
		ctx.bezierCurveTo(387, 141, 319, -17, 237, -59);
		ctx.bezierCurveTo(225, -133, 141, -209, 65, -215);
		ctx.bezierCurveTo(55, -209, 43, -219, 53, -193);
		ctx.bezierCurveTo(133, -185, 201, -129, 216, -46);
		ctx.bezierCurveTo(205, -23, 167, 11, 187, 25);
		ctx.bezierCurveTo(202, 36, 192, -37, 235, -3);
		ctx.bezierCurveTo(291, 41, 333, 227, 295, 207);
		ctx.bezierCurveTo(195, 155, 153, 111, 97, 43);
		ctx.bezierCurveTo(74, 15, 177, 62, 181, 43);
		ctx.bezierCurveTo(187, 17, 109, 25, 55, 19);
		ctx.bezierCurveTo(31, -7, -172, -89, -173, -87);
		ctx.bezierCurveTo(-173, -84, -232, -117, -191, -73);
		ctx.bezierCurveTo(-115, -49, -61, -13, -37, -3);
		ctx.bezierCurveTo(-67, 45, -14, 171, 3, 165);
		ctx.bezierCurveTo(21, 159, -53, 45, 15, 23);
		ctx.bezierCurveTo(103, 87, 199, 183, 231, 249);
		ctx.bezierCurveTo(199, 297, -31, 243, -81, 199);
		ctx.bezierCurveTo(-53, 175, -8, 204, -13, 187);
		ctx.bezierCurveTo(-17, 171, -66, 181, -105, 185);
		ctx.bezierCurveTo(-331, 209, -289, 33, -273, -37);
		ctx.bezierCurveTo(-270, -47, -287, -51, -287, -51);


		ctx.closePath();

		ctx.lineWidth = 4;
		ctx.fillStyle = "rgba(255, 255, 255, 0)";
		ctx.strokeStyle = "rgba(200, 200, 200, 1)";
		ctx.stroke();

	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle (overridden by subclasses)
 *
 * @returns {String} Description of doodle
 */
ED.Heart.prototype.description = function() {
	return "Heart";
}

/**
 * Aorta
 *
 * @class Aorta
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Aorta = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Aorta";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Aorta.prototype = new ED.Doodle;
ED.Aorta.prototype.constructor = ED.Aorta;
ED.Aorta.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Aorta.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.Aorta.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
	this.isDeletable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-460, -420);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-460, -400);
}

/**
 * Sets default parameters
 */
ED.Aorta.prototype.setParameterDefaults = function() {
	this.scaleX = 0.5;
	this.scaleY = 0.5;
	this.originX = -352;
	this.originY = -416;
	this.apexX = -460;
	this.apexY = -460;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Aorta.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Aorta.superclass.draw.call(this, _point);

	// Calculate parameters for arcs
	var arcStart = 0;
	var arcEnd = 2 * Math.PI;

	// Boundary path
	ctx.beginPath();

	// Do a 360 arc
	ctx.arc(0, 0, 400, arcStart, arcEnd, true);

	// Set line attributes
	ctx.lineWidth = 15;
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "rgba(200, 200, 200, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		ctx.moveTo(216, -112);
		ctx.bezierCurveTo(216, -112, 181, 46, 210, 40);
		ctx.bezierCurveTo(239, 33, 282, -111, 282, -111);

		ctx.moveTo(423, 335);
		ctx.bezierCurveTo(423, 335, 453, 57, 313, 31);
		ctx.bezierCurveTo(281, 26, 330, -100, 330, -100);

		ctx.moveTo(-1, -25);
		ctx.bezierCurveTo(-1, -25, 57, 2, 74, 41);
		ctx.bezierCurveTo(82, 61, 93, 79, 116, 78);
		ctx.bezierCurveTo(144, 78, 141, 42, 141, 7);
		ctx.bezierCurveTo(141, -50, 159, -97, 159, -97);

		ctx.moveTo(198, 582);
		ctx.bezierCurveTo(214, 619, 155, 663, 105, 649);

		ctx.moveTo(-39, 12);
		ctx.bezierCurveTo(-39, 12, 52, 54, 28, 133);
		ctx.bezierCurveTo(28, 133, -2, 180, -16, 200);
		ctx.bezierCurveTo(-49, 246, -125, 446, -28, 595);
		ctx.lineTo(-1, 640);
		ctx.bezierCurveTo(67, 725, 152, 624, 119, 566);
		ctx.bezierCurveTo(151, 598, 255, 603, 251, 514);
		ctx.bezierCurveTo(250, 473, 182, 418, 182, 418);
		ctx.bezierCurveTo(118, 352, 162, 209, 254, 211);
		ctx.bezierCurveTo(314, 212, 287, 365, 287, 365);

		//ctx.closePath();

		ctx.lineWidth = 12;
		ctx.fillStyle = "rgba(255, 255, 255, 0)";
		ctx.strokeStyle = "rgba(100, 100, 100, 1)";
		ctx.stroke();

	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle (overridden by subclasses)
 *
 * @returns {String} Description of doodle
 */
ED.Aorta.prototype.description = function() {
	return "";
}

/**
 * RightCoronaryArtery
 *
 * @class RightCoronaryArtery
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RightCoronaryArtery = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RightCoronaryArtery";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RightCoronaryArtery.prototype = new ED.Doodle;
ED.RightCoronaryArtery.prototype.constructor = ED.RightCoronaryArtery;
ED.RightCoronaryArtery.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.RightCoronaryArtery.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.RightCoronaryArtery.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
	this.isDeletable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-460, -420);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-460, -400);
}

/**
 * Sets default parameters
 */
ED.RightCoronaryArtery.prototype.setParameterDefaults = function() {
	this.originX = 24;
	this.originY = 2;
	this.scaleX = 1.5;
	this.scaleY = 1.5;
	this.apexX = -460;
	this.apexY = -460;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RightCoronaryArtery.prototype.draw = function(_point) {
	//console.log(this.originX, this.originY);
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RightCoronaryArtery.superclass.draw.call(this, _point);

	// Calculate parameters for arcs
	var arcStart = 0;
	var arcEnd = 2 * Math.PI;

	// Boundary path
	ctx.beginPath();

	// Do a 360 arc
	ctx.arc(0, 0, 400, arcStart, arcEnd, true);

	// Set line attributes
	ctx.lineWidth = 1;
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "rgba(200, 200, 200, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		ctx.moveTo(-254, -66);
		ctx.bezierCurveTo(-379, 8, -313, 171, -289, 204);
		ctx.bezierCurveTo(-245, 265, -184, 266, -151, 252);
		ctx.bezierCurveTo(-144, 261, -94, 311, -94, 311);

		ctx.moveTo(-244, -58);
		ctx.bezierCurveTo(-364, -23, -327, 263, -173, 247);
		ctx.bezierCurveTo(-138, 243, -88, 191, -36, 242);
		ctx.bezierCurveTo(-15, 261, -9, 276, -9, 276);

		ctx.moveTo(-54, 292);
		ctx.bezierCurveTo(-54, 292, -103, 238, -110, 234);
		ctx.bezierCurveTo(-125, 237, -142, 247, -142, 247);

		ctx.moveTo(-82, 306);
		ctx.lineTo(-142, 247);

		ctx.moveTo(-42, 286);
		ctx.lineTo(-96, 232);
		ctx.bezierCurveTo(-84, 218, -36, 250, -24, 276);

		ctx.lineWidth = 4;
		ctx.fillStyle = "rgba(255, 255, 255, 0)";
		ctx.strokeStyle = "rgba(100, 100, 100, 1)";
		ctx.stroke();

	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle (overridden by subclasses)
 *
 * @returns {String} Description of doodle
 */
ED.RightCoronaryArtery.prototype.description = function() {
	return "";
}

/**
 * LeftCoronaryArtery
 *
 * @class LeftCoronaryArtery
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.LeftCoronaryArtery = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "LeftCoronaryArtery";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.LeftCoronaryArtery.prototype = new ED.Doodle;
ED.LeftCoronaryArtery.prototype.constructor = ED.LeftCoronaryArtery;
ED.LeftCoronaryArtery.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.LeftCoronaryArtery.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.LeftCoronaryArtery.prototype.setPropertyDefaults = function() {
	//this.isSelectable= false;
	this.isDeletable = false;

	// Update component of validation array for simple parameters
	//    this.parameterValidationArray['apexX']['range'].setMinAndMax(-460, -420);
	//    this.parameterValidationArray['apexY']['range'].setMinAndMax(-460, -400);
}

/**
 * Sets default parameters
 */
ED.LeftCoronaryArtery.prototype.setParameterDefaults = function() {

	this.originY = 0;
	this.scaleX = 1.5;
	this.scaleY = 1.5;
	this.apexX = -153;
	this.apexY = -84;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.LeftCoronaryArtery.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.LeftCoronaryArtery.superclass.draw.call(this, _point);

	// Calculate parameters for arcs
	var arcStart = 0;
	var arcEnd = 2 * Math.PI;

	// Boundary path
	ctx.beginPath();

	// Do a 360 arc
	ctx.arc(-100, -50, 100, arcStart, arcEnd, true);

	// Set line attributes
	ctx.lineWidth = 1;
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "rgba(200, 200, 200, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		// Start segment
		//ctx.moveTo(-210, -94);
		ctx.moveTo(this.apexX, this.apexY);
		//ctx.bezierCurveTo(-277, -82, -206, -47, -186, -48);
		ctx.bezierCurveTo(-165, -48, -94, -52, -37, -58);
		ctx.bezierCurveTo(20, -63, 40, -34, 102, -34);
		ctx.bezierCurveTo(119, -34, 135, -36, 135, -36);

		ctx.moveTo(68, 136);
		ctx.bezierCurveTo(50, 130, 23, 124, 14, 110);
		ctx.bezierCurveTo(2, 92, -2, 66, -7, 39);
		ctx.bezierCurveTo(-11, 23, -24, -5, -35, -26);
		ctx.bezierCurveTo(-50, -55, 41, -34, 42, -8);
		ctx.bezierCurveTo(45, 25, 39, 41, 39, 41);

		ctx.moveTo(200, 257);
		ctx.bezierCurveTo(223, 258, 289, 267, 311, 253);
		ctx.bezierCurveTo(331, 240, 314, 208, 304, 193);
		ctx.bezierCurveTo(282, 155, 246, 114, 224, 90);

		ctx.moveTo(67, 143);
		ctx.bezierCurveTo(67, 143, 42, 138, 16, 129);
		ctx.bezierCurveTo(21, 144, 26, 171, 40, 185);
		ctx.bezierCurveTo(63, 208, 102, 210, 102, 210);

		ctx.moveTo(103, 218);
		ctx.bezierCurveTo(103, 218, 55, 208, 39, 202);
		ctx.bezierCurveTo(49, 273, 165, 280, 165, 280);

		ctx.moveTo(195, 136);
		ctx.bezierCurveTo(195, 136, 197, 101, 196, 86);
		ctx.bezierCurveTo(214, 97, 232, 110, 243, 130);
		ctx.bezierCurveTo(249, 142, 247, 180, 247, 180);

		ctx.moveTo(164, 284);
		ctx.bezierCurveTo(164, 284, 101, 286, 55, 253);
		ctx.bezierCurveTo(35, 238, 24, 200, 16, 175);

		ctx.lineTo(-6, 94);
		ctx.moveTo(221, 80);

		ctx.moveTo(135, -33);
		ctx.bezierCurveTo(135, -33, 104, -23, 71, -28);
		ctx.bezierCurveTo(110, -7, 147, 18, 182, 48);
		ctx.bezierCurveTo(193, 57, 205, 73, 215, 77);
		ctx.bezierCurveTo(226, 81, 241, 81, 253, 83);
		//
		ctx.moveTo(190, 133);
		ctx.bezierCurveTo(190, 133, 191, 87, 178, 68);
		ctx.bezierCurveTo(165, 49, 96, 11, 96, 11);

		// Repairs
		ctx.moveTo(-4, 98);
		ctx.bezierCurveTo(-10, 136, -10, 136, -22, 156);

		ctx.moveTo(58, -10);
		ctx.bezierCurveTo(62, 18, 62, 18, 54, 42);

		ctx.moveTo(102, 10);
		ctx.bezierCurveTo(106, 38, 106, 38, 102, 56);

		ctx.moveTo(222, 90);
		ctx.bezierCurveTo(242, 92, 242, 92, 258, 94);

		ctx.moveTo(258, 142);
		ctx.bezierCurveTo(340, 264, 316, 250, 204, 244);

		ctx.moveTo(258, 142);
		ctx.bezierCurveTo(264, 164, 264, 164, 260, 176);

		ctx.moveTo(54, -12);
		ctx.bezierCurveTo(54, -12, 77, -4, 84, 7);
		ctx.bezierCurveTo(94, 24, 89, 57, 89, 57);

		// End segment
		ctx.moveTo(-38, 158);
		ctx.bezierCurveTo(-38, 158, 17, 81, -58, -42);
		if (this.apexX > -200) ctx.bezierCurveTo(-152, -40, -146, -27, this.apexX - 20, this.apexY);
		else ctx.bezierCurveTo(-152, -40, -146, -27, this.apexX - 8, this.apexY + 15);

		ctx.lineWidth = 4;
		ctx.fillStyle = "rgba(255, 255, 255, 0)";
		ctx.strokeStyle = "rgba(100, 100, 100, 1)";
		ctx.stroke();

	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle (overridden by subclasses)
 *
 * @returns {String} Description of doodle
 */
ED.LeftCoronaryArtery.prototype.description = function() {
	if (this.apexX < -200) return "Anomalous insertion of left coronary artery";
	else return "";
}

/**
 * AnomalousVessels
 *
 * @class AnomalousVessels
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AnomalousVessels = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AnomalousVessels";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.AnomalousVessels.prototype = new ED.Doodle;
ED.AnomalousVessels.prototype.constructor = ED.AnomalousVessels;
ED.AnomalousVessels.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AnomalousVessels.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.AnomalousVessels.prototype.setPropertyDefaults = function() {
	//this.isSelectable= false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-460, -420);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-460, -400);
}

/**
 * Sets default parameters
 */
ED.AnomalousVessels.prototype.setParameterDefaults = function() {
	//    this.originX = -500;
	this.originY = -100;
	this.scaleX = 1.5;
	this.scaleY = 1.5;
	this.apexX = -460;
	this.apexY = -460;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AnomalousVessels.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AnomalousVessels.superclass.draw.call(this, _point);

	// Calculate parameters for arcs
	var arcStart = 0;
	var arcEnd = 2 * Math.PI;

	// Boundary path
	ctx.beginPath();

	// Do a 360 arc
	ctx.arc(0, 0, 400, arcStart, arcEnd, true);

	// Set line attributes
	ctx.lineWidth = 1;
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "rgba(200, 200, 200, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		ctx.moveTo(68, 136);
		ctx.bezierCurveTo(50, 130, 23, 124, 14, 110);
		ctx.bezierCurveTo(2, 92, -2, 66, -7, 39);
		ctx.bezierCurveTo(-11, 23, -24, -5, -35, -26);
		ctx.bezierCurveTo(-50, -55, 41, -34, 42, -8);
		ctx.bezierCurveTo(45, 25, 39, 41, 39, 41);



		ctx.moveTo(200, 257);
		ctx.bezierCurveTo(223, 258, 289, 267, 311, 253);
		ctx.bezierCurveTo(331, 240, 314, 208, 304, 193);
		ctx.bezierCurveTo(282, 155, 246, 114, 224, 90);

		ctx.lineTo(254, 89);
		ctx.moveTo(-6, 94);
		ctx.bezierCurveTo(-8, 113, -11, 132, -33, 164);

		ctx.moveTo(67, 143);
		ctx.bezierCurveTo(67, 143, 42, 138, 16, 129);
		ctx.bezierCurveTo(21, 144, 26, 171, 40, 185);
		ctx.bezierCurveTo(63, 208, 102, 210, 102, 210);

		ctx.moveTo(103, 218);
		ctx.bezierCurveTo(103, 218, 55, 208, 39, 202);
		ctx.bezierCurveTo(49, 273, 165, 280, 165, 280);

		ctx.moveTo(-54, 292);
		ctx.bezierCurveTo(-54, 292, -103, 238, -110, 234);
		ctx.bezierCurveTo(-125, 237, -142, 247, -142, 247);

		ctx.lineTo(-91, 307);

		ctx.moveTo(195, 136);
		ctx.bezierCurveTo(195, 136, 197, 101, 196, 86);
		ctx.bezierCurveTo(214, 97, 232, 110, 243, 130);
		ctx.bezierCurveTo(249, 142, 247, 180, 247, 180);

		ctx.moveTo(164, 284);
		ctx.bezierCurveTo(164, 284, 101, 286, 55, 253);
		ctx.bezierCurveTo(35, 238, 24, 200, 16, 175);

		ctx.lineTo(-6, 94);
		ctx.moveTo(221, 80);
		//ctx.lineTo(257, 151);

		ctx.moveTo(257, 151);
		ctx.bezierCurveTo(257, 151, 278, 176, 288, 190);
		ctx.bezierCurveTo(297, 204, 312, 227, 304, 240);
		ctx.bezierCurveTo(291, 264, 223, 250, 200, 250);

		ctx.moveTo(-14, 278);
		ctx.bezierCurveTo(-14, 278, -49, 217, -98, 230);

		//ctx.lineTo(-48, 290);

		ctx.moveTo(135, -33);
		ctx.bezierCurveTo(135, -33, 104, -23, 71, -28);
		ctx.bezierCurveTo(110, -7, 147, 18, 182, 48);
		ctx.bezierCurveTo(193, 57, 205, 73, 215, 77);
		ctx.bezierCurveTo(226, 81, 241, 81, 253, 83);
		//
		ctx.moveTo(190, 133);
		ctx.bezierCurveTo(190, 133, 191, 87, 178, 68);
		ctx.bezierCurveTo(165, 49, 96, 11, 96, 11);

		ctx.moveTo(54, -12);
		ctx.bezierCurveTo(54, -12, 77, -4, 84, 7);
		ctx.bezierCurveTo(94, 24, 89, 57, 89, 57);

		ctx.moveTo(-210, -104);
		ctx.bezierCurveTo(-253, -100, -259, -73, -254, -66);
		ctx.bezierCurveTo(-379, 8, -313, 171, -289, 204);
		ctx.bezierCurveTo(-245, 265, -184, 266, -151, 252);
		ctx.bezierCurveTo(-144, 261, -94, 311, -94, 311);

		ctx.moveTo(-38, 158);
		ctx.bezierCurveTo(-38, 158, 17, 81, -58, -42);
		ctx.bezierCurveTo(-152, -40, -206, -27, -238, -56);

		ctx.moveTo(-244, -58);
		ctx.bezierCurveTo(-364, -23, -327, 263, -173, 247);
		ctx.bezierCurveTo(-138, 243, -88, 191, -36, 242);
		ctx.bezierCurveTo(-15, 261, -9, 276, -9, 276);

		ctx.moveTo(-210, -94);
		ctx.bezierCurveTo(-277, -82, -206, -47, -186, -48);
		ctx.bezierCurveTo(-165, -48, -94, -52, -37, -58);
		ctx.bezierCurveTo(20, -63, 40, -34, 102, -34);
		ctx.bezierCurveTo(119, -34, 135, -36, 135, -36);

		//ctx.closePath();

		ctx.lineWidth = 4;
		ctx.fillStyle = "rgba(255, 255, 255, 0)";
		ctx.strokeStyle = "rgba(200, 200, 200, 1)";
		ctx.stroke();

	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle (overridden by subclasses)
 *
 * @returns {String} Description of doodle
 */
ED.AnomalousVessels.prototype.description = function() {
	return "AnomalousVessels";
}





/**
 * Bypass
 *
 * @class Bypass
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Bypass = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Bypass";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Bypass.prototype = new ED.Doodle;
ED.Bypass.prototype.constructor = ED.Bypass;
ED.Bypass.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Bypass.prototype.setHandles = function() {
	//	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.Bypass.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	// Update component of validation array for simple parameters
	//    this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	//    this.parameterValidationArray['apexY']['range'].setMinAndMax(-40, +30);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Bypass.prototype.setParameterDefaults = function() {
	var num = this.drawing.numberOfDoodlesOfClass(this.className);

	if (num == 0) {
		this.apexX = 40;
		this.apexY = -60;
	} else if (num == 1) {
		this.apexX = -11;
		this.apexY = 133;
	} else {
		this.apexX = -445;
		this.apexY = 205;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Bypass.prototype.draw = function(_point) {
	//console.log(this.apexX, this.apexY);
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Bypass.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Start point and end point
	var startPoint = new ED.Point(-320, -200);
	var endPoint = new ED.Point(this.apexX, this.apexY);

	var d = startPoint.distanceTo(endPoint);
	var r = 20;
	var phi = Math.PI / 8;

	// Start point
	ctx.moveTo(startPoint.x, startPoint.y);

	// Calculate angle to apex point
	var angleToApex = Math.atan((endPoint.y - startPoint.y) / (endPoint.x - startPoint.x));
	if (angleToApex < 0) angleToApex = Math.PI / 2 + (Math.PI / 2 + angleToApex);

	var firstPoint = new ED.Point(0, 0);
	firstPoint.setWithPolars(r, angleToApex);

	var firstControlPoint = new ED.Point(0, 0);
	firstControlPoint.setWithPolars(d / 2, angleToApex + Math.PI / 2 - phi);

	var secondPoint = new ED.Point(firstPoint.x + endPoint.x, firstPoint.y + endPoint.y);

	var fourthPoint = new ED.Point(0, 0);
	fourthPoint.setWithPolars(r, angleToApex + Math.PI);

	var thirdPoint = new ED.Point(fourthPoint.x + endPoint.x, fourthPoint.y + endPoint.y);


	ctx.lineTo(startPoint.x + firstPoint.x, startPoint.y + firstPoint.y);

	//ctx.lineTo(startPoint.x + firstPoint.x + firstControlPoint.x, startPoint.y + firstPoint.y + firstControlPoint.y);
	//ctx.lineTo(secondPoint.x, secondPoint.y);
	ctx.bezierCurveTo(startPoint.x + firstPoint.x + firstControlPoint.x, startPoint.y + firstPoint.y + firstControlPoint.y, startPoint.x + firstPoint.x + firstControlPoint.x, startPoint.y + firstPoint.y + firstControlPoint.y, secondPoint.x, secondPoint.y);



	//ctx.lineTo(x + (this.apexX - x)/2, y + (this.apexY - y)/2 - d);
	//ctx.lineTo(this.apexX, this.apexY);
	//ctx.bezierCurveTo(cpX, cpY, cpX, cpY, this.apexX, this.apexY - r);
	ctx.lineTo(endPoint.x, endPoint.y);
	ctx.lineTo(thirdPoint.x, thirdPoint.y);

	//ctx.lineTo(startPoint.x + fourthPoint.x + firstControlPoint.x, startPoint.y + fourthPoint.y + firstControlPoint.y);
	//ctx.lineTo(startPoint.x + fourthPoint.x, startPoint.y + fourthPoint.y);
	ctx.bezierCurveTo(startPoint.x + fourthPoint.x + firstControlPoint.x, startPoint.y + fourthPoint.y + firstControlPoint.y, startPoint.x + fourthPoint.x + firstControlPoint.x, startPoint.y + fourthPoint.y + firstControlPoint.y, startPoint.x + fourthPoint.x, startPoint.y + fourthPoint.y);

	ctx.closePath();


	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "rgba(200, 000, 000, 1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {}

	// Coordinates of handles (in canvas plane)
	//this.handleArray[3].location = this.transform.transformPoint(new ED.Point(40, -40));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Calculate arc (Arc property not used naturally in this doodle)
	this.leftExtremity = this.transform.transformPoint(new ED.Point(-40, -40));
	this.rightExtremity = this.transform.transformPoint(new ED.Point(40, -40));
	this.arc = this.calculateArc();

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Bypass.prototype.description = function() {
	var artery = "";

	// Size description
	if (this.apexX > 0) artery = "left coronary artery";
	else if (this.apexX > -300) artery = "circumflex artery";
	else artery = "right coronary artery";

	return "Bypass graft to " + artery;
}



/**
 * MetalStent
 *
 * @class MetalStent
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.MetalStent = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "MetalStent";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.MetalStent.prototype = new ED.Doodle;
ED.MetalStent.prototype.constructor = ED.MetalStent;
ED.MetalStent.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.MetalStent.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, true);
}

/**
 * Sets default dragging attributes
 */
ED.MetalStent.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-160, +0);
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 6, Math.PI * 2);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.5);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.MetalStent.prototype.setParameterDefaults = function() {
	this.originX = -18;
	this.originY = 86;
	this.rotation = -4.985446531081719;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.MetalStent.prototype.draw = function(_point) {
	console.log(this.originX, this.originY, this.rotation);
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.MetalStent.superclass.draw.call(this, _point);

	// Stent radius
	var r = 50;
	var w = 10;
	var d = 10

	// Boundary path
	ctx.beginPath();

	// Exudate
	ctx.rect(-r, -w, 2 * r, 2 * w);

	// Set attributes
	ctx.lineWidth = 4;
	//ctx.strokeStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "blue";
	ctx.fillStyle = "rgba(255, 255, 255, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		for (var i = 0; i < 10; i++) {
			ctx.moveTo(-r + i * d, -w);
			ctx.lineTo(-r + i * d, +w);
		}
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(-50, -10);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.MetalStent.prototype.description = function() {
	var artery;
	if (this.originX > 0) artery = "left coronary artery";
	else if (this.originX > -300) artery = "circumflex artery";
	else artery = "right coronary artery";

	return "Metal stent in " + artery;
}

/**
 * DrugStent
 *
 * @class DrugStent
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.DrugStent = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "DrugStent";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.DrugStent.prototype = new ED.Doodle;
ED.DrugStent.prototype.constructor = ED.DrugStent;
ED.DrugStent.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.DrugStent.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, true);
}

/**
 * Sets default dragging attributes
 */
ED.DrugStent.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-160, +0);
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 6, Math.PI * 2);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.5);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.DrugStent.prototype.setParameterDefaults = function() {
	this.originX = -18;
	this.originY = 86;
	this.rotation = -4.985446531081719;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.DrugStent.prototype.draw = function(_point) {
	console.log(this.originX, this.originY, this.rotation);
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.DrugStent.superclass.draw.call(this, _point);

	// Stent radius
	var r = 50;
	var w = 10;
	var d = 20;

	// Boundary path
	ctx.beginPath();

	// Exudate
	ctx.rect(-r, -w, 2 * r, 2 * w);

	// Set attributes
	ctx.lineWidth = 4;
	//ctx.strokeStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "blue";
	ctx.fillStyle = "rgba(255, 255, 255, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		for (var i = 0; i < 5; i++) {
			ctx.moveTo(-r + i * d, -w);
			ctx.lineTo(-r + (i + 1) * d, +w);
			ctx.moveTo(-r + (i + 1) * d, -w);
			ctx.lineTo(-r + i * d, +w);
		}
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(-50, -10);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.DrugStent.prototype.description = function() {
	var artery;
	if (this.originX > 0) artery = "left coronary artery";
	else if (this.originX > -300) artery = "circumflex artery";
	else artery = "right coronary artery";

	return "Metal stent in " + artery;
}

/**
 * Stenosis
 *
 * @class Stenosis
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Stenosis = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Stenosis";

	// Derived parameters
	this.degree = 0;
	this.type = "Calcified";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Stenosis.prototype = new ED.Doodle;
ED.Stenosis.prototype.constructor = ED.Stenosis;
ED.Stenosis.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Stenosis.prototype.setHandles = function() {
	//this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, true);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.Stenosis.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-10, +10);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-100, +0);
	//    this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI/6, Math.PI*2);
	//    this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.5);
	//    this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.5);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['degree'] = {
		kind: 'derived',
		type: 'int',
		range: new ED.Range(0, 100),
		precision: 0,
		animate: true
	};
	this.parameterValidationArray['type'] = {
		kind: 'derived',
		type: 'string',
		list: ['Calcified', 'Non-calcified'],
		animate: true
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Stenosis.prototype.setParameterDefaults = function() {
	this.setParameterFromString('degree', '0');
	this.setParameterFromString('type', 'Calcified');
	this.apexX = 0;
	this.apexY = 0;

	this.originX = -373;
	this.originY = 323;
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.Stenosis.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexX':
			returnArray['type'] = _value > 0 ? "Calcified" : "Non-calcified";
			break;

		case 'apexY':
			returnArray['degree'] = _value / -1;
			break;

		case 'type':
			returnArray['apexX'] = _value == "Calcified" ? +10 : -10;
			break;

		case 'degree':
			returnArray['apexY'] = -1 * _value;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Stenosis.prototype.draw = function(_point) {
	//console.log(this.originX, this.originY);
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Stenosis.superclass.draw.call(this, _point);

	// Exudate radius
	var r = 100;

	// Boundary path
	ctx.beginPath();

	// Stenosis
	ctx.arc(0, 0, 30, 0, 2 * Math.PI, false);

	// Set attributes
	ctx.lineWidth = 2;
	//ctx.strokeStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "blue";
	//    if (this.apexX > 0) ctx.fillStyle = "rgba(0, 0, 255," + (this.apexY/-100) + ")";
	//    else ctx.fillStyle = "rgba(0, 255, 0," + (this.apexY/-100) + ")";
	ctx.fillStyle = "rgba(155, 155, 0," + (this.apexY / -100) + ")";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {

		if (this.type == "Calcified") {
			ctx.beginPath();
			ctx.arc(-10, -10, 8, 0, 2 * Math.PI, false);
			ctx.moveTo(+10, -10);
			ctx.arc(+10, -10, 8, 0, 2 * Math.PI, false);
			ctx.moveTo(+10, +10);
			ctx.arc(+10, +10, 8, 0, 2 * Math.PI, false);
			ctx.moveTo(-10, +10);
			ctx.arc(-10, +10, 8, 0, 2 * Math.PI, false);

			ctx.fillStyle = "white";
			ctx.fill();

		}
		//        ctx.fillStyle = "blue";
		//
		//        ctx.beginPath();
		//        ctx.moveTo(-100, -50);
		//        ctx.bezierCurveTo(this.apexX, this.apexY, this.apexX, this.apexY, 100, -50);
		//        ctx.closePath();
		//        ctx.fill();
		//
		//        ctx.beginPath();
		//        ctx.moveTo(-100, 50);
		//        ctx.bezierCurveTo(this.apexX, -this.apexY, this.apexX, -this.apexY, 100, 50);
		//        ctx.closePath();
		//        ctx.fill();
	}

	// Coordinates of handles (in canvas plane)
	point = new ED.Point(this.apexX, this.apexY);
	this.handleArray[4].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Stenosis.prototype.description = function() {
	var artery;
	if (this.originX > 0) artery = "left coronary artery";
	else if (this.originX > -300) artery = "circumflex artery";
	else artery = "right coronary artery";

	return this.degree.toString() + "% " + this.type + " stenosis in the " + artery;
}

/**
 * Groin
 *
 * @class Groin
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Groin = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Groin";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Groin.prototype = new ED.Doodle;
ED.Groin.prototype.constructor = ED.Groin;
ED.Groin.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Groin.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.Groin.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
	this.isDeletable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-460, -420);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-460, -400);
}

/**
 * Sets default parameters
 */
ED.Groin.prototype.setParameterDefaults = function() {}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Groin.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Groin.superclass.draw.call(this, _point);

	// Calculate parameters for arcs
	var arcStart = 0;
	var arcEnd = 2 * Math.PI;

	// Boundary path
	ctx.beginPath();

	// Do a 360 arc
	ctx.moveTo(12, 49);
	ctx.bezierCurveTo(37, 49, 68, 24, 68, 24);
	ctx.bezierCurveTo(73, 42, 136, 318, 136, 318);

	ctx.lineTo(460, 318);
	ctx.bezierCurveTo(460, 318, 468, 191, 468, 159);
	ctx.bezierCurveTo(468, 127, 451, -48, 451, -67);
	ctx.bezierCurveTo(451, -87, 444, -188, 444, -215);
	ctx.bezierCurveTo(444, -242, 407, -402, 407, -402);

	ctx.lineTo(-380, -402);
	ctx.bezierCurveTo(-380, -402, -417, -242, -417, -215);
	ctx.bezierCurveTo(-417, -189, -423, -87, -423, -67);
	ctx.bezierCurveTo(-423, -48, -440, 127, -440, 159);
	ctx.bezierCurveTo(-440, 191, -432, 318, -432, 318);

	ctx.lineTo(-112, 318);
	ctx.lineTo(-40, 24);
	ctx.bezierCurveTo(-27, 39, -10, 49, 15, 49);

	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255, 175, 175, 0.5)";
	ctx.strokeStyle = "rgba(100, 100, 100, 1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		ctx.moveTo(-228, -189);

		ctx.lineTo(-158, -155);
		ctx.bezierCurveTo(-158, -155, -109, -113, -88, -75);
		ctx.bezierCurveTo(-74, -51, -65, -5, -40, 24);

		ctx.moveTo(255, -189);
		ctx.lineTo(186, -155);
		ctx.bezierCurveTo(186, -155, 136, -113, 115, -75);
		ctx.bezierCurveTo(102, -51, 92, -5, 68, 23);

		ctx.lineWidth = 4;
		ctx.fillStyle = "rgba(255, 255, 255, 0)";
		ctx.strokeStyle = "rgba(100, 100, 100, 1)";
		ctx.stroke();

	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle (overridden by subclasses)
 *
 * @returns {String} Description of doodle
 */
ED.Groin.prototype.description = function() {
	return "Groin";
}

/**
 * Blot Haemorrhage
 *
 * @class Haematoma
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Haematoma = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Haematoma";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Haematoma.prototype = new ED.Doodle;
ED.Haematoma.prototype.constructor = ED.Haematoma;
ED.Haematoma.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Haematoma.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Haematoma.prototype.setParameterDefaults = function() {
	this.originX = -150;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Haematoma.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Haematoma.superclass.draw.call(this, _point);

	// Exudate radius
	var r = 30;

	// Boundary path
	ctx.beginPath();

	// Exudate
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 1;
	ctx.strokeStyle = "red";
	ctx.fillStyle = "red";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.Haematoma.prototype.groupDescription = function() {
	return "Haematoma";
}


/**
 * Blot Haemorrhage
 *
 * @class Bruising
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Bruising = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Bruising";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Bruising.prototype = new ED.Doodle;
ED.Bruising.prototype.constructor = ED.Bruising;
ED.Bruising.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Bruising.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Bruising.prototype.setParameterDefaults = function() {
	this.originX = -190;
	this.originY = 100;
	this.scaleY = 2;
}

/**
 * Sets default dragging attributes
 */
ED.Bruising.prototype.setPropertyDefaults = function() {
	this.isSqueezable = true;
	//    // Update component of validation array for simple parameters
	//    this.parameterValidationArray['apexX']['range'].setMinAndMax(-10, +10);
	//    this.parameterValidationArray['apexY']['range'].setMinAndMax(-100, +0);
	//    //    this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI/6, Math.PI*2);
	//    //    this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.5);
	//    //    this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.5);
	//
	//    // Add complete validation arrays for derived parameters
	//    this.parameterValidationArray['degree'] = {kind:'derived', type:'int', range:new ED.Range(0, 100), precision:0, animate:true};
	//    this.parameterValidationArray['type'] = {kind:'derived', type:'string', list:['Calcified', 'Non-calcified'], animate:true};
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Bruising.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Bruising.superclass.draw.call(this, _point);

	// Exudate radius
	var r = 100;

	// Boundary path
	ctx.beginPath();

	// Exudate
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 1;
	ctx.strokeStyle = "rgba(127, 0, 127, 0.5)";
	ctx.fillStyle = "rgba(127, 0, 127, 0.5)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.Bruising.prototype.description = function() {
	return "Bruising";
}

/**
 * Bruit
 *
 * @class Bruit
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Bruit = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Bruit";

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Bruit.prototype = new ED.Doodle;
ED.Bruit.prototype.constructor = ED.Bruit;
ED.Bruit.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Bruit.prototype.setHandles = function() {
	//	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	//	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.Bruit.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-160, +0);
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 6, Math.PI * 2);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.5);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Bruit.prototype.setParameterDefaults = function() {
	this.scaleX = 0.6;
	this.scaleY = 0.6;

	this.originX = -150;
	this.originY = -62;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Bruit.prototype.draw = function(_point) {
	//console.log(this.originX, this.originY);
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Bruit.superclass.draw.call(this, _point);

	// Exudate radius
	var r = 100;

	// Boundary path
	ctx.beginPath();

	// Exudate
	ctx.arc(0, -50, r, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgba(155, 255, 255, 0)";
	ctx.fillStyle = "rgba(255, 255, 255, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.fillStyle = "gray";
		ctx.strokeStyle = "gray";
		ctx.lineWidth = 8;

		// Red centre
		ctx.beginPath();
		ctx.arc(-50, 0, 20, 0, 2 * Math.PI, false);
		ctx.fill();

		ctx.beginPath();
		ctx.moveTo(-34, 0);
		ctx.lineTo(-34, -100);
		ctx.lineTo(0, -80);

		ctx.stroke();

	}

	// Coordinates of handles (in canvas plane)
	//    var point = new ED.Point(0, 0);
	//    point.setWithPolars(rc, Math.PI/4);
	//	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Bruit.prototype.description = function() {
	//    var lung = this.originX > 0?" left lung":" right lung";
	//    var lobe = this.originY > 0?" lower lobe of":" upper lobe of";

	return 'Bruit';
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Crepitations
 *
 * @class Crepitations
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Crepitations = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Crepitations";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexX', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Crepitations.prototype = new ED.Doodle;
ED.Crepitations.prototype.constructor = ED.Crepitations;
ED.Crepitations.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Crepitations.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.Crepitations.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(+50, +200);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-0, +0);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Crepitations.prototype.setParameterDefaults = function() {
	this.rotation = -Math.PI / 4;
	this.apexX = 50;
	this.apexY = 0;

	this.setOriginWithDisplacements(-150, 300);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Crepitations.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Crepitations.superclass.draw.call(this, _point);

	// Crepitation radius
	var r = Math.sqrt(this.apexX * this.apexX + this.apexY * this.apexY);

	// Boundary path
	ctx.beginPath();

	// Crepitation
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 3;
	ctx.strokeStyle = "rgba(255, 255, 255, 0)";
	ctx.fillStyle = "rgba(255, 255, 255, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Start path
		ctx.beginPath();

		// Spacing of lines
		var d = 30;

		// Draw central line
		ctx.moveTo(-r, 0);
		ctx.lineTo(r, 0);

		// Draw other lines
		for (var s = -1; s < 2; s += 2) {
			for (var y = d; y < r; y += d) {
				var x = this.xForY(r, y);
				ctx.moveTo(-x, s * y);
				ctx.lineTo(x, s * y);
			}
		}

		// Set attributes
		ctx.lineWidth = 15;
		ctx.lineCap = "round";
		ctx.strokeStyle = "rgba(200, 200, 200, 0.75)";

		// Draw lines
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Crepitations.prototype.description = function() {
	var lung = this.originX > 0 ? " left lung" : " right lung";
	var lobe = this.originY > 0 ? " lower lobe of" : " upper lobe of";

	return 'crepitations' + lobe + lung;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Effusion
 *
 * @class Effusion
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Effusion = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Effusion";

	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Effusion.prototype = new ED.Doodle;
ED.Effusion.prototype.constructor = ED.Effusion;
ED.Effusion.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Effusion.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.Effusion.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Effusion.prototype.setParameterDefaults = function() {
	this.apexX = -231;
	this.apexY = 136;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Effusion.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Effusion.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Right effusion
	ctx.moveTo(this.apexX, this.apexY);
	ctx.lineTo(-400 + (-136 + this.apexY) * -0.3, this.apexY);
	ctx.lineTo(-426, 289);

	ctx.bezierCurveTo(-334, 226, -219, 196, -79, 236);
	ctx.lineTo(-44, this.apexY);
	ctx.lineTo(this.apexX, this.apexY);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "yellow";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Effusion.prototype.description = function() {
	return "pleural effusion in right lung";
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Lungs
 *
 * @class Lungs
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Lungs = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Lungs";

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Lungs.prototype = new ED.Doodle;
ED.Lungs.prototype.constructor = ED.Lungs;
ED.Lungs.superclass = ED.Doodle.prototype;

/**
 * Sets default properties
 */
ED.Lungs.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
	this.isDeletable = false;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Lungs.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Lungs.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Right lung
	ctx.moveTo(-147, -281);
	ctx.bezierCurveTo(-224, -279, -414, 29, -426, 289);
	ctx.bezierCurveTo(-334, 226, -219, 196, -79, 236);
	ctx.bezierCurveTo(-6, 231, -71, -284, -147, -281);

	// Left Lung
	ctx.moveTo(147, -281);
	ctx.bezierCurveTo(224, -279, 414, 29, 426, 289);
	ctx.bezierCurveTo(334, 226, 219, 196, 79, 236);
	ctx.bezierCurveTo(6, 231, 71, -284, 147, -281);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "white";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Calculate arc (Arc property not used naturally in this doodle)
// 	this.leftExtremity = this.transform.transformPoint(new ED.Point(-40, -40));
// 	this.rightExtremity = this.transform.transformPoint(new ED.Point(40, -40));
// 	this.arc = this.calculateArc();

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Lungs.prototype.description = function() {
	return this.drawing.doodleArray.length == 1 ? "No abnormality" : "";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Wheeze
 *
 * @class Wheeze
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Wheeze = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Wheeze";
	
	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Wheeze.prototype = new ED.Doodle;
ED.Wheeze.prototype.constructor = ED.Wheeze;
ED.Wheeze.superclass = ED.Doodle.prototype;

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Wheeze.prototype.setParameterDefaults = function() {
	this.scaleX = 0.6;
	this.scaleY = 0.6;
	
	this.setOriginWithDisplacements(-200, 100);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Wheeze.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Wheeze.superclass.draw.call(this, _point);

	// Exudate radius
	var r = 100;

	// Boundary path
	ctx.beginPath();

	// Boundary
	ctx.arc(0, -50, r, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgba(255, 255, 255, 0)";
	ctx.fillStyle = "rgba(255, 255, 255, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.fillStyle = "gray";
		ctx.strokeStyle = "gray";
		ctx.lineWidth = 8;

		ctx.beginPath();
		ctx.arc(-50, 0, 20, 0, 2 * Math.PI, false);
		ctx.fill();

		ctx.beginPath();
		ctx.moveTo(-34, 0);
		ctx.lineTo(-34, -100);
		ctx.lineTo(66, -150);
		ctx.lineTo(66, -50);

		ctx.stroke();

		ctx.beginPath();
		ctx.arc(50, -50, 20, 0, 2 * Math.PI, false);
		ctx.fill();

		ctx.closePath();
		ctx.fillStyle = "gray";
		ctx.fill();
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Wheeze.prototype.description = function() {
	var lung = this.originX > 0 ? " left lung" : " right lung";
	var lobe = this.originY > 0 ? " lower lobe of" : " upper lobe of";

	return 'wheeze' + lobe + lung;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Ear Drum
 *
 * @class EarDrum
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.EarDrum = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "EarDrum";

	// Saved parameters
	//this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.EarDrum.prototype = new ED.Doodle;
ED.EarDrum.prototype.constructor = ED.EarDrum;
ED.EarDrum.superclass = ED.Doodle.prototype;

/**
 * Sets default properties
 */
ED.EarDrum.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.EarDrum.prototype.setParameterDefaults = function() {
	//this.originY = -70;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.EarDrum.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.EarDrum.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Ear drum boundary
	ctx.moveTo(-319, -94);
	ctx.bezierCurveTo(-321, -68, -330, 81, -278, 194);
	ctx.bezierCurveTo(-247, 261, -175, 336, -105, 371);
	ctx.bezierCurveTo(-58, 395, -5, 397, 46, 395);
	ctx.bezierCurveTo(166, 390, 231, 294, 236, 287);
	ctx.bezierCurveTo(301, 194, 347, 8, 322, -133);
	ctx.bezierCurveTo(304, -234, 284, -259, 251, -302);
	ctx.bezierCurveTo(191, -383, 69, -373, 15, -373);
	ctx.bezierCurveTo(-10, -373, -23, -393, -61, -390);
	ctx.bezierCurveTo(-93, -388, -107, -366, -141, -352);
	ctx.bezierCurveTo(-167, -337, -194, -345, -211, -330);
	ctx.bezierCurveTo(-229, -313, -236, -289, -254, -253);
	ctx.bezierCurveTo(-271, -218, -308, -152, -319, -94);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(245,224,173,0.5)";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.fillStyle = "rgba(255,255,255,0";
		
		// Wavy bit across top
		ctx.beginPath();
		ctx.moveTo(-237, -255);
		ctx.bezierCurveTo(-224, -269, -198, -270, -175, -272);
		ctx.bezierCurveTo(-151, -274, -127, -268, -92, -279);
		ctx.bezierCurveTo(-58, -290, -44, -303, -31, -314);
		ctx.bezierCurveTo(-18, -325, -4, -339, 30, -348);
		ctx.stroke();

		// Big separator with the notch
		ctx.beginPath();		
		ctx.moveTo(328, -14);
		ctx.bezierCurveTo(334, -136, 269, -283, 204, -320);
		ctx.bezierCurveTo(139, -357, 94, -347, 47, -339);
		ctx.bezierCurveTo(17, -332, -5, -304, -25, -291);
		ctx.bezierCurveTo(-46, -278, -71, -268, -86, -255);
		ctx.bezierCurveTo(-102, -242, -102, -227, -107, -212);
		ctx.bezierCurveTo(-112, -200, -115, -200, -128, -200);
		ctx.bezierCurveTo(-143, -201, -143, -202, -152, -212);
		ctx.bezierCurveTo(-162, -223, -156, -244, -169, -248);
		ctx.bezierCurveTo(-182, -251, -204, -246, -204, -246);
		ctx.bezierCurveTo(-259, -227, -321, -138, -321, -63);
		ctx.stroke();
		
		// Shading at top
		ctx.beginPath();
		ctx.moveTo(-207, -282);
		ctx.bezierCurveTo(-179, -279, -164, -280, -143, -292);
		ctx.moveTo(-207, -292);
		ctx.bezierCurveTo(-197, -289, -181, -290, -165, -295);
		ctx.moveTo(-201, -302);
		ctx.bezierCurveTo(-193, -299, -182, -302, -174, -305);
		ctx.moveTo(-96, -345);
		ctx.bezierCurveTo(-88, -351, -87, -352, -82, -363);
		ctx.moveTo(-92, -335);
		ctx.bezierCurveTo(-83, -341, -75, -349, -70, -359);
		ctx.moveTo(-92, -321);
		ctx.bezierCurveTo(-76, -330, -65, -345, -58, -359);
		ctx.moveTo(-87, -308);
		ctx.bezierCurveTo(-71, -317, -50, -339, -44, -354);
		ctx.moveTo(-87, -297);
		ctx.bezierCurveTo(-70, -308, -45, -327, -33, -348);
		ctx.moveTo(-82, -290);
		ctx.bezierCurveTo(-62, -301, -33, -324, -18, -348);
		ctx.stroke();
		
		// Large toungey thing
		ctx.beginPath();		
		ctx.moveTo(-204, -246);
		ctx.bezierCurveTo(-189, -199, -146, -200, -123, -195);
		ctx.bezierCurveTo(-99, -189, -91, -152, -92, -120);
		ctx.bezierCurveTo(-92, -88, -100, -58, -92, -21);
		ctx.bezierCurveTo(-83, 16, -55, 40, -47, 64);
		ctx.bezierCurveTo(-40, 87, -53, 99, -44, 117);
		ctx.bezierCurveTo(-38, 128, -38, 135, -18, 137);
		ctx.bezierCurveTo(1, 140, 2, 131, 7, 120);
		ctx.bezierCurveTo(16, 99, 16, 86, 10, 63);
		ctx.bezierCurveTo(4, 40, -20, 8, -27, -66);
		ctx.bezierCurveTo(-33, -129, -17, -167, -3, -223);
		ctx.bezierCurveTo(12, -278, 58, -321, 99, -345);
		ctx.setLineDash([10]);
		ctx.stroke();
		
		// Small toungey thing
		ctx.beginPath();		
		ctx.moveTo(56, -315);
		ctx.bezierCurveTo(56, -315, 68, -321, 84, -308);
		ctx.bezierCurveTo(100, -296, 126, -182, 137, -158);
		ctx.bezierCurveTo(148, -135, 143, -130, 159, -130);
		ctx.bezierCurveTo(175, -130, 183, -136, 185, -162);
		ctx.bezierCurveTo(187, -188, 169, -293, 151, -340);
		ctx.setLineDash([10]);
		ctx.stroke();
		
		// Lines
		ctx.beginPath();
		ctx.moveTo(-165, 230);
		ctx.lineTo(-44, 117);
		ctx.moveTo(-63, 356);
		ctx.lineTo(-1, 138);
		ctx.setLineDash([30,10]);
		ctx.stroke();
	}

	// Return value indicating successful hittest
	return this.isClicked;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Grommet
 *
 * @class Grommet
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Grommet = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Grommet";

	// Other parameters
	this.type = "Short term";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY', 'type'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'type':'Type'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Grommet.prototype = new ED.Doodle;
ED.Grommet.prototype.constructor = ED.Grommet;
ED.Grommet.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Grommet.prototype.setHandles = function() {
	//this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default properties
 */
ED.Grommet.prototype.setPropertyDefaults = function() {
	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['type'] = {
		kind: 'derived',
		type: 'string',
		list: ['Short term', 'Long term'],
		animate: true
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Grommet.prototype.setParameterDefaults = function() {
	// Displacement from fovea, and from last doodle
	var d = 100;
	this.originX = d;
	this.originY = d;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Grommet.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Grommet.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Round hole
	ctx.arc(0, 0, 40, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 32;
	ctx.fillStyle = "rgba(255,255,255,0)";
	ctx.strokeStyle = "white";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(21, -21));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Calculate arc (Arc property not used naturally in this doodle ***TODO** more elegant method of doing this possible!)
	var centre = this.transform.transformPoint(new ED.Point(0, 0));
	var oneWidthToRight = this.transform.transformPoint(new ED.Point(60, 0));
	var xco = centre.x - this.drawing.canvas.width / 2;
	var yco = centre.y - this.drawing.canvas.height / 2;
	var radius = this.scaleX * Math.sqrt(xco * xco + yco * yco);
	var width = this.scaleX * (oneWidthToRight.x - centre.x);
	this.arc = Math.atan(width / radius);
	//console.log(this.arc * 180/Math.PI + " + " + this.calculateArc() * 180/Math.PI);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Grommet.prototype.description = function() {
	return "Grommet";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Perforation
 *
 * @class Perforation
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Perforation = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Perforation";

	// Constants
	this.margin = 30000;

	// Derived parameters
	this.isMarginal = false;

	// Other parameters
	this.safe = true;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY', 'safe'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'safe':'Safe'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Perforation.prototype = new ED.Doodle;
ED.Perforation.prototype.constructor = ED.Perforation;
ED.Perforation.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Perforation.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default dragging attributes
 */
ED.Perforation.prototype.setPropertyDefaults = function() {
	this.isSqueezable = true;
	this.isRotatable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-300, +300);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-300, +300);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.25, +2);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.25, +2);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['isMarginal'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['safe'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
}

/**
 * Sets default parameters
 */
ED.Perforation.prototype.setParameterDefaults = function() {
	this.scaleX = 0.5;
	this.scaleY = 0.75;
	this.setOriginWithDisplacements(-100, 25);
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.Perforation.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'originX':
			if (this.originX * this.originX + this.originY * this.originY > this.margin) {
				returnArray['isMarginal'] = true;
			}
			else {
				returnArray['isMarginal'] = false;
			}
			break;

		case 'originY':
			if (this.originX * this.originX + this.originY * this.originY > this.margin) {
				returnArray['isMarginal'] = true;
			}
			else {
				returnArray['isMarginal'] = false;
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Perforation.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Perforation.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Perforation
	var r = 120;
	ctx.arc(0, 0, r, 0, Math.PI * 2, false);

	// Close path
	ctx.closePath();

	// Properties
	ctx.lineWidth = 3;
	ctx.fillStyle = "rgba(255, 155, 110, 1)";
	ctx.strokeStyle = "rgba(100, 100, 100, 1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
	ED.Perforation.prototype.description = function() {
// 	var returnValue = this.isMarginal?"Marginal":"Central";
// 	returnValue += " perforation of eardrum";

	var returnValue = "";

	if (this.originX <= 0) returnValue = "Antero";
	else returnValue = "Postero";

	if (this.originY <= 0) returnValue += "superior";
	else returnValue += "inferior";

	returnValue += " perforation of eardrum";


	return returnValue;
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.Perforation.prototype.snomedCode = function() {
	return this.isMarginal?39895008:40723007;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.Perforation.prototype.diagnosticHierarchy = function() {
	return 3;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Anterior chamber IOL
 *
 * @class ACIOL
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ACIOL = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ACIOL";
    this.csOriginX = -140;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'rotation', 'csOriginX'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

	// Invariate parameters
	this.scaleX = 0.8;
	this.scaleY = 0.8;
}

/**
 * Sets superclass and constructor
 */
ED.ACIOL.prototype = new ED.Doodle;
ED.ACIOL.prototype.constructor = ED.ACIOL;
ED.ACIOL.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.ACIOL.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Rotate, false);
}

/**
 * Sets default properties
 */
ED.ACIOL.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isUnique = true;
	
	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-200, +200);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-200, +200);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ACIOL.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ACIOL.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Radius of IOL optic
	var r = 240;

	// Draw optic
	ctx.arc(0, 0, r, 0, Math.PI * 2, false);

	// Draw upper haptic (see ACIOL.c4D for bezier points)
	ctx.moveTo(150, -190);
	ctx.bezierCurveTo(160, -200, 170, -210, 160, -230);
	ctx.bezierCurveTo(150, -250, 100, -280, 50, -290);
	ctx.bezierCurveTo(0, -300, -220, -330, -230, -340);
	ctx.bezierCurveTo(-250, -360, -220, -420, -200, -430);
	ctx.bezierCurveTo(-180, -440, -180, -440, -150, -450);
	ctx.bezierCurveTo(-120, -460, -130, -430, -120, -420);
	ctx.bezierCurveTo(-110, -410, 110, -410, 120, -420);
	ctx.bezierCurveTo(130, -430, 120, -460, 150, -450);
	ctx.bezierCurveTo(180, -440, 180, -440, 200, -430);
	ctx.bezierCurveTo(220, -420, 180, -400, 150, -390);
	ctx.bezierCurveTo(120, -380, -120, -380, -150, -390);
	ctx.bezierCurveTo(-180, -400, -190, -370, -170, -360);
	ctx.bezierCurveTo(-150, -350, 20, -330, 70, -320);
	ctx.bezierCurveTo(120, -310, 190, -280, 210, -250);
	ctx.bezierCurveTo(230, -220, 220, -140, 220, -100);

	// Draw lower haptic
	ctx.moveTo(-150, 190);
	ctx.bezierCurveTo(-160, 200, -170, 210, -160, 230);
	ctx.bezierCurveTo(-150, 250, -100, 280, -50, 290);
	ctx.bezierCurveTo(0, 300, 220, 330, 230, 340);
	ctx.bezierCurveTo(250, 360, 220, 420, 200, 430);
	ctx.bezierCurveTo(180, 440, 180, 440, 150, 450);
	ctx.bezierCurveTo(120, 460, 130, 430, 120, 420);
	ctx.bezierCurveTo(110, 410, -110, 410, -120, 420);
	ctx.bezierCurveTo(-130, 430, -120, 460, -150, 450);
	ctx.bezierCurveTo(-180, 440, -180, 440, -200, 430);
	ctx.bezierCurveTo(-220, 420, -180, 400, -150, 390);
	ctx.bezierCurveTo(-120, 380, 120, 380, 150, 390);
	ctx.bezierCurveTo(180, 400, 190, 370, 170, 360);
	ctx.bezierCurveTo(150, 350, -20, 330, -70, 320);
	ctx.bezierCurveTo(-120, 310, -190, 280, -210, 250);
	ctx.bezierCurveTo(-230, 220, -220, 140, -220, 100);

	// Colour of fill is white but with transparency
	ctx.fillStyle = "rgba(255,255,255,0.75)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "darkgray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0)
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ACIOL.prototype.description = function() {
	var returnValue = "Anterior chamber IOL";

	// Displacement limit
	var limit = 40;

	var displacementValue = "";

	if (this.originY < -limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += " superiorly";
	}
	if (this.originY > limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += " inferiorly";
	}
	if (this.originX < -limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += (this.drawing.eye == ED.eye.Right) ? " temporally" : " nasally";
	}
	if (this.originX > limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += (this.drawing.eye == ED.eye.Right) ? " nasally" : " temporally";
	}

	// Add displacement description
	if (displacementValue.length > 0) returnValue += " displaced" + displacementValue;

	return returnValue;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * AC IOL Cross Section
 *
 * @class ACIOLCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ACIOLCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ACIOLCrossSection";
	
	// Saved parameters
	this.savedParameterArray = ['originX', 'originY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

    this.linkedDoodleParameters = {
        'ACIOL': {
            source: ['originY'],
            store: [['originX', 'csOriginX']]
        }
    };
}

/**
 * Sets superclass and constructor
 */
ED.ACIOLCrossSection.prototype = new ED.Doodle;
ED.ACIOLCrossSection.prototype.constructor = ED.ACIOLCrossSection;
ED.ACIOLCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.ACIOLCrossSection.prototype.setPropertyDefaults = function() {
	this.isUnique = true;
	this.inFrontOfClassArray = ["HypopyonCrossSection", "HyphaemaCrossSection" ];
	this.addAtBack = true;
	
	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-220, -100);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-140, +140);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.ACIOLCrossSection.prototype.setParameterDefaults = function() {
	this.originX = -140;
}


/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ACIOLCrossSection.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ACIOLCrossSection.superclass.draw.call(this, _point);

	// Draw lens
	ctx.beginPath();
	ctx.ellipse(100, 0, 160, 20, 0.5 * Math.PI, 0, 2 * Math.PI);

	// Set line attributes
	ctx.lineWidth = 5;
	ctx.fillStyle = "rgba(255, 255, 255, 0.75)";
	ctx.strokeStyle = "#898989";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {

		// Loops
		ctx.beginPath();
		ctx.arc(10 - this.originX, -310 - this.originY, 10, 0*Math.PI, 1*Math.PI, false);
		ctx.moveTo(5 - this.originX, -310 - this.originY);
		ctx.bezierCurveTo(80 - this.originX, -300 - this.originY, 70, -220, 100, -160);
		ctx.moveTo(40 - this.originX, 300 - this.originY);
		ctx.arc(10 - this.originX, 310 - this.originY, 10, 0, 1*Math.PI, true);
		ctx.moveTo(5 - this.originX, 310 - this.originY);
		ctx.bezierCurveTo(80 - this.originX, 300 - this.originY, 70, 220, 100, 160);
		ctx.strokeStyle = "#898989";
		ctx.stroke();

	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Chandelier (single)
 *
 * @class ACMaintainer
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ACMaintainer = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ACMaintainer";

	// Private parameters
	this.limbus = -400;

	// Saved parameters
	this.savedParameterArray = ['rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.ACMaintainer.prototype = new ED.Doodle;
ED.ACMaintainer.prototype.constructor = ED.ACMaintainer;
ED.ACMaintainer.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.ACMaintainer.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
}

/**
 * Sets default parameters
 */
ED.ACMaintainer.prototype.setParameterDefaults = function() {
	this.setRotationWithDisplacements(180, 90);
	
	// Position over SidePort if present
	var doodle = this.drawing.lastDoodleOfClass("SidePort");
	if (doodle) {
		this.rotation = doodle.rotation;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ACMaintainer.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ACMaintainer.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Port
	ctx.rect(-60, this.limbus - 60, 120, 160);

	// Set line attributes
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";

	ctx.fillStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Trocar
		ctx.beginPath();
		ctx.moveTo(-20, this.limbus + 60);
		ctx.lineTo(+20, this.limbus + 60);
		ctx.lineTo(+20, this.limbus + 160);
		ctx.lineTo(-20, this.limbus + 200);
		ctx.lineTo(-20, this.limbus + 60);
		ctx.fillStyle = "rgba(120, 120, 120, 0.5)";
		ctx.fill();

		// Body
		ctx.beginPath();
		ctx.rect(-30, this.limbus, 60, 80);
		ctx.fillStyle = "rgba(120, 120, 120, 0.75)";
		ctx.fill();

		// Fibre optic
		ctx.beginPath();
		ctx.moveTo(0, this.limbus);
		ctx.bezierCurveTo(0, this.limbus - 50, 50, this.limbus - 100, 100, this.limbus - 100);
		ctx.lineWidth = 40;
		ctx.strokeStyle = "rgba(120, 120, 120, 0.5)";
		ctx.stroke();
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.ACMaintainer.prototype.groupDescription = function() {
	return "Chandelier at ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ACMaintainer.prototype.description = function() {
	// Location (clockhours)
	return this.clockHour() + " o'clock";
}

/**
 * OpenEyes
 *
 * (C) OpenEyes Foundation, 2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Adenoviral keratitis
 *
 * @class AdenoviralKeratitis
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AdenoviralKeratitis = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AdenoviralKeratitis";

	// Private parameters used in bound sideview doodle
	this.h = 250;
	
	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY', 'scaleX', 'scaleY','originX','originY','h'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.AdenoviralKeratitis.prototype = new ED.Doodle;
ED.AdenoviralKeratitis.prototype.constructor = ED.AdenoviralKeratitis;
ED.AdenoviralKeratitis.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AdenoviralKeratitis.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.AdenoviralKeratitis.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +40);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-160, +0);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.5);
	
	this.parameterValidationArray['h'] = {
		kind: 'derived',
		type: 'int',
		animate: false
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.AdenoviralKeratitis.prototype.setParameterDefaults = function() {
	this.apexY = -5;
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @param {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.AdenoviralKeratitis.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = {},
		returnValue;

	switch (_parameter) {
		// dependent parameters for bound side view doodle		
		case 'scaleX':
			returnArray.h = Math.round(_value * 250);
			break;
			
		case 'h':
			returnArray['h'] = _value;
			break;
			
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AdenoviralKeratitis.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AdenoviralKeratitis.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Invisible boundary
	var r = 250;
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Colours
		var fill = "rgba(230, 230, 230, 0.8)";
		ctx.shadowBlur = 3;
		ctx.shadowColor="black";

		var dr = 8 * ((this.apexX + 20) / 20) / this.scaleX;

		var p = new ED.Point(0, 0);
		var n = 2 + Math.abs(Math.floor(this.apexY / 2));
		for (var i = 0; i < n; i++) {
			p.setWithPolars(r * ED.randomArray[i], 2 * Math.PI * ED.randomArray[i+100]);
			this.drawSpot(ctx, p.x, p.y, dr, fill);
		}
		this.drawSpot(ctx, 0, r, dr, fill);
		this.drawSpot(ctx, 0, -r, dr, fill);
		this.drawSpot(ctx, r, 0, dr, fill);
		this.drawSpot(ctx, -r, 0, dr, fill);
		
		ctx.shadowColor="rgba(0, 0, 0, 0)";
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(r * 0.7, -r * 0.7));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.AdenoviralKeratitis.prototype.description = function() {
	return "Adenoviral keratitis";
}

/**
 * OpenEyes
 *
 * (C) OpenEyes Foundation, 2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Adenoviral Keratitis Cross Section
 *
 * @class AdenoviralKeratitisCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AdenoviralKeratitisCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AdenoviralKeratitisCrossSection";
	
	// Derived parameters
	this.h = 250;
	
	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'h'];
	
	// Parameters in doodle control bar
	this.controlParameterArray = {};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.AdenoviralKeratitisCrossSection.prototype = new ED.Doodle;
ED.AdenoviralKeratitisCrossSection.prototype.constructor = ED.AdenoviralKeratitisCrossSection;
ED.AdenoviralKeratitisCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AdenoviralKeratitisCrossSection.prototype.setHandles = function() {
}

/**
 * Sets default properties
 */
ED.AdenoviralKeratitisCrossSection.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
	this.isFilled = false;
		
	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(+50, +50);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-500, +500);
	
	this.parameterValidationArray['h'] = {
		kind: 'other',
		type: 'int',
		range: [0,1080],
		animate: true
	};
}

/**
 * Sets default parameters
 */
ED.AdenoviralKeratitisCrossSection.prototype.setParameterDefaults = function() {
	this.originX = 50; // as is in Cornea cross section doodle to dulicate bezier control points

}

/**
 * Draws a circular spot with given parameters
 *
 * @param {Object} _ctx Context of canvas
 * @param {Float} _x X-coordinate of origin
 * @param {Float} _y Y-coordinate of origin
 * @param {Float} _r Radius
 * @param {String} _colour String containing colour
 */
ED.AdenoviralKeratitisCrossSection.prototype.drawOval = function(_ctx, _x, _y, _r, _rotation) {
	_ctx.save();
	_ctx.beginPath();
	_ctx.ellipse(_x, _y, 0.5*_r, _r, _rotation, 0, 2*Math.PI, true);
	_ctx.fillStyle = "rgba(215, 215, 215, 0.8)";
	_ctx.strokeStyle = "rgba(215, 215, 215, 0.8)";
	_ctx.shadowBlur = 2;
	_ctx.shadowColor="black";
	_ctx.lineWidth = 0;
	_ctx.fill();
	_ctx.stroke();
	_ctx.restore();
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AdenoviralKeratitisCrossSection.prototype.draw = function(_point) {	
	
	// Get context
	var ctx = this.drawing.context;

	var cornea = this.drawing.lastDoodleOfClass('CorneaCrossSection');
	var cornealThickness = cornea.pachymetry/5;

	// Call draw method in superclass
	ED.AdenoviralKeratitisCrossSection.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();
	
	// Calculate segment extent in terms of time along curve
	var r = this.h; // TO DO
	var startY = this.originY - r;
	var endY = this.originY + r;
		
	var startT = (startY + 380) / 760;
	if (startT<0) startT = 0;
	var endT = (endY + 380) / 760;
	if (endT>1) endT = 1;
			
	if (startT < 0.5) {
		
		var superiorBezier = new Object;

		// define start and end time points
		var tI0 = startT * 2;
		var tI1 = (endT < 0.5) ? endT * 2 : 1;
		
		// default bezier points (as in cornea cross section)
		if (cornea && cornea.shape == "Keratoconus") {			
			superiorBezier.SP = new ED.Point(-120, -380 - this.originY);
			superiorBezier.CP1 = new ED.Point(-240, -260 - this.originY);
			superiorBezier.CP2 = new ED.Point(cornea.apexX, cornea.apexY - 100 - this.originY);
			superiorBezier.EP = new ED.Point(cornea.apexX, cornea.apexY - this.originY);
		}
		else if (cornea && cornea.shape == "Keratoglobus") {
			superiorBezier.SP = new ED.Point(-120, -380 - this.originY);
			superiorBezier.CP1 = new ED.Point(-240, -260 - this.originY);
			superiorBezier.CP2 = new ED.Point(-380, -100 - this.originY);
			superiorBezier.EP = new ED.Point(-380, 100 - this.originY);
		}
		else {			
			superiorBezier.SP = new ED.Point(-120, -380 - this.originY);
			superiorBezier.CP1 = new ED.Point(-240, -260 - this.originY);
			superiorBezier.CP2 = new ED.Point(-320, -160 - this.originY);
			superiorBezier.EP = new ED.Point(-320, 0 - this.originY);
		}
		
			
		if (tI0 > 0) {
		// Trim start of curve			
			
			// front of cornea
			var sq0 = new ED.Point(0,0);
			sq0.y = (1-tI0)*(1-tI0)*(1-tI0)*superiorBezier.SP.y + 3*(1-tI0)*(1-tI0)*tI0*superiorBezier.CP1.y + 3*(1-tI0)*tI0*tI0*superiorBezier.CP2.y + tI0*tI0*tI0*superiorBezier.EP.y;
			sq0.x = (1-tI0)*(1-tI0)*(1-tI0)*superiorBezier.SP.x + 3*(1-tI0)*(1-tI0)*tI0*superiorBezier.CP1.x + 3*(1-tI0)*tI0*tI0*superiorBezier.CP2.x + tI0*tI0*tI0*superiorBezier.EP.x;
			
			var iP23 = new ED.Point(0,0);
			iP23.x = superiorBezier.CP1.x + tI0 * (superiorBezier.CP2.x - superiorBezier.CP1.x);
			iP23.y = superiorBezier.CP1.y + tI0 * (superiorBezier.CP2.y - superiorBezier.CP1.y);
			
			var iP34 = new ED.Point(0,0);
			iP34.x = superiorBezier.CP2.x + tI0 * (superiorBezier.EP.x - superiorBezier.CP2.x);
			iP34.y = superiorBezier.CP2.y + tI0 * (superiorBezier.EP.y - superiorBezier.CP2.y);
			
			var iP2334 = new ED.Point(0,0);
			iP2334.x = iP23.x + tI0 * (iP34.x - iP23.x);
			iP2334.y = iP23.y + tI0 * (iP34.y - iP23.y);
			
			superiorBezier.SP = sq0;
			superiorBezier.CP1 = iP2334;
			superiorBezier.CP2 = iP34;
		}
		
		if (tI1 < 1) {
		// Trim end of curve			
			
			// front of cornea
			var iq1 = new ED.Point(0,0);
			iq1.y = (1-tI1)*(1-tI1)*(1-tI1)*superiorBezier.SP.y + 3*(1-tI1)*(1-tI1)*tI1*superiorBezier.CP1.y + 3*(1-tI1)*tI1*tI1*superiorBezier.CP2.y + tI1*tI1*tI1*superiorBezier.EP.y;
			iq1.x = (1-tI1)*(1-tI1)*(1-tI1)*superiorBezier.SP.x + 3*(1-tI1)*(1-tI1)*tI1*superiorBezier.CP1.x + 3*(1-tI1)*tI1*tI1*superiorBezier.CP2.x + tI1*tI1*tI1*superiorBezier.EP.x;

			var iP12 = new ED.Point(0,0);
			iP12.x = superiorBezier.SP.x + tI1 * (superiorBezier.CP1.x - superiorBezier.SP.x);
			iP12.y = superiorBezier.SP.y + tI1 * (superiorBezier.CP1.y - superiorBezier.SP.y);
			
			var iP23 = new ED.Point(0,0);
			iP23.x = superiorBezier.CP1.x + tI1 * (superiorBezier.CP2.x - superiorBezier.CP1.x);
			iP23.y = superiorBezier.CP1.y + tI1 * (superiorBezier.CP2.y - superiorBezier.CP1.y);
			
			var iP1223 = new ED.Point(0,0);
			iP1223.x = iP12.x + tI1 * (iP23.x - iP12.x);
			iP1223.y = iP12.y + tI1 * (iP23.y - iP12.y);
			
			superiorBezier.CP1 = iP12;
			superiorBezier.CP2 = iP1223;
			superiorBezier.EP = iq1;
		}
	}
	
	
	if (endT > 0.5) {
		
		var inferiorBezier = new Object;
		
		// define start and end time points
		var tS0 = (startT > 0.5) ? (startT - 0.5) * 2 : 0;
		var tS1 = (endT - 0.5) * 2;
		
		// default bezier points (as in cornea cross section)
		if (cornea && cornea.shape == "Keratoconus") {			
			inferiorBezier.SP = new ED.Point(cornea.apexX, cornea.apexY - this.originY);
			inferiorBezier.CP1 = new ED.Point(cornea.apexX, cornea.apexY + 100 - this.originY);
			inferiorBezier.CP2 = new ED.Point(-240, 260 - this.originY);
			inferiorBezier.EP = new ED.Point(-120, 380 - this.originY);
		}
		else if (cornea && cornea.shape == "Keratoglobus") {
			inferiorBezier.SP = new ED.Point(-380, 100 - this.originY);
			inferiorBezier.CP1 = new ED.Point(-380, 200 - this.originY);
			inferiorBezier.CP2 = new ED.Point(-240, 360 - this.originY);
			inferiorBezier.EP = new ED.Point(-120, 380 - this.originY);
		}
		else {			
			inferiorBezier.SP = new ED.Point(-320, -0 - this.originY);
			inferiorBezier.CP1 = new ED.Point(-320, 160 - this.originY);
			inferiorBezier.CP2 = new ED.Point(-240, 260 - this.originY);
			inferiorBezier.EP = new ED.Point(-120, 380 - this.originY);
		}			
		
		
		if (tS0 > 0) {
		// Trim start of curve
			
			// front of cornea			
			var sq0 = new ED.Point(0,0);
			sq0.y = (1-tS0)*(1-tS0)*(1-tS0)*inferiorBezier.SP.y + 3*(1-tS0)*(1-tS0)*tS0*inferiorBezier.CP1.y + 3*(1-tS0)*tS0*tS0*inferiorBezier.CP2.y + tS0*tS0*tS0*inferiorBezier.EP.y;
			sq0.x = (1-tS0)*(1-tS0)*(1-tS0)*inferiorBezier.SP.x + 3*(1-tS0)*(1-tS0)*tS0*inferiorBezier.CP1.x + 3*(1-tS0)*tS0*tS0*inferiorBezier.CP2.x + tS0*tS0*tS0*inferiorBezier.EP.x;
			
			var sP23 = new ED.Point(0,0);
			sP23.x = inferiorBezier.CP1.x + tS0 * (inferiorBezier.CP2.x - inferiorBezier.CP1.x);
			sP23.y = inferiorBezier.CP1.y + tS0 * (inferiorBezier.CP2.y - inferiorBezier.CP1.y);
			
			var sP34 = new ED.Point(0,0);
			sP34.x = inferiorBezier.CP2.x + tS0 * (inferiorBezier.EP.x - inferiorBezier.CP2.x);
			sP34.y = inferiorBezier.CP2.y + tS0 * (inferiorBezier.EP.y - inferiorBezier.CP2.y);
			
			var sP2334 = new ED.Point(0,0);
			sP2334.x = sP23.x + tS0 * (sP34.x - sP23.x);
			sP2334.y = sP23.y + tS0 * (sP34.y - sP23.y);
			
			inferiorBezier.SP = sq0;
			inferiorBezier.CP1 = sP2334;
			inferiorBezier.CP2 = sP34;
		}
		
		if (tS1 < 1) {
		// Trim end of curve
			
			// front of cornea
			var sq1 = new ED.Point(0,0);
			sq1.y = (1-tS1)*(1-tS1)*(1-tS1)*inferiorBezier.SP.y + 3*(1-tS1)*(1-tS1)*tS1*inferiorBezier.CP1.y + 3*(1-tS1)*tS1*tS1*inferiorBezier.CP2.y + tS1*tS1*tS1*inferiorBezier.EP.y;
			sq1.x = (1-tS1)*(1-tS1)*(1-tS1)*inferiorBezier.SP.x + 3*(1-tS1)*(1-tS1)*tS1*inferiorBezier.CP1.x + 3*(1-tS1)*tS1*tS1*inferiorBezier.CP2.x + tS1*tS1*tS1*inferiorBezier.EP.x;

			var sP12 = new ED.Point(0,0);
			sP12.x = inferiorBezier.SP.x + tS1 * (inferiorBezier.CP1.x - inferiorBezier.SP.x);
			sP12.y = inferiorBezier.SP.y + tS1 * (inferiorBezier.CP1.y - inferiorBezier.SP.y);
			
			var sP23 = new ED.Point(0,0);
			sP23.x = inferiorBezier.CP1.x + tS1 * (inferiorBezier.CP2.x - inferiorBezier.CP1.x);
			sP23.y = inferiorBezier.CP1.y + tS1 * (inferiorBezier.CP2.y - inferiorBezier.CP1.y);
			
			var sP1223 = new ED.Point(0,0);
			sP1223.x = sP12.x + tS1 * (sP23.x - sP12.x);
			sP1223.y = sP12.y + tS1 * (sP23.y - sP12.y);

			inferiorBezier.CP1 = sP12;
			inferiorBezier.CP2 = sP1223;
			inferiorBezier.EP = sq1;
		}
	}
	
	if (inferiorBezier) {
		ctx.moveTo(inferiorBezier.SP.x, inferiorBezier.SP.y);
		ctx.bezierCurveTo(inferiorBezier.CP1.x, inferiorBezier.CP1.y, inferiorBezier.CP2.x, inferiorBezier.CP2.y, inferiorBezier.EP.x, inferiorBezier.EP.y);
	}
	if (superiorBezier) {
		ctx.moveTo(superiorBezier.SP.x, superiorBezier.SP.y);
		ctx.bezierCurveTo(superiorBezier.CP1.x, superiorBezier.CP1.y, superiorBezier.CP2.x, superiorBezier.CP2.y, superiorBezier.EP.x, superiorBezier.EP.y);
	}
	
	
	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 0;
	ctx.strokeStyle = "rgba(0,0,0,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
		
	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {

		var dr = 8 * ((this.apexX + 20) / 20) / this.scaleX;		
		var n = 4 + Math.abs(Math.floor(this.apexY / 8));
		
		var bezier;
		var p = new ED.Point(0, 0);
		var tP;
		var o = new ED.Point(0, 0);
		var angle;

		for (var i = 0; i < n; i++) {
			// random point in time
			tP = ED.randomArray[i+100];
			
			// set bezier appropriate for time point
			if (-r + this.h * 2 * tP + this.originY>0) bezier = inferiorBezier;
			else bezier = superiorBezier;
			
			// time along current bezier
			tP = (tP<=0.5) ? tP * 2 : (tP-0.5) * 2;
			
			// set point on bezier
			p.x = dr*0.5 + (1-tP)*(1-tP)*(1-tP)*bezier.SP.x + 3*(1-tP)*(1-tP)*tP*bezier.CP1.x + 3*(1-tP)*tP*tP*bezier.CP2.x + tP*tP*tP*bezier.EP.x;
			p.y = (1-tP)*(1-tP)*(1-tP)*bezier.SP.y + 3*(1-tP)*(1-tP)*tP*bezier.CP1.y + 3*(1-tP)*tP*tP*bezier.CP2.y + tP*tP*tP*bezier.EP.y;
			
			angle = p.direction() + 0.5*Math.PI;
						
			// draw spot
			this.drawOval(ctx, p.x, p.y, dr, angle);
		}
	}
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
	
}



/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * AngleGradeEast
 *
 * @class AngleGradeEast
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AngleGradeEast = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AngleGradeEast";

	// Private parameters
	this.rsl = 480;
	this.rsli = 470;
	this.rtmo = 404;
	this.rtmi = 304;
	this.rcbo = 270;
	this.rcbi = 190;
	this.riro = 190;
	this.riri = 176;
	this.rpu = 100;

	// Derived parameters
	this.grade = "4";
	this.seen = "Yes";

	// Saved parameters
	this.savedParameterArray = ['apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

	// Invariant simple parameters
	this.arc = 90 * Math.PI / 180;
	this.rotation = Math.PI / 2;
}

/**
 * Sets superclass and constructor
 */
ED.AngleGradeEast.prototype = new ED.Doodle;
ED.AngleGradeEast.prototype.constructor = ED.AngleGradeEast;
ED.AngleGradeEast.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AngleGradeEast.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.AngleGradeEast.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.125, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.125, +1.5);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-this.rsli, -this.riri);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['grade'] = {
		kind: 'derived',
		type: 'string',
		list: ['4', '3', '2', '1', '0'],
		animate: true
	};
	this.parameterValidationArray['seen'] = {
		kind: 'derived',
		type: 'string',
		list: ['Yes', 'No'],
		animate: true
	};
}

/**
 * Sets default parameters
 */
ED.AngleGradeEast.prototype.setParameterDefaults = function() {
	this.apexY = -this.riri;
	this.setParameterFromString('grade', '4');
	this.setParameterFromString('seen', 'Yes');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.AngleGradeEast.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			// Return value uses Schaffer classificaton (although visibility is based on Scheie)
			var returnValue = "4";
			if (-_value >= this.riro) returnValue = "3";
			if (-_value >= this.rcbo) returnValue = "2";
			if (-_value >= this.rtmo) returnValue = "1";
			if (-_value >= this.rsli) returnValue = "0";
			returnArray['grade'] = returnValue;
			returnArray['seen'] = (-_value >= this.rtmo) ? 'No' : 'Yes';
			break;

		case 'grade':
			var returnValue = "";
			switch (_value) {
				case '0':
					if (-this.apexY >= this.rsli) returnValue = this.apexY;
					else returnValue = -this.rsli;
					break;
				case '1':
					if (-this.apexY >= this.rtmo && -this.apexY < this.rsli) returnValue = this.apexY;
					else returnValue = -this.rtmo;
					break;
				case '2':
					if (-this.apexY >= this.rcbo && -this.apexY < this.rtmo) returnValue = this.apexY;
					else returnValue = -360; //-this.rcbo;
					break;
				case '3':
					if (-this.apexY >= this.riro && -this.apexY < this.rcbo) returnValue = this.apexY;
					else returnValue = -230; //-this.riro;
					break;
				case '4':
					if (-this.apexY >= this.riri && -this.apexY < this.riro) returnValue = this.apexY;
					else returnValue = -this.riri;
					break;
			}
			returnArray['apexY'] = returnValue;
			break;

		case 'seen':
			var returnValue = "";
			switch (_value) {
				case 'No':
					if (-this.apexY >= this.rtmo) returnValue = this.apexY;
					else returnValue = -this.rtmo;
					break;
				case 'Yes':
					if (-this.apexY < this.rtmo) returnValue = this.apexY;
					else returnValue = -this.riri;
					break;
			}
			returnArray['apexY'] = returnValue;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AngleGradeEast.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AngleGradeEast.superclass.draw.call(this, _point);

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Boundary path
	ctx.beginPath();

	// Arc across, move to inner and arc back
	ctx.arc(0, 0, -this.apexY, arcStart, arcEnd, true);
	ctx.arc(0, 0, this.rpu, arcEnd, arcStart, false);
	ctx.closePath();

	// Set fill attributes (same colour as Iris)
	ctx.fillStyle = "rgba(100, 200, 250, 1.0)";
	ctx.strokeStyle = "rgba(100, 100, 100, 1.0)";
	ctx.lineWidth = 4;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * AngleGradeNorth
 *
 * @class AngleGradeNorth
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AngleGradeNorth = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AngleGradeNorth";

	// Private parameters
	this.rsl = 480;
	this.rsli = 470;
	this.rtmo = 404;
	this.rtmi = 304;
	this.rcbo = 270;
	this.rcbi = 190;
	this.riro = 190;
	this.riri = 176;
	this.rpu = 100;

	// Derived parameters
	this.grade = "4";
	this.seen = "Yes";

	// Saved parameters
	this.savedParameterArray = ['apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

	// Invariant simple parameters
	this.arc = 90 * Math.PI / 180;
	this.rotation = 0;
}

/**
 * Sets superclass and constructor
 */
ED.AngleGradeNorth.prototype = new ED.Doodle;
ED.AngleGradeNorth.prototype.constructor = ED.AngleGradeNorth;
ED.AngleGradeNorth.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AngleGradeNorth.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.AngleGradeNorth.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.125, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.125, +1.5);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-this.rsli, -this.riri);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['grade'] = {
		kind: 'derived',
		type: 'string',
		list: ['4', '3', '2', '1', '0'],
		animate: true
	};
	this.parameterValidationArray['seen'] = {
		kind: 'derived',
		type: 'string',
		list: ['Yes', 'No'],
		animate: true
	};
}

/**
 * Sets default parameters
 */
ED.AngleGradeNorth.prototype.setParameterDefaults = function() {
	this.apexY = -this.riri;
	this.setParameterFromString('grade', '4');
	this.setParameterFromString('seen', 'Yes');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.AngleGradeNorth.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			// Return value uses Schaffer classificaton (although visibility is based on Scheie)
			var returnValue = "4";
			if (-_value >= this.riro) returnValue = "3";
			if (-_value >= this.rcbo) returnValue = "2";
			if (-_value >= this.rtmo) returnValue = "1";
			if (-_value >= this.rsli) returnValue = "0";
			returnArray['grade'] = returnValue;
			returnArray['seen'] = (-_value >= this.rtmo) ? 'No' : 'Yes';
			break;

		case 'grade':
			var returnValue = "";
			switch (_value) {
				case '0':
					if (-this.apexY >= this.rsli) returnValue = this.apexY;
					else returnValue = -this.rsli;
					break;
				case '1':
					if (-this.apexY >= this.rtmo && -this.apexY < this.rsli) returnValue = this.apexY;
					else returnValue = -this.rtmo;
					break;
				case '2':
					if (-this.apexY >= this.rcbo && -this.apexY < this.rtmo) returnValue = this.apexY;
					else returnValue = -360; //-this.rcbo;
					break;
				case '3':
					if (-this.apexY >= this.riro && -this.apexY < this.rcbo) returnValue = this.apexY;
					else returnValue = -230; //-this.riro;
					break;
				case '4':
					if (-this.apexY >= this.riri && -this.apexY < this.riro) returnValue = this.apexY;
					else returnValue = -this.riri;
					break;
			}
			returnArray['apexY'] = returnValue;
			break;

		case 'seen':
			var returnValue = "";
			switch (_value) {
				case 'No':
					if (-this.apexY >= this.rtmo) returnValue = this.apexY;
					else returnValue = -this.rtmo;
					break;
				case 'Yes':
					if (-this.apexY < this.rtmo) returnValue = this.apexY;
					else returnValue = -this.riri;
					break;
			}
			returnArray['apexY'] = returnValue;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AngleGradeNorth.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AngleGradeNorth.superclass.draw.call(this, _point);

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Boundary path
	ctx.beginPath();

	// Arc across, move to inner and arc back
	ctx.arc(0, 0, -this.apexY, arcStart, arcEnd, true);
	ctx.arc(0, 0, this.rpu, arcEnd, arcStart, false);
	ctx.closePath();

	// Set fill attributes (same colour as Iris)
	ctx.fillStyle = "rgba(100, 200, 250, 1.0)";
	ctx.strokeStyle = "rgba(100, 100, 100, 1.0)";
	ctx.lineWidth = 4;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * AngleGradeSouth
 *
 * @class AngleGradeSouth
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AngleGradeSouth = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AngleGradeSouth";

	// Private parameters
	this.rsl = 480;
	this.rsli = 470;
	this.rtmo = 404;
	this.rtmi = 304;
	this.rcbo = 270;
	this.rcbi = 190;
	this.riro = 190;
	this.riri = 176;
	this.rpu = 100;

	// Derived parameters
	this.grade = "4";
	this.seen = "Yes";

	// Saved parameters
	this.savedParameterArray = ['apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

	// Invariant simple parameters
	this.arc = 90 * Math.PI / 180;
	this.rotation = Math.PI;
}

/**
 * Sets superclass and constructor
 */
ED.AngleGradeSouth.prototype = new ED.Doodle;
ED.AngleGradeSouth.prototype.constructor = ED.AngleGradeSouth;
ED.AngleGradeSouth.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AngleGradeSouth.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.AngleGradeSouth.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.125, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.125, +1.5);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-this.rsli, -this.riri);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['grade'] = {
		kind: 'derived',
		type: 'string',
		list: ['4', '3', '2', '1', '0'],
		animate: true
	};
	this.parameterValidationArray['seen'] = {
		kind: 'derived',
		type: 'string',
		list: ['Yes', 'No'],
		animate: true
	};
}

/**
 * Sets default parameters
 */
ED.AngleGradeSouth.prototype.setParameterDefaults = function() {
	this.apexY = -this.riri;
	this.setParameterFromString('grade', '4');
	this.setParameterFromString('seen', 'Yes');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.AngleGradeSouth.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			// Return value uses Schaffer classificaton (although visibility is based on Scheie)
			var returnValue = "4";
			if (-_value >= this.riro) returnValue = "3";
			if (-_value >= this.rcbo) returnValue = "2";
			if (-_value >= this.rtmo) returnValue = "1";
			if (-_value >= this.rsli) returnValue = "0";
			returnArray['grade'] = returnValue;
			returnArray['seen'] = (-_value >= this.rtmo) ? 'No' : 'Yes';
			break;

		case 'grade':
			var returnValue = "";
			switch (_value) {
				case '0':
					if (-this.apexY >= this.rsli) returnValue = this.apexY;
					else returnValue = -this.rsli;
					break;
				case '1':
					if (-this.apexY >= this.rtmo && -this.apexY < this.rsli) returnValue = this.apexY;
					else returnValue = -this.rtmo;
					break;
				case '2':
					if (-this.apexY >= this.rcbo && -this.apexY < this.rtmo) returnValue = this.apexY;
					else returnValue = -360; //-this.rcbo;
					break;
				case '3':
					if (-this.apexY >= this.riro && -this.apexY < this.rcbo) returnValue = this.apexY;
					else returnValue = -230; //-this.riro;
					break;
				case '4':
					if (-this.apexY >= this.riri && -this.apexY < this.riro) returnValue = this.apexY;
					else returnValue = -this.riri;
					break;
			}
			returnArray['apexY'] = returnValue;
			break;

		case 'seen':
			var returnValue = "";
			switch (_value) {
				case 'No':
					if (-this.apexY >= this.rtmo) returnValue = this.apexY;
					else returnValue = -this.rtmo;
					break;
				case 'Yes':
					if (-this.apexY < this.rtmo) returnValue = this.apexY;
					else returnValue = -this.riri;
					break;
			}
			returnArray['apexY'] = returnValue;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AngleGradeSouth.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AngleGradeSouth.superclass.draw.call(this, _point);

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Boundary path
	ctx.beginPath();

	// Arc across, move to inner and arc back
	ctx.arc(0, 0, -this.apexY, arcStart, arcEnd, true);
	ctx.arc(0, 0, this.rpu, arcEnd, arcStart, false);
	ctx.closePath();

	// Set fill attributes (same colour as Iris)
	ctx.fillStyle = "rgba(100, 200, 250, 1.0)";
	ctx.strokeStyle = "rgba(100, 100, 100, 1.0)";
	ctx.lineWidth = 4;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * AngleGradeWest
 *
 * @class AngleGradeWest
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AngleGradeWest = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AngleGradeWest";

	// Private parameters
	this.rsl = 480;
	this.rsli = 470;
	this.rtmo = 404;
	this.rtmi = 304;
	this.rcbo = 270;
	this.rcbi = 190;
	this.riro = 190;
	this.riri = 176;
	this.rpu = 100;

	// Derived parameters
	this.grade = "4";
	this.seen = "Yes";

	// Saved parameters
	this.savedParameterArray = ['apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

	// Invariant simple parameters
	this.arc = 90 * Math.PI / 180;
	this.rotation = 3 * Math.PI / 2;
}

/**
 * Sets superclass and constructor
 */
ED.AngleGradeWest.prototype = new ED.Doodle;
ED.AngleGradeWest.prototype.constructor = ED.AngleGradeWest;
ED.AngleGradeWest.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AngleGradeWest.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.AngleGradeWest.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.125, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.125, +1.5);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-this.rsli, -this.riri);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['grade'] = {
		kind: 'derived',
		type: 'string',
		list: ['4', '3', '2', '1', '0'],
		animate: true
	};
	this.parameterValidationArray['seen'] = {
		kind: 'derived',
		type: 'string',
		list: ['Yes', 'No'],
		animate: true
	};
}

/**
 * Sets default parameters
 */
ED.AngleGradeWest.prototype.setParameterDefaults = function() {
	this.apexY = -this.riri;
	this.setParameterFromString('grade', '4');
	this.setParameterFromString('seen', 'Yes');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.AngleGradeWest.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			// Return value uses Schaffer classificaton (although visibility is based on Scheie)
			var returnValue = "4";
			if (-_value >= this.riro) returnValue = "3";
			if (-_value >= this.rcbo) returnValue = "2";
			if (-_value >= this.rtmo) returnValue = "1";
			if (-_value >= this.rsli) returnValue = "0";
			returnArray['grade'] = returnValue;
			returnArray['seen'] = (-_value >= this.rtmo) ? 'No' : 'Yes';
			break;

		case 'grade':
			var returnValue = "";
			switch (_value) {
				case '0':
					if (-this.apexY >= this.rsli) returnValue = this.apexY;
					else returnValue = -this.rsli;
					break;
				case '1':
					if (-this.apexY >= this.rtmo && -this.apexY < this.rsli) returnValue = this.apexY;
					else returnValue = -this.rtmo;
					break;
				case '2':
					if (-this.apexY >= this.rcbo && -this.apexY < this.rtmo) returnValue = this.apexY;
					else returnValue = -360; //-this.rcbo;
					break;
				case '3':
					if (-this.apexY >= this.riro && -this.apexY < this.rcbo) returnValue = this.apexY;
					else returnValue = -230; //-this.riro;
					break;
				case '4':
					if (-this.apexY >= this.riri && -this.apexY < this.riro) returnValue = this.apexY;
					else returnValue = -this.riri;
					break;
			}
			returnArray['apexY'] = returnValue;
			break;

		case 'seen':
			var returnValue = "";
			switch (_value) {
				case 'No':
					if (-this.apexY >= this.rtmo) returnValue = this.apexY;
					else returnValue = -this.rtmo;
					break;
				case 'Yes':
					if (-this.apexY < this.rtmo) returnValue = this.apexY;
					else returnValue = -this.riri;
					break;
			}
			returnArray['apexY'] = returnValue;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AngleGradeWest.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AngleGradeWest.superclass.draw.call(this, _point);

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Boundary path
	ctx.beginPath();

	// Arc across, move to inner and arc back
	ctx.arc(0, 0, -this.apexY, arcStart, arcEnd, true);
	ctx.arc(0, 0, this.rpu, arcEnd, arcStart, false);
	ctx.closePath();

	// Set fill attributes (same colour as Iris)
	ctx.fillStyle = "rgba(100, 200, 250, 1.0)";
	ctx.strokeStyle = "rgba(100, 100, 100, 1.0)";
	ctx.lineWidth = 4;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Angle New Vessels
 *
 * @class AngleNV
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AngleNV = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AngleNV";

	// Private parameters
	this.rtmo = 404;
	this.rtmi = 304;

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.AngleNV.prototype = new ED.Doodle;
ED.AngleNV.prototype.constructor = ED.AngleNV;
ED.AngleNV.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AngleNV.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Sets default dragging attributes
 */
ED.AngleNV.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.125, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.125, +1.5);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(+50, +250);
}

/**
 * Sets default parameters
 */
ED.AngleNV.prototype.setParameterDefaults = function() {
	this.arc = 30 * Math.PI / 180;
	this.setRotationWithDisplacements(0, -60);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AngleNV.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AngleNV.superclass.draw.call(this, _point);

	// AngleNV is at equator
	var ras = this.rtmo;
	this.rir = this.rtmi;
	var r = this.rir + (ras - this.rir) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of AngleNV
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Path
	ctx.arc(0, 0, this.rir, arcStart, arcEnd, true);
	ctx.arc(0, 0, ras, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// create pattern
	var ptrn = ctx.createPattern(this.drawing.imageArray['NewVesselPattern'], 'repeat');
	ctx.fillStyle = ptrn;
	ctx.strokeStyle = "rgba(255, 255, 255, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.AngleNV.prototype.groupDescription = function() {
	// Calculate total extent in degrees
	var degrees = this.drawing.totalDegreesExtent(this.className);

	// Return string
	return "Angle new vessels over " + degrees.toString() + " degrees";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Angle Recession
 *
 * @class AngleRecession
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AngleRecession = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AngleRecession";

	// Private parameters
	this.riri = 176;

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.AngleRecession.prototype = new ED.Doodle;
ED.AngleRecession.prototype.constructor = ED.AngleRecession;
ED.AngleRecession.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AngleRecession.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Sets default dragging attributes
 */
ED.AngleRecession.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(+50, +250);
}

/**
 * Sets default parameters
 */
ED.AngleRecession.prototype.setParameterDefaults = function() {
	this.arc = 30 * Math.PI / 180;
	this.setRotationWithDisplacements(0, -60);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AngleRecession.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AngleRecession.superclass.draw.call(this, _point);

	// AngleRecession is at equator
	var ras = this.riri - 30;
	this.rir = this.riri;
	var r = this.rir + (ras - this.rir) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;
	var outArcStart = -Math.PI / 2 + theta - Math.PI / 24;
	var outArcEnd = -Math.PI / 2 - theta + Math.PI / 24;

	// Coordinates of 'corners' of AngleRecession
	var topRightX = this.rir * Math.sin(theta);
	var topRightY = -this.rir * Math.cos(theta);
	var topLeftX = -this.rir * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Path
	ctx.arc(0, 0, this.rir, arcStart, arcEnd, true);
	ctx.arc(0, 0, ras, outArcEnd, outArcStart, false);

	// Close path
	ctx.closePath();

	ctx.fillStyle = "rgba(255, 255, 200, 1.0)";
	ctx.strokeStyle = "rgba(255, 255, 255, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.AngleRecession.prototype.groupDescription = function() {
	// Calculate total extent in degrees
	var degrees = this.drawing.totalDegreesExtent(this.className);

	// Return string
	return "Angle recession over " + degrees.toString() + " degrees";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Anterior capsulotomy ***TODO***
 *
 * @class AnteriorCapsulotomy
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AnteriorCapsulotomy = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AnteriorCapsulotomy";

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.AnteriorCapsulotomy.prototype = new ED.Doodle;
ED.AnteriorCapsulotomy.prototype.constructor = ED.AnteriorCapsulotomy;
ED.AnteriorCapsulotomy.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.AnteriorCapsulotomy.prototype.setPropertyDefaults = function() {
	this.isUnique = true;
	this.addAtBack = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-500, +500);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-500, +500);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.AnteriorCapsulotomy.prototype.setParameterDefaults = function() {}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AnteriorCapsulotomy.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AnteriorCapsulotomy.superclass.draw.call(this, _point);

	// Height of cross section (half value of ro in AntSeg doodle)
	var ro = 240;

	// Boundary path
	ctx.beginPath();

	// Do a 360 arc
	ctx.arc(0, 0, ro, 0, 2 * Math.PI, true);

	// Move to inner circle
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		var ri = ro - 60;

		// Edge of nucleus
		ctx.beginPath();
		ctx.arc(0, 0, ri, 0, 2 * Math.PI, true);
		ctx.strokeStyle = "rgba(220, 220, 220, 0.75)";
		ctx.stroke();
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Anterior PVR
 *
 * @class AntPVR
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AntPVR = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AntPVR";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.AntPVR.prototype = new ED.Doodle;
ED.AntPVR.prototype.constructor = ED.AntPVR;
ED.AntPVR.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AntPVR.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.AntPVR.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-400, -300);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.25, +4);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.25, +4);
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 6, Math.PI * 2);
}


/**
 * Sets default parameters
 */
ED.AntPVR.prototype.setParameterDefaults = function() {
	this.arc = 120 * Math.PI / 180;
	this.apexY = -400;
	this.setRotationWithDisplacements(180, 120);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AntPVR.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AntPVR.superclass.draw.call(this, _point);

	// Radius of outer curve just inside ora on right and left fundus diagrams
	var ro = 952 / 2;
	var ri = -this.apexY;
	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of lattice
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	var ptrn = ctx.createPattern(this.drawing.imageArray['AntPVRPattern'], 'repeat');
	ctx.fillStyle = ptrn;
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.AntPVR.prototype.description = function() {
    return "PVR (anterior) " + this.clockHourExtent("o'clock");
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.AntPVR.prototype.snomedCode = function() {
	return 232017001;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.AntPVR.prototype.diagnosticHierarchy = function() {
	return 2;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Anterior segment with adjustable sized pupil
 *
 * @class AntSeg
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AntSeg = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AntSeg";

	// Derived parameters
	this.pupilSize = 'Large';

	// Other parameters
	this.pxe = false;
	this.coloboma = false;
	this.colour = 'Blue';
	this.ectropion = false;
	this.cornealSize = 'Normal';
	this.cells = 'Not Checked';
	this.flare = 'Not Checked';
	this.csApexX = 0;

	// Saved parameters
	this.savedParameterArray = [
		'pupilSize',
		'apexY',
		'rotation',
		'pxe',
		'coloboma',
		'colour',
		'ectropion',
		'cornealSize',
		'cells',
		'flare',
		'csApexX' // store of cross section apex x value
	];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {
		'pupilSize':'Pupil size',
		'pxe':'Pseudoexfoliation',
		'coloboma':'Coloboma',
		'colour':'Colour',
		'ectropion':'Ectropion uveae',
		'cornealSize':'Corneal size',
		'cells': 'Cells',
		'flare': 'Flare'
	};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
};

/**
 * Sets superclass and constructor
 */
ED.AntSeg.prototype = new ED.Doodle();
ED.AntSeg.prototype.constructor = ED.AntSeg;
ED.AntSeg.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AntSeg.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
};

/**
 * Set default properties
 */
ED.AntSeg.prototype.setPropertyDefaults = function() {
	this.version = 1.1;
	this.isDeletable = false;
	this.isMoveable = false;
	this.isRotatable = true;
	this.isUnique = true;

	// Update component of validation array for simple parameters (enable 2D control by adding -50,+50 apexX range
	this.parameterValidationArray.apexX.range.setMinAndMax(0, 0);
	this.parameterValidationArray.apexY.range.setMinAndMax(-300, -60);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray.pupilSize = {
		kind: 'derived',
		type: 'string',
		list: ['Large', 'Medium', 'Small'],
		animate: true
	};

	this.parameterValidationArray.pxe = {
		kind: 'derived',
		type: 'bool',
		display: true
	};

	this.parameterValidationArray.coloboma = {
		kind: 'derived',
		type: 'bool',
		display: true
	};

	this.parameterValidationArray.colour = {
		kind: 'other',
		type: 'string',
		list: ['Blue', 'Brown', 'Gray', 'Green'],
		animate: false
	};

	this.parameterValidationArray.ectropion = {
		kind: 'derived',
		type: 'bool',
		display: true
	};

	this.parameterValidationArray.cornealSize = {
		kind: 'other',
		type: 'string',
		list: ['Micro', 'Normal', 'Macro'],
		animate: false
	};

	this.parameterValidationArray.cells = {
		kind: 'other',
		type: 'string',
		list: ['Not Checked', '0 (<1)', '0.5+ (1-5)', '1+ (6-15)', '2+ (16-25)', '3+ (26-50)', '4+ (>50)'],
		animate: false
	};

	this.parameterValidationArray.flare = {
		kind: 'other',
		type: 'string',
		list: ['Not Checked', '0 (None)', '1+ (Faint)', '2+ (Moderate)', '3+ (Marked)', '4+ (Intense)'],
		animate: false
	};
};

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.AntSeg.prototype.setParameterDefaults = function() {
	this.setParameterFromString('pupilSize', 'Large');
	this.setParameterFromString('pxe', 'false');
	this.setParameterFromString('cornealSize', 'Normal');
};

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @param {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.AntSeg.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = {},
		returnValue;

	switch (_parameter) {
		case 'apexY':
			if (_value < -200) {
			  returnArray.pupilSize = 'Large';
      } else if (_value < -100) {
			  returnArray.pupilSize = 'Medium';
      } else {
			  returnArray.pupilSize = 'Small';
      }
			break;

		case 'pupilSize':
			switch (_value) {
				case 'Large':
					if (this.apexY < -200) {
					  returnValue = this.apexY;
          } else {
					  returnArray.apexY = -260;
          }
					break;
				case 'Medium':
					if (this.apexY >= -200 && this.apexY < -100) {
						returnValue = this.apexY;
					} else {
						returnArray.apexY = -200;
					}
					break;
				case 'Small':
					if (this.apexY >= -100) {
						returnValue = this.apexY;
					} else {
						returnArray.apexY = -100;
					}
					break;
			}
			break;
		case 'coloboma':
			this.isRotatable = (_value === "true");
			this.rotation = _value === "true" ? this.rotation : 0;
			break;
	}

	return returnArray;
};

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AntSeg.prototype.draw = function(_point) {

	// Get context
	var ctx = this.drawing.context;
	var colAngle;
	var colAngleOuter;
	var rimSize;
	var p1;
	var p2;

	// Call draw method in superclass
	ED.AntSeg.superclass.draw.call(this, _point);

	// Radius of limbus
	var ro = 380;
	var ri = -this.apexY;

	// Calculate parameters for arcs
	var arcStart = 0;
	var arcEnd = 2 * Math.PI;

	// Boundary path
	ctx.beginPath();

	// Do a 360 arc
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	if (!this.coloboma) {
		// Move to inner circle
		ctx.moveTo(ri, 0);

		// Arc round edge of pupil
		ctx.arc(0, 0, ri, arcEnd, arcStart, false);
	}
	else {
		// Angular size of coloboma
		colAngle = (Math.PI/3) * 280/ri;
		colAngleOuter = Math.PI/6;
		rimSize = 20;

		p1 = new ED.Point(0,0);
		p1.setWithPolars(ri, Math.PI + colAngle/2);
		p2 = new ED.Point(0,0);
		p2.setWithPolars(ro - rimSize, Math.PI + colAngleOuter/2);

		// Coloboma
		ctx.moveTo(-p2.x, p2.y);
		ctx.arc(0, 0, ro - rimSize, Math.PI/2 - colAngleOuter/2, Math.PI/2 + colAngleOuter/2, false);

		// Arc round edge of pupil
		ctx.arc(0, 0, ri, Math.PI/2 + colAngle/2, Math.PI/2 - colAngle/2, false);

		// Back to start
		ctx.lineTo(-p2.x, p2.y);
	}

	// Edge attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "gray";

	// Iris colour
	switch (this.colour) {
		case 'Blue':
			ctx.fillStyle = "rgba(100, 200, 250, 0.5)";
			break;
		case 'Brown':
			ctx.fillStyle = "rgba(172, 100, 55, 0.5)";
			break;
		case 'Gray':
			ctx.fillStyle = "rgba(125, 132, 116, 0.5)";
			break;
		case 'Green':
			ctx.fillStyle = "rgba(114, 172, 62, 0.5)";
			break;
	}

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode === ED.drawFunctionMode.Draw) {
		// Pseudo exfoliation
		if (this.pxe) {
			ctx.lineWidth = 8;
			ctx.strokeStyle = "darkgray";

			var rl = ri * 0.8;
			var rp = ri * 1.05;
			var segments = 36;
			var i;
			var phi = Math.PI * 2 / segments;

			// Loop around alternating segments
			for (i = 0; i < segments; i++) {
				// PXE on lens
				ctx.beginPath();
				ctx.arc(0, 0, rl, i * phi, i * phi + phi / 2, false);
				ctx.stroke();

				// PXE on pupil
				ctx.beginPath();
				ctx.arc(0, 0, rp, i * phi, i * phi + phi / 2, false);
				ctx.stroke();
			}
		}

		// Ectropion uveae
		if (this.ectropion) {
			ctx.beginPath();
			if (this.coloboma) {
				ctx.arc(0, 0, ri, Math.PI/2 - colAngle/2, Math.PI/2 + colAngle/2, true);
			}
			else {
				ctx.arc(0, 0, ri + 16, arcStart, arcEnd, true);
			}
			ctx.lineWidth = 32;
			ctx.lineCap = "round";
			ctx.strokeStyle = "brown";
			ctx.stroke();
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) {
		this.drawHandles(_point);
	}

	// Return value indicating successful hit test
	return this.isClicked;
};

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.AntSeg.prototype.description = function() {
	var returnValue = "";
	var pupilSize = Math.round(-this.apexY * 0.03);

	// Pupil size and coloboma
	returnValue += this.pupilSize.toLowerCase() + " pupil (diameter: " + pupilSize + "mm), ";

	// Coloboma
	if (this.coloboma) {
		returnValue += "coloboma at " + this.clockHour(6) + " o'clock, ";
	}

	// Ectopion
	if (this.ectropion) {
		returnValue += "ectropion uveae, ";
	}

	// PXE
	if (this.pxe) {
		returnValue += "pseudoexfoliation, ";
	}

	if (this.cells && this.cells !== 'Not Checked') {
		returnValue += "cells: " + this.cells + ", ";
	}

	if (this.flare && this.flare !== 'Not Checked') {
		returnValue += "flare: " + this.flare + ", ";
	}

	// Empty report so far
	if (returnValue.length === 0 && this.drawing.doodleArray.length === 1) {
		// Is lens present and normal?
		/*
		var doodle = this.drawing.lastDoodleOfClass('Lens');
		if (doodle) {
			var lensDescription = doodle.description();
			if (lensDescription.length == 0) {
				returnValue = "Anterior segment normal, ";
			}
		}
		else {
			returnValue = "Aphakic, ";
		}
		*/
		returnValue = "No abnormality";
	}

/*
	if (this.pupilSize == 'Large') {
		returnValue += "pupil diameter: " + pupilSize + "mm, ";
	}
*/

	// Remove final comma and space and capitalise first letter
	returnValue = returnValue.replace(/, +$/, '');
	returnValue = returnValue.charAt(0).toUpperCase() + returnValue.slice(1);

	return returnValue;
};

ED.AntSeg.prototype.snomedCodes = function()
{
    snomedCodes = [];
    if (this.pxe) {
        snomedCodes.push([44219007, 3]);
    }
    return snomedCodes;
};

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 *
 *
 * @class AntSegAngleMarks
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AntSegAngleMarks = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AntSegAngleMarks";

	
	// Saved parameters
	this.savedParameterArray = [];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.AntSegAngleMarks.prototype = new ED.Doodle;
ED.AntSegAngleMarks.prototype.constructor = ED.AntSegAngleMarks;
ED.AntSegAngleMarks.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.AntSegAngleMarks.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
	this.addAtBack = true;
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.AntSegAngleMarks.prototype.setParameterDefaults = function() {
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.AntSegAngleMarks.prototype.dependentParameterValues = function(_parameter, _value) {
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AntSegAngleMarks.prototype.draw = function(_point) {
	
	// Axis length
	var l = 499;
	
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AntSegAngleMarks.superclass.draw.call(this, _point);
	
	// Draw invisible boundary box around canvas
	ctx.moveTo(-l,-l);
	ctx.lineTo(-l,l);
	ctx.lineTo(l,l);
	ctx.lineTo(l,-l);
	ctx.lineTo(-l,-l);
	
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "rgba(0,0,0,0)"
	
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();
		
		// Set style defaults
		ctx.font="36px Arial";
		ctx.fillStyle="black";
		ctx.textAlign="center"; 
		ctx.textBaseline = "middle";
		ctx.lineWidth = 3;
		ctx.strokeStyle = "black";
		
		// Number of tick marks
		var n = 8;
		
		// Distance of tick marks from origin
		var r = 400;
		
		// Length of single tick mark
		var d = 25;
		
		var point1 = new ED.Point(0,0);
		var point2 = new ED.Point(0,0);
		var point3 = new ED.Point(0,0);
		for (var i=0; i<n; i++) {
			var angleRad = 2*Math.PI / n * i;
			var angleDeg = angleRad * 180 / Math.PI;
			
			point1.setWithPolars(r, 2 * Math.PI - angleRad + 0.5*Math.PI);
			point2.setWithPolars(r+d, 2 * Math.PI - angleRad + 0.5*Math.PI);
			point3.setWithPolars(r+d*2.5,2 * Math.PI - angleRad + 0.5*Math.PI);
			
			ctx.moveTo(point1.x, point1.y);
			ctx.lineTo(point2.x, point2.y);
			ctx.fillText(angleDeg + "\xB0",point3.x,point3.y);
		}
		
/*
		ctx.moveTo(-500,0);
		ctx.lineTo(500,0);
*/
		
		ctx.stroke();
		
		
		
		// If toric lens exists, draw flat axis
		var toricLens = this.drawing.lastDoodleOfClass('ToricPCIOL');
		if (toricLens) {
			var phi = 0.7 * Math.PI / 4;
			var axisRotation = toricLens.rotation + phi - 0.5077 * Math.PI;
			
			ctx.beginPath();
			ctx.save();
			ctx.rotate(axisRotation);
			
			ctx.strokeStyle = "blue";
			ctx.lineWidth = 8;
			
			var w = 420;
			var z = Math.round(2 * w / (d*2));
			for (var j=0; j<z; j++) {
				ctx.moveTo(-w + j*d*2, 0);
				ctx.lineTo(-w + j*d*2 + d, 0);
			};
/*
			ctx.moveTo(-w, 0);
			ctx.lineTo(w,0);
*/
			ctx.stroke();
			ctx.restore();
		}		
		
	}

	// Return value indicating successful hittest
	return this.isClicked;
}



/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */


/**
 * Anterior Segment Cross Section ***TODO***
 *
 * @class AntSegCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AntSegCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AntSegCrossSection";

	// Derived parameters
	this.pupilSize = 'Large';

	this.colour = 'Blue';
    
	// Saved parameters
	this.savedParameterArray = ['apexY', 'apexX','colour','c'];

    // Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

  	this.linkedDoodleParameters = {
    	'AntSeg': {
      		source: ['apexY', 'colour'],
      		store: [['apexX', 'csApexX']]
    	}
  	};

	// Invariant simple parameters
	this.originX = 44;
}

/**
 * Sets superclass and constructor
 */
ED.AntSegCrossSection.prototype = new ED.Doodle;
ED.AntSegCrossSection.prototype.constructor = ED.AntSegCrossSection;
ED.AntSegCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AntSegCrossSection.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.AntSegCrossSection.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	//this.parameterValidationArray['apexX']['range'].setMinAndMax(-140, 0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-280, -60);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['pupilSize'] = {
		kind: 'derived',
		type: 'string',
		list: ['Large', 'Medium', 'Small'],
		animate: true
	};
	
	this.parameterValidationArray['c'] = {
		kind: 'other',
		type: 'int',
		animate: false
	};
	
	this.parameterValidationArray.colour = {
		kind: 'other',
		type: 'string',
		list: ['Blue', 'Brown', 'Gray', 'Green'],
		animate: false
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.AntSegCrossSection.prototype.setParameterDefaults = function() {
	this.setParameterFromString('pupilSize', 'Large');
	this.setParameterFromString('c', '1');
	this.apexX = 24;
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.AntSegCrossSection.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			// ***TOSDP*** Putting this here will cancel out any saved value of apexX
			// Set apexX and its limits for apexX according to value of apexY (prevents collisions with cornea and lens)
				/// MSC: Max position dependent on lens type present
			var lens = this.drawing.lastDoodleOfClass('LensCrossSection');
			if (!lens) lens = this.drawing.lastDoodleOfClass('PCIOLCrossSection');
			
			var maxApexX = (lens.className == 'LensCrossSection') ? 32 - (72 / 220) * (this.apexY + 280) + lens.originX - 44: (lens.className == 'PCIOLCrossSection') ? lens.originX - 21 : 25;
			this.parameterValidationArray['apexX']['range'].setMinAndMax(-40 - (140 / 220) * (this.apexY + 280), maxApexX);

			// If being synced, make sensible decision about x
			// Commented out by MCS as was preventing display of saved values ... the above prevents overlap with the PCIOL though
			// if (!this.drawing.isActive) {
			// 	var newOriginX = this.parameterValidationArray['apexX']['range'].max;
			// } else {
			// 	var newOriginX = this.parameterValidationArray['apexX']['range'].constrain(this.apexX);
			// }
			// this.setSimpleParameter('apexX', newOriginX);

			// Set pupil size value
			if (_value < -200) returnArray['pupilSize'] = 'Large';
			else if (_value < -100) returnArray['pupilSize'] = 'Medium';
			else returnArray['pupilSize'] = 'Small';
			break;

		case 'pupilSize':
			switch (_value) {
				case 'Large':
					returnArray['apexY'] = -260;
					break;
				case 'Medium':
					returnArray['apexY'] = -200;
					break;
				case 'Small':
					returnArray['apexY'] = -100;
					break;
			}
			break;

		// commented out by MCS as seems to be blocking correct colour selection in view mode
		// case 'c':
		// 	if (_value === 1) returnArray['colour'] = 'Blue';
		// 	else if (_value === 2) returnArray['colour'] = 'Brown';
		// 	else if (_value === 3) returnArray['colour'] = 'Gray';
		// 	else returnArray['colour'] = 'Green';
		// 	break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AntSegCrossSection.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AntSegCrossSection.superclass.draw.call(this, _point);

	// If lens there, take account of pupil size
	var marginX = this.apexX;
	//    var doodle = this.drawing.lastDoodleOfClass("LensCrossSection");
	//    if (doodle) marginX -= 44 - doodle.originX;

	// Boundary path
	ctx.beginPath();

	// Bottom cut away
	ctx.moveTo(60, 480);
	ctx.lineTo(140, 480);
	ctx.lineTo(140, 380);

	// Bottom ciliary body
	ctx.bezierCurveTo(120, 340, 120, 340, 100, 380);
	ctx.bezierCurveTo(80, 340, 80, 340, 60, 380);

	// Bottom pupil and angle
	var f = Math.abs(marginX) * 0.15;
	ctx.bezierCurveTo(40, 460, marginX + 60 + f, -this.apexY, marginX, -this.apexY);
	ctx.bezierCurveTo(marginX - 60 - f, -this.apexY, -21, 317, 0, 380);

	// Top cut away
	ctx.moveTo(60, -480);
	ctx.lineTo(140, -480);
	ctx.lineTo(140, -380);

	// Bottom ciliary body
	ctx.bezierCurveTo(120, -340, 120, -340, 100, -380);
	ctx.bezierCurveTo(80, -340, 80, -340, 60, -380);

	// Bottom pupil and angle
	ctx.bezierCurveTo(40, -460, marginX + 60 + f, this.apexY, marginX, this.apexY);
	ctx.bezierCurveTo(marginX - 60 - f, this.apexY, -21, -317, 0, -380);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;
	ctx.strokeStyle = "rgba(0,0,0,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
	    // colour fill for iris
		ctx.lineWidth = 4;
		ctx.strokeStyle = "gray";
		switch (this.colour) {
			case 'Blue':
				ctx.fillStyle = "rgba(160, 221, 251, 1)";
				break;
			case 'Brown':
				ctx.fillStyle = "rgba(203, 161, 134, 1)";
				break;
			case 'Gray':
				ctx.fillStyle = "rgba(177, 181, 172, 1)";
				break;
			case 'Green':
				ctx.fillStyle = "rgba(169, 206, 141, 1)";
				break;
		}
		
// 		ctx.fillStyle = "rgba(255, 160, 40, 1)";
		
		// bottom iris
		ctx.beginPath();
		ctx.moveTo(70, 380);
		ctx.lineTo(55, 380);
		ctx.bezierCurveTo(40, 460, marginX + 60 + f, -this.apexY, marginX, -this.apexY);
		ctx.bezierCurveTo(marginX - 60 - f, -this.apexY, -21, 317, 0, 380);
		ctx.lineTo(55,480);
		ctx.fill();
		ctx.stroke();
		ctx.closePath();	
		
		// top iris
		ctx.beginPath();
		ctx.moveTo(70,-380);
		ctx.lineTo(55,-380);
		ctx.bezierCurveTo(40, -460, marginX + 60 + f, this.apexY, marginX, this.apexY);
		ctx.bezierCurveTo(marginX - 60 - f, this.apexY, -21, -317, 0, -380);
		ctx.lineTo(55, -480);
		ctx.fill();
		ctx.stroke();
		ctx.closePath();
		
		ctx.fillStyle = "rgba(255, 160, 40, 1)";		
		// top cilliary body and cutaway
		ctx.beginPath();
		ctx.moveTo(55, -480);
		ctx.lineTo(140, -480);
		ctx.lineTo(140, -380);
	
		ctx.bezierCurveTo(120, -340, 120, -340, 100, -380);
		ctx.bezierCurveTo(80, -340, 80, -340, 55, -380);
		ctx.fill();
		ctx.stroke();
		ctx.closePath();

		
		// bottom cilliary body	and cut away
		ctx.beginPath();
		ctx.moveTo(55, 480);
		ctx.lineTo(140, 480);
		ctx.lineTo(140, 380);
	
		ctx.bezierCurveTo(120, 340, 120, 340, 100, 380);
		ctx.bezierCurveTo(80, 340, 80, 340, 55, 380);
		ctx.fill();
		ctx.stroke();
		ctx.closePath();

	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Anterior Synechiae
 *
 * @class AntSynech
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AntSynech = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AntSynech";

	// Private parameters
	this.rtmi = 304;
	this.riri = 176;

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.AntSynech.prototype = new ED.Doodle;
ED.AntSynech.prototype.constructor = ED.AntSynech;
ED.AntSynech.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.AntSynech.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.AntSynech.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.125, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.125, +1.5);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-480, -260);
	this.parameterValidationArray['arc']['range'].setMinAndMax(30 * Math.PI / 180, Math.PI * 2);
}

/**
 * Sets default parameters
 */
ED.AntSynech.prototype.setParameterDefaults = function() {
	this.arc = 30 * Math.PI / 180;
	this.apexY = -this.rtmi;
	this.setRotationWithDisplacements(0, -60);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AntSynech.prototype.draw = function(_point) { console.log(this.apexY);
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AntSynech.superclass.draw.call(this, _point);

	// AntSynech is at equator
	var ras = -this.apexY;
	this.rir = this.riri;

	var r = this.rir + (ras - this.rir) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;
	var outArcStart = -Math.PI / 2 + theta - Math.PI / 14;
	var outArcEnd = -Math.PI / 2 - theta + Math.PI / 14;

	// Coordinates of 'corners' of AntSynech
	var topRightX = this.rir * Math.sin(theta);
	var topRightY = -this.rir * Math.cos(theta);
	var topLeftX = -this.rir * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Path
	ctx.arc(0, 0, this.rir, arcStart, arcEnd, true);
	ctx.arc(0, 0, ras, outArcEnd, outArcStart, false);

	// Close path
	ctx.closePath();

	// Set fill attributes (same colour as Iris)
	ctx.fillStyle = "rgba(100, 200, 250, 1.0)";
	ctx.strokeStyle = "rgba(100, 100, 100, 1.0)";
	ctx.lineWidth = 4;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(0, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.AntSynech.prototype.groupDescription = function() {
	// Calculate total extent in degrees
	var degrees = this.drawing.totalDegreesExtent(this.className);

	// Return string
	return "Anterior synechiae over " + degrees.toString() + " degrees";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * ArcuateKeratotomy
 *
 * @class ArcuateKeratotomy
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ArcuateKeratotomy = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ArcuateKeratotomy";

	// Derived parameters
	this.diameter = 8;
	this.arcLength = 0;
	this.axis = 0;
	
	// Other parameters
	this.anteriorDepth = 0;
	this.posteriorDepth = 0;
	this.angle = 0;
	this.spotSeparation = "";
	this.lineSeparation = "";
	this.energyLevel = "";
	
	// Saved parameters
	this.savedParameterArray = [
		'arc', 
		'rotation', 
		'apexY', 
		'diameter', 
		'arcLength', 
		'axis', 
		'anteriorDepth', 
		'posteriorDepth', 
		'angle', 
		'spotSeparation', 
		'lineSeparation',
		'energyLevel'
		];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {
		'diameter':'Diameter (mm)',
		'arcLength':'Arc length (deg)',
		'axis':'Axis (deg)',
		'anteriorDepth':'Anterior depth (um)',
		'posteriorDepth':'Posterior depth (um)',
		'angle':'Cut angle (deg)', 
		'spotSeparation':'Spot separation',
		'lineSeparation':'Line separation',
		'energyLevel':'Energy level'
	};
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.ArcuateKeratotomy.prototype = new ED.Doodle;
ED.ArcuateKeratotomy.prototype.constructor = ED.ArcuateKeratotomy;
ED.ArcuateKeratotomy.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.ArcuateKeratotomy.prototype.setHandles = function() {
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.ArcuateKeratotomy.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = true;
	this.isArcSymmetrical = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(10 * Math.PI / 180, 2 * Math.PI / 3);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-320, -96);
	
	// Derived parameters
	this.parameterValidationArray['diameter'] = {
		kind: 'derived',
		type: 'float',
		range: new ED.Range(3, 10),
		precision: 1,
		animate: true
	};
	this.parameterValidationArray['arcLength'] = {
		kind: 'derived',
		type: 'int',
		range: new ED.Range(10, 120),
		precision: 1,
		animate: true
	};
	this.parameterValidationArray['axis'] = {
		kind: 'derived',
		type: 'mod',
		range: new ED.Range(0, 360),
		clock: 'bottom',
		animate: true
	};
	this.parameterValidationArray['diameter'] = {
		kind: 'derived',
		type: 'float',
		range: new ED.Range(3, 10),
		precision: 1,
		animate: true
	};
	this.parameterValidationArray['anteriorDepth'] = {
		kind: 'other',
		type: 'float',
		range: new ED.Range(-50, 100),
		precision: 0,
		animate: false
	};
	this.parameterValidationArray['posteriorDepth'] = {
		kind: 'other',
		type: 'float',
		range: new ED.Range(300, 800),
		precision: 0,
		animate: false
	};
	this.parameterValidationArray['angle'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(30, 150),
		precision: 1,
		animate: false
	};
	this.parameterValidationArray['spotSeparation'] = {
		kind: 'other',
		type: 'string',
		list: ['0.5um', '0.6um', '0.7um', '0.8um', '0.9um', '1.0um'],
		animate: false
	};
	this.parameterValidationArray['lineSeparation'] = {
		kind: 'other',
		type: 'string',
		list: ['0.5um', '0.6um', '0.7um', '0.8um', '0.9um', '1.0um'],
		animate: false
	};
	this.parameterValidationArray['energyLevel'] = {
		kind: 'other',
		type: 'string',
		list: ['0.50uJ', '0.55uJ', '0.60uJ', '0.65uJ', '0.70uJ', '0.75uJ', '0.80uJ', '0.85uJ', '0.90uJ', '0.95uJ', '1.00uJ'],
		animate: false
	};
}

/**
 * Sets default parameters
 */
ED.ArcuateKeratotomy.prototype.setParameterDefaults = function() {
	this.setParameterFromString('diameter', '6.0');
	this.setParameterFromString('arcLength', '60');
	this.setParameterFromString('axis', '90');
	this.setParameterFromString('anteriorDepth', '70');
	this.setParameterFromString('posteriorDepth', '600');
	this.setParameterFromString('angle', '90');
	this.setParameterFromString('spotSeparation', '0.6um');
	this.setParameterFromString('lineSeparation', '0.6um');
	this.setParameterFromString('energyLevel', '0.75uJ');

	// Add others according to scheme
	var n = this.drawing.numberOfDoodlesOfClass(this.className);

	if (n > 0) {
		var doodle = this.drawing.firstDoodleOfClass(this.className);
		switch (n) {
			// Second doodle is opposite first
			case 1:
				this.rotation = doodle.rotation + Math.PI;
				this.arc = doodle.arc;
				this.setParameterFromString('diameter', doodle.diameter.toString());
				break;
				
			// Third doodle is inside first and smaller
			case 2:
				this.rotation = doodle.rotation;
				var newDiameter = doodle.diameter * 0.8;
				this.setParameterFromString('diameter', newDiameter.toString());
				break;
				
			// Fourth doodle is inside second and smaller
			case 3:
				this.rotation = doodle.rotation + Math.PI;
				var newDiameter = doodle.diameter * 0.8;
				this.setParameterFromString('diameter', newDiameter.toString());
				break;
				
			// Fifth doodle is somewhere else!
			case 4:
				this.rotation = doodle.rotation + Math.PI/2;
				break;
				
			default:
				doodle = this.drawing.lastDoodleOfClass(this.className);
				this.rotation = doodle.rotation + Math.PI/6;
				break;
		}
	}
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.ArcuateKeratotomy.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {

		case 'apexY':
			returnArray['diameter'] = -10 * _value/320;
			break;

		case 'diameter':
			returnArray['apexY'] = -320 * parseFloat(_value)/10;
			break;
			
		case 'arc':
			returnArray['arcLength'] = 180 * _value/Math.PI;
			break;

		case 'arcLength':
			returnArray['arc'] = parseInt(_value) * Math.PI / 180;
			break;
			
		case 'rotation':
			var angle = (((Math.PI * 2 - _value + Math.PI / 2) * 180 / Math.PI) + 360) % 360;
			if (angle == 360) angle = 0;
			returnArray['axis'] = angle;
			break;

		case 'axis':
			returnArray['rotation'] = (((90 - _value) + 360) % 360) * Math.PI / 180;
			break;			
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ArcuateKeratotomy.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ArcuateKeratotomy.superclass.draw.call(this, _point);

	// Radius
	var r = -this.apexY;
	var d = 12;
	var ro = r + d;
	var ri = r - d;

	// Boundary path
	ctx.beginPath();

	// Half angle of arc
	var theta = this.arc / 2;
	var offsetAngle = -Math.PI / 2;

	// Arc across
	ctx.arc(0, 0, ro, offsetAngle + theta, offsetAngle - theta, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, offsetAngle - theta, offsetAngle + theta, false);

	// Close path
	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = "rgba(100,100,200,0.5)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "rgba(120,120,120,0.75)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, theta);
	this.handleArray[3].location = this.transform.transformPoint(point);
	var point = new ED.Point(this.apexX, this.apexY);
	this.handleArray[4].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.ArcuateKeratotomy.prototype.groupDescription = function() {
	return "Arcuate Keratotomy";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ArcuateKeratotomy.prototype.description = function() {
	var returnString = "";

	return returnString;
}



/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * ArcuateScotoma
 *
 * @class ArcuateScotoma
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ArcuateScotoma = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ArcuateScotoma";

	// Saved parameters
	this.savedParameterArray = ['scaleX', 'scaleY', 'apexY', 'arc'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.ArcuateScotoma.prototype = new ED.Doodle;
ED.ArcuateScotoma.prototype.constructor = ED.ArcuateScotoma;
ED.ArcuateScotoma.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.ArcuateScotoma.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.ArcuateScotoma.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = false;
	this.isArcSymmetrical = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(140, +300);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-0, +0);
}

/**
 * Sets default parameters
 */
ED.ArcuateScotoma.prototype.setParameterDefaults = function() {
	// Default arc
	this.arc = 60 * Math.PI / 180;
	this.apexX = 200;

	// Eye
	if (this.drawing.eye == ED.eye.Left) this.scaleX = this.scaleX * -1;

	// Make a second one opposite to the first
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		this.scaleY = doodle.scaleY * -1;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ArcuateScotoma.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ArcuateScotoma.superclass.draw.call(this, _point);

	// Dimensions
	var bs = -100;
	var be = 100;
	var ts = -140;

	var r = (be - bs) / 2;
	var x = bs + r;

	// Boundary path
	ctx.beginPath();

	// Arcuate scotoma base
	ctx.arc(x, 0, r, -Math.PI, 0, false);
	ctx.lineTo(this.apexX, 0);

	// Arcuate scotoma top
	r = (this.apexX - ts) / 2;
	x = ts + r;
	ctx.arc(x, 0, r, 0, -Math.PI, true);
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 6;
	ctx.fillStyle = "gray";
	ctx.strokeStyle = "black";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ArcuateScotoma.prototype.description = function() {
	return this.scaleY > 0 ? "Superior" : "Inferior" + " arcuate scotoma";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * AxialLengthGraph
 *
 * @class AxialLengthGraph
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.AxialLengthGraph = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "AxialLengthGraph";

	// Private parameters
	this.padding = 100;	// Gap between axes and left and bottom edges of canvas
	this.offset = 120;
	this.xAxis = 24;
	this.xFirst = 14;
	this.interval = 2;
	this.stubLength = 30;

	// Values
	this.axialLength = 25;
	this.standardDeviation = 1;
	this.lowerLimit = 21.2;
	this.upperLimit = 26.6;

	// Saved parameters
	//this.savedParameterArray = ['startDate'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.AxialLengthGraph.prototype = new ED.Doodle;
ED.AxialLengthGraph.prototype.constructor = ED.AxialLengthGraph;
ED.AxialLengthGraph.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.AxialLengthGraph.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isShowHighlight = false;
	this.isSelectable = false;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['axialLength'] = {
		kind: 'derived',
		type: 'float',
		precision: 2,
		range: new ED.Range(14, 38),
		animate: false
	};
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.AxialLengthGraph.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.AxialLengthGraph.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();
	var xo = -this.drawing.doodlePlaneWidth/2;
	var yo = -this.drawing.doodlePlaneHeight/2;
	var xs = this.drawing.doodlePlaneWidth/2;
	var ys = this.drawing.doodlePlaneHeight/2;
	var factor = (this.drawing.doodlePlaneWidth - 2 * this.padding)/this.xAxis;
	ctx.rect(xo, yo, this.drawing.doodlePlaneWidth, this.drawing.doodlePlaneHeight);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "gray";
	ctx.fillStyle = "rgba(255,255,255,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Danger areas
		ctx.beginPath();
		ctx.rect(xo + this.padding, yo + this.padding, (this.lowerLimit - this.xFirst) * factor, this.drawing.doodlePlaneHeight - 2 * this.padding - this.offset);
		ctx.rect(xo + this.padding + (this.upperLimit - this.xFirst) * factor, yo + this.padding, this.drawing.doodlePlaneWidth - 2 * this.padding - (this.upperLimit - this.xFirst) * factor, this.drawing.doodlePlaneHeight - 2 * this.padding - this.offset);
		ctx.fillStyle = "rgba(255,167,152,0.5)";
		ctx.fill();

		// Safe areas
		ctx.beginPath();
		ctx.rect(xo + this.padding + (this.lowerLimit - this.xFirst) * factor, yo + this.padding, (this.upperLimit - this.lowerLimit) * factor, this.drawing.doodlePlaneHeight - 2 * this.padding - this.offset);
		ctx.fillStyle = "rgba(208,255,197,0.5)";
		ctx.fill();

		// Draw axes
		ctx.beginPath();

		// X-axis
		ctx.moveTo(xo + this.padding, ys - this.padding - this.offset);
		ctx.lineTo(xs - this.padding, ys - this.padding - this.offset);

		// Y-axis
		ctx.moveTo(xo + this.padding, ys - this.padding - this.offset);
		ctx.lineTo(xo + this.padding, yo + this.padding);

		// Set line attributes
		ctx.lineWidth = 4;

		// Draw grid lines
		ctx.stroke();

		// Draw time values at top, but leave out edges
		var n = Math.floor(this.xAxis/this.interval) + 1;
		for (var i = 0; i < n; i++) {

			// Text for x-axis
			var labelText = (this.xFirst + i * this.interval).toString();
			var increment = i * (this.drawing.doodlePlaneWidth - 2 * this.padding)/(n - 1);

			// Text properties
			ctx.lineWidth = 4;
			ctx.font = "112px sans-serif";
			ctx.strokeStyle = "gray";
			ctx.fillStyle = "gray";

			// Draw stub
			ctx.beginPath();
			ctx.moveTo(xo + this.padding + increment, ys - this.padding - this.offset);
			ctx.lineTo(xo + this.padding + increment, ys - this.padding - this.offset + this.stubLength);
			ctx.stroke();

			// Draw text centred on grid line
			var textWidth = ctx.measureText(labelText).width;
			ctx.fillText(labelText, xo + this.padding + increment - textWidth/2, ys - this.padding);
		}

		// Draw axial length
		var x = xo + this.padding + (this.axialLength - this.xFirst) * factor;
		ctx.beginPath();
		ctx.moveTo(x, ys - this.padding - this.offset);
		ctx.lineTo(x, yo + this.padding);
		ctx.lineWidth = 16;
		ctx.strokeStyle = "rgba(50,50,50,1)";
		ctx.stroke();

		// Draw standard deviation
		var sd = this.standardDeviation * factor;
		ctx.beginPath();
		ctx.rect(x - sd/2, 0 - this.offset/2, sd, 50);
		ctx.lineWidth = 16;
		ctx.strokeStyle = "red";
		ctx.stroke();
	}

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Biopsy site
 *
 * @class BiopsySite
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.BiopsySite = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "BiopsySite";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.BiopsySite.prototype = new ED.Doodle;
ED.BiopsySite.prototype.constructor = ED.BiopsySite;
ED.BiopsySite.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.BiopsySite.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default properties
 */
ED.BiopsySite.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +3);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +3);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.BiopsySite.prototype.setParameterDefaults = function() {
	this.scaleX = 0.75;
	this.scaleY = 0.75;
	this.setOriginWithDisplacements(300, -80);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.BiopsySite.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.BiopsySite.superclass.draw.call(this, _point);

	// Radius of laser spot
	var r = 30;

	// Boundary path
	ctx.beginPath();

	// Circle
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = r * 2 / 3;
	ctx.fillStyle = "yellow";
	ctx.strokeStyle = "red";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {}

	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.BiopsySite.prototype.description = function() {
	return "Biopsy site in the " + this.quadrant();
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Bleb
 *
 * @class Bleb
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Bleb = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Bleb";

	// Saved parameters
	this.savedParameterArray = ['rotation','arc'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Bleb.prototype = new ED.Doodle;
ED.Bleb.prototype.constructor = ED.Bleb;
ED.Bleb.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Bleb.prototype.setHandles = function() {
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Sets default dragging attributes
 */
ED.Bleb.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.isArcSymmetrical = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 12, Math.PI / 2);
}

/**
 * Sets default parameters
 */
ED.Bleb.prototype.setParameterDefaults = function() {
	this.setRotationWithDisplacements(30, 30);
	this.arc = Math.PI/8;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Bleb.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Bleb.superclass.draw.call(this, _point);

	// Base radius
	var r = 384;

	// Boundary path
	ctx.beginPath();

	// Radii
	var ro = 500;
	var r = 470;
	var ri = 384;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var eps = Math.PI/30;
	var phi = Math.PI/40;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of doodle
	var topRightX = ro * Math.sin(theta);
	var topRightY = -ro * Math.cos(theta);
	var topLeftX = -ro * Math.sin(theta);
	var topLeftY = topRightY;
	var handleRightX = r * Math.sin(theta + eps);
	var handleRightY = -r * Math.cos(theta + eps);
	var handleLeftX = -r * Math.sin(theta + eps);
	var handleLeftY = handleRightY;
	var cpRightX = r * Math.sin(theta + eps + phi);
	var cpRightY = -r * Math.cos(theta + eps + phi);
	var cpLeftX = -r * Math.sin(theta + eps + phi);
	var cpLeftY = cpRightY;
	var bottomRightX = ri * Math.sin(theta);
	var bottomRightY = -ri * Math.cos(theta);
	var bottomLeftX = -ri * Math.sin(theta);
	var bottomLeftY = bottomRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across
	ctx.arc(0, 0, ro, -Math.PI / 2 + theta, -Math.PI / 2 - theta, true);

	// Curvy left hand edge
	ctx.quadraticCurveTo(cpLeftX, cpLeftY, bottomLeftX, bottomLeftY);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, -Math.PI / 2 - theta, -Math.PI / 2 + theta, false);

	// Curvy right hand edge
	ctx.quadraticCurveTo(cpRightX, cpRightY, topRightX, topRightY);

	// Close path
	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = "rgba(240,240,240,0.9)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "rgba(120,120,120,0.75)";;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();
		ctx.moveTo(-50, -ri);
		ctx.lineTo(-50, -ri * 1.2);
		ctx.lineTo(50, -ri * 1.2);
		ctx.lineTo(50, -ri);
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(handleRightX, handleRightY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point)

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Bleb.prototype.description = function() {
	return "Trabeculectomy bleb at " + this.clockHour() + " o'clock";;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Blot Haemorrhage
 *
 * @class BlotHaemorrhage
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.BlotHaemorrhage = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "BlotHaemorrhage";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.BlotHaemorrhage.prototype = new ED.Doodle;
ED.BlotHaemorrhage.prototype.constructor = ED.BlotHaemorrhage;
ED.BlotHaemorrhage.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.BlotHaemorrhage.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.BlotHaemorrhage.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(-60, -60);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.BlotHaemorrhage.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.BlotHaemorrhage.superclass.draw.call(this, _point);

	// Exudate radius
	var r = 30;

	// Boundary path
	ctx.beginPath();

	// Haemorrhage
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 1;
	ctx.strokeStyle = "red";
	ctx.fillStyle = "red";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.BlotHaemorrhage.prototype.groupDescription = function() {
	return "Blot haemorrhages";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * BuckleOperation
 *
 * @class BuckleOperation
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.BuckleOperation = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "BuckleOperation";
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.BuckleOperation.prototype = new ED.Doodle;
ED.BuckleOperation.prototype.constructor = ED.BuckleOperation;
ED.BuckleOperation.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.BuckleOperation.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
	this.isDeletable = false;
	this.willReport = false;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.BuckleOperation.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.BuckleOperation.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Cornea
	ctx.arc(0, 0, 100, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	this.isFilled = false;
	ctx.strokeStyle = "#444";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Recti
		this.drawRectus(ctx, 'Sup');
		this.drawRectus(ctx, 'Nas');
		this.drawRectus(ctx, 'Inf');
		this.drawRectus(ctx, 'Tem');
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Draws a rectus muscle
 *
 * @param {Context} _ctx
 * @param {Stirng} _quad Quadrant
 */
ED.BuckleOperation.prototype.drawRectus = function(_ctx, _quad) {
	_ctx.beginPath();

	switch (_quad) {
		case 'Sup':
			x1 = -60;
			y1 = -480;
			x2 = -60;
			y2 = -200;
			x3 = 60;
			y3 = -200;
			x4 = 60;
			y4 = -480;
			xd = 30;
			yd = 0;
			break;
		case 'Nas':
			x1 = 480;
			y1 = -60;
			x2 = 200;
			y2 = -60;
			x3 = 200;
			y3 = 60;
			x4 = 480;
			y4 = 60;
			xd = 0;
			yd = 30;
			break;
		case 'Inf':
			x1 = 60;
			y1 = 480;
			x2 = 60;
			y2 = 200;
			x3 = -60;
			y3 = 200;
			x4 = -60;
			y4 = 480;
			xd = -30;
			yd = 0;
			break;
		case 'Tem':
			x1 = -480;
			y1 = 60;
			x2 = -200;
			y2 = 60;
			x3 = -200;
			y3 = -60;
			x4 = -480;
			y4 = -60;
			xd = 0;
			yd = -30;
		default:
			break;
	}

	_ctx.moveTo(x1, y1);
	_ctx.lineTo(x2, y2);
	_ctx.lineTo(x3, y3);
	_ctx.lineTo(x4, y4);
	_ctx.moveTo(x1 + xd, y1 + yd);
	_ctx.lineTo(x2 + xd, y2 + yd);
	_ctx.moveTo(x1 + 2 * xd, y1 + 2 * yd);
	_ctx.lineTo(x2 + 2 * xd, y2 + 2 * yd);
	_ctx.moveTo(x1 + 3 * xd, y1 + 3 * yd);
	_ctx.lineTo(x2 + 3 * xd, y2 + 3 * yd);
	_ctx.fillStyle = "#CA6800";
	_ctx.fill();
	_ctx.lineWidth = 8;
	_ctx.strokeStyle = "#804000";
	_ctx.stroke();
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * BuckleSuture
 *
 * @class BuckleSuture
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.BuckleSuture = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "BuckleSuture";

	// Saved parameters
	this.savedParameterArray = ['rotation'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
	
	// Invariant simple parameters
	this.arc = 15 * Math.PI/180;
}

/**
 * Sets superclass and constructor
 */
ED.BuckleSuture.prototype = new ED.Doodle;
ED.BuckleSuture.prototype.constructor = ED.BuckleSuture;
ED.BuckleSuture.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.BuckleSuture.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.willReport = false;
}

/**
 * Sets default parameters
 */
ED.BuckleSuture.prototype.setParameterDefaults = function() {
	this.setRotationWithDisplacements(30, 30);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.BuckleSuture.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.BuckleSuture.superclass.draw.call(this, _point);

	// If Buckle there, take account of  size
	var ro = 340;
	var doodle = this.drawing.lastDoodleOfClass("CircumferentialBuckle");
	if (doodle) ro = -doodle.apexY + 20;

	var ri = 200;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	this.isFilled = false;
	ctx.strokeStyle = "#666";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Calculate location of suture
		r = ri + (ro - ri) / 2;
		var sutureX = r * Math.sin(theta);
		var sutureY = -r * Math.cos(theta);

		ctx.beginPath();
		ctx.arc(sutureX, sutureY, 5, 0, Math.PI * 2, true);
		ctx.moveTo(sutureX + 20, sutureY + 20);
		ctx.lineTo(sutureX, sutureY);
		ctx.lineTo(sutureX + 20, sutureY - 20);

		ctx.stroke();
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Peripheral iridectomy
 *
 * @class PI
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.BusaccaNodule = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "BusaccaNodule";

	// Saved parameters
	this.savedParameterArray = ['rotation'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.BusaccaNodule.prototype = new ED.Doodle;
ED.BusaccaNodule.prototype.constructor = ED.BusaccaNodule;
ED.BusaccaNodule.superclass = ED.Doodle.prototype;

/**
 * Sets default properties
 */
ED.BusaccaNodule.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
}

/**
 * Sets default parameters
 */
ED.BusaccaNodule.prototype.setParameterDefaults = function() {
	this.setRotationWithDisplacements(30, 30);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.BusaccaNodule.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.BusaccaNodule.superclass.draw.call(this, _point);

	// Outer radius
	var ro = 380;
	var ri = 260;
	
	// If iris there, take account of pupil size
	var doodle = this.drawing.lastDoodleOfClass("AntSeg");
	if (doodle) ri = -doodle.apexY;
	
	// Calculate distance of nodule from centre
	var r = ri + (ro - ri) / 2;
	
	// Boundary path
	ctx.beginPath();

	// Draw nodule
	ctx.arc(0, -r, 30, 0, 2 * Math.PI, false);

	// Colour of fill
	ctx.fillStyle = "rgba(150,100,50,1)";

	// Set line attributes
	ctx.lineWidth = 1;

	// Colour of outer line is dark gray
	ctx.strokeStyle = ctx.fillStyle;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.BusaccaNodule.prototype.groupDescription = function() {
	return "Busacca nodules";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Capsular Tension Ring
 *
 * @class CapsularTensionRing
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CapsularTensionRing = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CapsularTensionRing";

	// Saved parameters
	this.savedParameterArray = ['rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CapsularTensionRing.prototype = new ED.Doodle;
ED.CapsularTensionRing.prototype.constructor = ED.CapsularTensionRing;
ED.CapsularTensionRing.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.CapsularTensionRing.prototype.setPropertyDefaults = function() {
	this.addAtBack = true;
	this.isScaleable = false;
	this.isMoveable = false;
	this.isUnique = true;
}

/**
 * Sets default parameters
 */
ED.CapsularTensionRing.prototype.setParameterDefaults = function() {
	this.rotation = -Math.PI / 2;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CapsularTensionRing.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CapsularTensionRing.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Radii
	var ro = 360;
	var rm = 340;
	var ri = 300;
	var rh = 15;

	// Half angle of missing arc
	var theta = Math.PI * 0.2;

	// Outer ring
	ctx.arc(0, 0, ro, -theta, theta, true);

	var p1c1 = new ED.Point(0, 0)
	p1c1.setWithPolars(ro, Math.PI / 2 + 0.8 * theta);

	var p1c2 = new ED.Point(0, 0)
	p1c2.setWithPolars(ri, Math.PI / 2 + 0.8 * theta);

	var p1 = new ED.Point(0, 0)
	p1.setWithPolars(ri, Math.PI / 2 + theta);

	var p2c1 = new ED.Point(0, 0)
	p2c1.setWithPolars(ri, Math.PI / 2 + 1.1 * theta);

	var p2c2 = new ED.Point(0, 0)
	p2c2.setWithPolars(rm, Math.PI / 2 + 1.1 * theta);

	var p2 = new ED.Point(0, 0)
	p2.setWithPolars(rm, Math.PI / 2 + 1.2 * theta);

	ctx.bezierCurveTo(p1c1.x, p1c1.y, p1c2.x, p1c2.y, p1.x, p1.y);
	ctx.bezierCurveTo(p2c1.x, p2c1.y, p2c2.x, p2c2.y, p2.x, p2.y);

	// Inner ring
	ctx.arc(0, 0, rm, 1.2 * theta, -1.2 * theta, false);

	var p3c1 = new ED.Point(0, 0)
	p3c1.setWithPolars(rm, Math.PI / 2 - 1.1 * theta);

	var p3c2 = new ED.Point(0, 0)
	p3c2.setWithPolars(ri, Math.PI / 2 - 1.1 * theta);

	var p3 = new ED.Point(0, 0)
	p3.setWithPolars(ri, Math.PI / 2 - theta);

	var p4c1 = new ED.Point(0, 0)
	p4c1.setWithPolars(ri, Math.PI / 2 - 0.8 * theta);

	var p4c2 = new ED.Point(0, 0)
	p4c2.setWithPolars(ro, Math.PI / 2 - 0.8 * theta);

	var p4 = new ED.Point(0, 0)
	p4.setWithPolars(ro, Math.PI / 2 - theta);

	ctx.bezierCurveTo(p3c1.x, p3c1.y, p3c2.x, p3c2.y, p3.x, p3.y);
	ctx.bezierCurveTo(p4c1.x, p4c1.y, p4c2.x, p4c2.y, p4.x, p4.y);

	// Hole in end 1
	var cp1 = new ED.Point(0, 0)
	cp1.setWithPolars(rm - 8, Math.PI / 2 - theta);
	var ep1 = new ED.Point(0, 0)
	ep1.setWithPolars(rm - 8 + rh, Math.PI / 2 - theta);
	ctx.moveTo(ep1.x, ep1.y);
	ctx.arc(cp1.x, cp1.y, 15, 0, 2 * Math.PI, false);

	// Hole in end 2
	var cp2 = new ED.Point(0, 0)
	cp2.setWithPolars(rm - 8, Math.PI / 2 + theta);
	var ep2 = new ED.Point(0, 0)
	ep2.setWithPolars(rm - 8 + rh, Math.PI / 2 + theta);
	ctx.moveTo(ep2.x, ep2.y);
	ctx.arc(cp2.x, cp2.y, 15, 0, 2 * Math.PI, false);

	ctx.closePath();

	// Colour of fill is white but with transparency
	ctx.fillStyle = "rgba(255,255,255,0.75)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "darkgray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CapsularTensionRing.prototype.description = function() {
	var returnValue = "Capsular Tension Ring";

	return returnValue;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Chandelier (double)
 *
 * @class ChandelierDouble
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ChandelierDouble = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ChandelierDouble";

	// Private parameters
	this.parsPlana = -560;

	// Saved parameters
	this.savedParameterArray = ['rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.ChandelierDouble.prototype = new ED.Doodle;
ED.ChandelierDouble.prototype.constructor = ED.ChandelierDouble;
ED.ChandelierDouble.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.ChandelierDouble.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
}

/**
 * Sets default parameters
 */
ED.ChandelierDouble.prototype.setParameterDefaults = function() {
	this.setRotationWithDisplacements(180, 90);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ChandelierDouble.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ChandelierDouble.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Port
	ctx.rect(-120, this.parsPlana - 60, 240, 160);

	// Set line attributes
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";

	ctx.fillStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Trocars
		ctx.beginPath();
		var d = -80;
		ctx.moveTo(d - 20, this.parsPlana + 60);
		ctx.lineTo(d + 20, this.parsPlana + 60);
		ctx.lineTo(d + 20, this.parsPlana + 120);
		ctx.lineTo(d, this.parsPlana + 140);
		ctx.lineTo(d - 20, this.parsPlana + 120);
		ctx.lineTo(d - 20, this.parsPlana + 60);
		var d = 80;
		ctx.moveTo(d - 20, this.parsPlana + 60);
		ctx.lineTo(d + 20, this.parsPlana + 60);
		ctx.lineTo(d + 20, this.parsPlana + 120);
		ctx.lineTo(d, this.parsPlana + 140);
		ctx.lineTo(d - 20, this.parsPlana + 120);
		ctx.lineTo(d - 20, this.parsPlana + 60);
		ctx.fillStyle = "rgba(120, 120, 120, 0.5)";
		ctx.fill();

		// Body
		ctx.beginPath();
		ctx.rect(-120, this.parsPlana, 240, 60);
		ctx.fillStyle = "rgba(120, 120, 120, 1)";
		ctx.fill();

		// Fibre optic
		ctx.beginPath();
		ctx.moveTo(0, this.parsPlana);
		ctx.bezierCurveTo(0, this.parsPlana - 50, 50, this.parsPlana - 100, 100, this.parsPlana - 100);
		ctx.lineWidth = 40;
		ctx.strokeStyle = "rgba(120, 120, 120, 0.5)";
		ctx.stroke();
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.ChandelierDouble.prototype.groupDescription = function() {
	return "Twin chandelier at ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ChandelierDouble.prototype.description = function() {
	// Location (clockhours)
	return this.clockHour() + " o'clock";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Chandelier (single)
 *
 * @class ChandelierSingle
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ChandelierSingle = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ChandelierSingle";

	// Private parameters
	this.parsPlana = -560;

	// Saved parameters
	this.savedParameterArray = ['rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.ChandelierSingle.prototype = new ED.Doodle;
ED.ChandelierSingle.prototype.constructor = ED.ChandelierSingle;
ED.ChandelierSingle.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.ChandelierSingle.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
}

/**
 * Sets default parameters
 */
ED.ChandelierSingle.prototype.setParameterDefaults = function() {
	this.setRotationWithDisplacements(180, 90);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ChandelierSingle.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ChandelierSingle.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Port
	ctx.rect(-60, this.parsPlana - 60, 120, 160);

	// Set line attributes
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";

	ctx.fillStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Trocar
		ctx.beginPath();
		ctx.moveTo(-20, this.parsPlana + 60);
		ctx.lineTo(+20, this.parsPlana + 60);
		ctx.lineTo(+20, this.parsPlana + 120);
		ctx.lineTo(0, this.parsPlana + 140);
		ctx.lineTo(-20, this.parsPlana + 120);
		ctx.lineTo(-20, this.parsPlana + 60);
		ctx.fillStyle = "rgba(120, 120, 120, 0.5)";
		ctx.fill();

		// Body
		ctx.beginPath();
		ctx.rect(-60, this.parsPlana, 120, 60);
		ctx.fillStyle = "rgba(120, 120, 120, 1)";
		ctx.fill();

		// Fibre optic
		ctx.beginPath();
		ctx.moveTo(0, this.parsPlana);
		ctx.bezierCurveTo(0, this.parsPlana - 50, 50, this.parsPlana - 100, 100, this.parsPlana - 100);
		ctx.lineWidth = 40;
		ctx.strokeStyle = "rgba(120, 120, 120, 0.5)";
		ctx.stroke();
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.ChandelierSingle.prototype.groupDescription = function() {
	return "Chandelier at ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ChandelierSingle.prototype.description = function() {
	// Location (clockhours)
	return this.clockHour() + " o'clock";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Retinal detachment
 *
 * @class ChoroidalHaemorrhage
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ChoroidalHaemorrhage = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ChoroidalHaemorrhage";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.ChoroidalHaemorrhage.prototype = new ED.Doodle;
ED.ChoroidalHaemorrhage.prototype.constructor = ED.ChoroidalHaemorrhage;
ED.ChoroidalHaemorrhage.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.ChoroidalHaemorrhage.prototype.setHandles = function() {
	this.handleArray[1] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.ChoroidalHaemorrhage.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-400, +400);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.ChoroidalHaemorrhage.prototype.setParameterDefaults = function() {
	this.arc = 60 * Math.PI / 180;
	this.apexY = -200;
	this.setRotationWithDisplacements(315, 60);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ChoroidalHaemorrhage.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ChoroidalHaemorrhage.superclass.draw.call(this, _point);

	// Fit outer curve just inside ora on right and left fundus diagrams
	var r = 952 / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of corners of arc
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across from top right to to mirror image point on the other side
	ctx.arc(0, 0, r, arcStart, arcEnd, true);

	// Connect across the bottom via the apex point
	var bp = +0.6;

	// Radius of disc (from Fundus doodle)
	var dr = +25;

	// Choroidal above optic disc
	if (this.apexY < -dr) {
		ctx.bezierCurveTo(topLeftX, topLeftY, bp * topLeftX, this.apexY, this.apexX, this.apexY);
		ctx.bezierCurveTo(-bp * topLeftX, this.apexY, topRightX, topRightY, topRightX, topRightY);
	}
	// Choroidal involves optic disc
	else if (this.apexY < dr) {
		// Angle from origin to intersection of disc margin with a horizontal line through apexY
		var phi = Math.acos((0 - this.apexY) / dr);

		// Curve to disc, curve around it, then curve out again
		var xd = dr * Math.sin(phi);
		ctx.bezierCurveTo(topLeftX, topLeftY, bp * topLeftX, this.apexY, -xd, this.apexY);
		ctx.arc(0, 0, dr, -Math.PI / 2 - phi, -Math.PI / 2 + phi, false);
		ctx.bezierCurveTo(-bp * topLeftX, this.apexY, topRightX, topRightY, topRightX, topRightY);
	}
	// Choroidale beyond optic disc
	else {
		ctx.bezierCurveTo(topLeftX, topLeftY, bp * topLeftX, this.apexY, 0, 25);
		ctx.arc(0, 0, dr, Math.PI / 2, 2.5 * Math.PI, false);
		ctx.bezierCurveTo(-bp * topLeftX, this.apexY, topRightX, topRightY, topRightX, topRightY);
	}

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(153, 102, 51, 1)";
	ctx.strokeStyle = "rgba(153, 102, 51, 1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[1].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ChoroidalHaemorrhage.prototype.description = function() {
	// Construct description
	var returnString = "";

	// Use trigonometry on rotation field to determine quadrant
	returnString = returnString + (Math.cos(this.rotation) > 0 ? "Supero" : "Infero");
	returnString = returnString + (Math.sin(this.rotation) > 0 ? (this.drawing.eye == ED.eye.Right ? "nasal" : "temporal") : (this.drawing.eye == ED.eye.Right ? "temporal" : "nasal"));
	returnString = returnString + " choroidal haemorrhage";

	// Return description
	return returnString;
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.ChoroidalHaemorrhage.prototype.snomedCode = function() {
	return 419596007;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * The optic disc
 *
 * @class ChoroidalNaevus
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ChoroidalNaevus = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ChoroidalNaevus";

	// Private parameters
	this.numberOfHandles = 4;
	this.initialRadius = 120;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexX', 'apexY', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.ChoroidalNaevus.prototype = new ED.Doodle;
ED.ChoroidalNaevus.prototype.constructor = ED.ChoroidalNaevus;
ED.ChoroidalNaevus.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.ChoroidalNaevus.prototype.setHandles = function() {
	// Array of handles
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	}

	// Allow top handle to rotate doodle
	this.handleArray[0].isRotatable = true;

	// Handle for apex
	this.handleArray[this.numberOfHandles] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.ChoroidalNaevus.prototype.setPropertyDefaults = function() {
	// Create ranges to constrain handles
	this.handleVectorRangeArray = new Array();
	for (var i = 0; i < this.numberOfHandles; i++) {
		// Full circle in radians
		var cir = 2 * Math.PI;

		// Create a range object for each handle
		var n = this.numberOfHandles;
		var range = new Object;
		range.length = new ED.Range(+50, +290);
		range.angle = new ED.Range((((2 * n - 1) * cir / (2 * n)) + i * cir / n) % cir, ((1 * cir / (2 * n)) + i * cir / n) % cir);
		this.handleVectorRangeArray[i] = range;
	}

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-50, +50);

	this.addAtBack = true;
}

/**
 * Sets default parameters
 */
ED.ChoroidalNaevus.prototype.setParameterDefaults = function() {
	this.apexY = 50;
	this.setOriginWithDisplacements(200, 150);

	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate with handles at equidistant points around circumference
	for (var i = 0; i < this.numberOfHandles; i++) {
		var point = new ED.Point(0, 0);
		point.setWithPolars(this.initialRadius, i * 2 * Math.PI / this.numberOfHandles);
		this.addPointToSquiggle(point);
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ChoroidalNaevus.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ChoroidalNaevus.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Bezier points
	var fp;
	var tp;
	var cp1;
	var cp2;

	// Angle of control point from radius line to point (this value makes path a circle Math.PI/12 for 8 points
	var phi = 2 * Math.PI / (3 * this.numberOfHandles);

	// Start curve
	ctx.moveTo(this.squiggleArray[0].pointsArray[0].x, this.squiggleArray[0].pointsArray[0].y);

	// Complete curve segments
	for (var i = 0; i < this.numberOfHandles; i++) {
		// From and to points
		fp = this.squiggleArray[0].pointsArray[i];
		var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
		tp = this.squiggleArray[0].pointsArray[toIndex];

		// Control points
		cp1 = fp.tangentialControlPoint(+phi);
		cp2 = tp.tangentialControlPoint(-phi);

		// Draw Bezier curve
		ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);
	}

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(125, 65, 54, 0.8)";
	ctx.strokeStyle = ctx.fillStyle;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Drusen
		p = new ED.Point(0,0);
		fill = "yellow";
		var dr = 4;
		n = Math.abs(Math.floor((-this.apexY + 50) / 5));
		for (var i = 0; i < n; i++) {
			p.setWithPolars(this.initialRadius * 0.8 * ED.randomArray[i + 10], 2 * Math.PI * ED.randomArray[i + 100]);
			this.drawSpot(ctx, p.x, p.y, dr * 2, fill);
		}
	}

	// Coordinates of handles (in canvas plane)
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[i]);
	}
	this.handleArray[this.numberOfHandles].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ChoroidalNaevus.prototype.description = function() {
	return 'Choroidal naevus';
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.ChoroidalNaevus.prototype.snomedCode = function() {
	return 255024002;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * CiliaryInjection
 *
 * @class CiliaryInjection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CiliaryInjection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CiliaryInjection";

	// Other parameters
	this.severity = 'Medium';

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation', 'severity'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'severity':'Severity'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CiliaryInjection.prototype = new ED.Doodle;
ED.CiliaryInjection.prototype.constructor = ED.CiliaryInjection;
ED.CiliaryInjection.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CiliaryInjection.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Sets default dragging attributes
 */
ED.CiliaryInjection.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = true;
	this.isArcSymmetrical = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(20 * Math.PI / 180, 2 * Math.PI);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-334, -300);
	this.parameterValidationArray['radius']['range'].setMinAndMax(250, 450);

	// Add complete validation arrays for other parameters
	this.parameterValidationArray['severity'] = {
		kind: 'other',
		type: 'string',
		list: ['Severe', 'Medium', 'Mild'],
		animate: false
	};
}

/**
 * Sets default parameters
 */
ED.CiliaryInjection.prototype.setParameterDefaults = function() {
	// Default arc
	this.arc = 60 * Math.PI / 180;

	// Make a second one 90 degress to last one of same class
	this.setRotationWithDisplacements(45, -90);

	// Match subsequent properties
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		this.arc = doodle.arc
		this.severity = doodle.severity
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CiliaryInjection.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CiliaryInjection.superclass.draw.call(this, _point);

	// Radii
	var ro = 480;
	var ri = 400;
	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of doodle
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across
	ctx.arc(0, 0, ro, -Math.PI / 2 + theta, -Math.PI / 2 - theta, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, -Math.PI / 2 - theta, -Math.PI / 2 + theta, false);

	// Close path
	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = "rgba(218,230,241,0)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line
	ctx.strokeStyle = "rgba(218,230,241,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Total number of vessels in a 360 arc
		var t = 60;

		// Number in the current arc and angular separation
		var phi = 2 * Math.PI / t;
		var n = Math.floor(this.arc / phi);

		// Start and end points of vessel
		var sp = new ED.Point(0, 0);
		var ep = new ED.Point(0, 0);

		ctx.beginPath();

		// Radial lines - adjust length to indicate severity
		var rc
		switch (this.severity) {
			case 'Severe':
				rc = ro - 0;
				break;
			case 'Medium':
				rc = ro - 20;
				break;
			case 'Mild':
				rc = ro - 40;
				break;
		}
		for (var i = 0; i < n; i++) {
			var theta = Math.PI / 2 + arcEnd + i * phi;
			sp.setWithPolars(rc, theta);
			ep.setWithPolars(ri, theta);

			ctx.moveTo(sp.x, sp.y);
			ctx.lineTo(ep.x, ep.y);
		}

		ctx.strokeStyle = "red";

		// Adjust thickness of line for severity
		switch (this.severity) {
			case 'Severe':
				ctx.lineWidth = 16;
				break;
			case 'Medium':
				ctx.lineWidth = 12;
				break;
			case 'Mild':
				ctx.lineWidth = 8;
				break;
		}

		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CiliaryInjection.prototype.groupDescription = function() {
	var returnString = this.severity + " ciliary injection";

	// Unless nearly complete, include quadrant
	if (this.arc < 1.8 * Math.PI) {
		returnString += " centred "

		// Use trigonometry on rotation field to determine quadrant
		returnString += (Math.cos(this.rotation) > 0 ? "supero" : "infero");
		returnString += (Math.sin(this.rotation) > 0 ? (this.drawing.eye == ED.eye.Right ? "nasally" : "temporally") : (this.drawing.eye == ED.eye.Right ? "temporally" : "nasally"));
	}
	return returnString
}

ED.CiliaryInjection.prototype.drawSoftLine = function(x1, y1, x2, y2, lineWidth, r, g, b, a) {
	// Get context
	var ctx = this.drawing.context;

	var lx = x2 - x1;
	var ly = y2 - y1;
	var lineLength = Math.sqrt(lx*lx + ly*ly);
	var wy = lx / lineLength * lineWidth;
	var wx = ly / lineLength * lineWidth;
	var gradient = ctx.createLinearGradient(x1-wx/2, y1+wy/2, x1+wx/2, y1-wy/2);
	  // The gradient must be defined accross the line, 90 turned compared
	  // to the line direction.
	gradient.addColorStop(0,    "rgba("+r+","+g+","+b+",0)");
	gradient.addColorStop(0.43, "rgba("+r+","+g+","+b+","+a+")");
	gradient.addColorStop(0.57, "rgba("+r+","+g+","+b+","+a+")");
	gradient.addColorStop(1,    "rgba("+r+","+g+","+b+",0)");
	ctx.save();
	ctx.beginPath();
	ctx.lineWidth = lineWidth;
	ctx.strokeStyle = gradient;
	ctx.moveTo(x1, y1);
	ctx.lineTo(x2, y2);
	ctx.stroke();
	ctx.restore();
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Circinate
 *
 * @class Circinate
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Circinate = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Circinate";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Circinate.prototype = new ED.Doodle;
ED.Circinate.prototype.constructor = ED.Circinate;
ED.Circinate.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Circinate.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Set default properties
 */
ED.Circinate.prototype.setPropertyDefaults = function() {}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Circinate.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(60, 100);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Circinate.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Circinate.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Radius of Circinate
	var rc = 80;

	// Circle
	ctx.arc(0, 0, rc, 0, 2 * Math.PI, false);

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(200,200,0,0)";
	ctx.strokeStyle = "rgba(100,100,100,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Parameters
		var ro = 40;
		var rh = 10
		var ne = 12;
		var el = 30;

		// Point objects
		var cp = new ED.Point(0, 0);
		var ep = new ED.Point(0, 0);

		// Red centre
		ctx.beginPath();
		ctx.arc(0, 0, rh, 0, 2 * Math.PI, false);
		ctx.closePath();
		ctx.fillStyle = "red";
		ctx.fill();

		// Exudates
		phi = 2 * Math.PI / ne;
		for (i = 0; i < ne; i++) {
			ctx.beginPath();
			cp.setWithPolars(ro, i * phi);
			ep.setWithPolars(ro + el, i * phi);
			ctx.moveTo(cp.x, cp.y);
			ctx.lineTo(ep.x, ep.y);
			ctx.closePath();
			ctx.lineWidth = 12;
			ctx.strokeStyle = "rgba(220,220,0,1)";
			ctx.lineCap = "round";
			ctx.stroke();
		}
	}

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(rc, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.Circinate.prototype.groupDescription = function() {
	return "Circinate retinopathy ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Circinate.prototype.description = function() {
	return this.locationRelativeToFovea();
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * CircumferentialBuckle buckle
 *
 * @class CircumferentialBuckle
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CircumferentialBuckle = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CircumferentialBuckle";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CircumferentialBuckle.prototype = new ED.Doodle;
ED.CircumferentialBuckle.prototype.constructor = ED.CircumferentialBuckle;
ED.CircumferentialBuckle.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CircumferentialBuckle.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.CircumferentialBuckle.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.addAtBack = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-410, -320);
}

/**
 * Sets default parameters
 */
ED.CircumferentialBuckle.prototype.setParameterDefaults = function() {
	this.arc = 140 * Math.PI / 180;
	this.apexY = -320;
	this.rotation = -45 * Math.PI / 180;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CircumferentialBuckle.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CircumferentialBuckle.superclass.draw.call(this, _point);

	// Radii
	var ro = 320;
	if (-350 > this.apexY && this.apexY > -380) ro = 350;
	else if (this.apexY < -380) ro = 410;
	var ri = 220;
	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of CircumferentialBuckle
	var topRightX = ro * Math.sin(theta);
	var topRightY = -ro * Math.cos(theta);
	var topLeftX = -ro * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(200,200,200,0.75)";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Gutter path
		ctx.beginPath();

		var gut = 30;

		rgi = ri + (ro - ri - gut) / 2;
		rgo = ro - (ro - ri - gut) / 2;

		// Arc across
		ctx.arc(0, 0, rgo, arcStart, arcEnd, true);

		// Arc back
		ctx.arc(0, 0, rgi, arcEnd, arcStart, false);

		ctx.closePath();

		ctx.fill();
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, -ro));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CircumferentialBuckle.prototype.description = function() {
	var returnString = "";

	// Size description
	if (this.apexY <= -380) returnString = "280 circumferential buckle ";
	else if (this.apexY <= -350) returnString = "279 circumferential buckle ";
	else returnString = "277 circumferential buckle ";

	// Location (clockhours)
	if (this.arc > Math.PI * 1.8) returnString += "encirclement";
	else returnString += this.clockHourExtent() + " o'clock";

	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * CNV
 *
 * @class CNV
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CNV = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CNV";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CNV.prototype = new ED.Doodle;
ED.CNV.prototype.constructor = ED.CNV;
ED.CNV.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CNV.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Set default properties
 */
ED.CNV.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +2);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +2);
}

/**
 * Sets default parameters
 */
ED.CNV.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(0, -100);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CNV.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CNV.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Radius of CNV
	var r = 80;

	// Parameters of random curve
	var n = 16;
	var phi = 2 * Math.PI / n;
	var th = 0.5 * Math.PI / n;
	var b = 4;
	var point = new ED.Point(0, 0);

	// First point
	var fp = new ED.Point(0, 0);
	fp.setWithPolars(r, 0);
	ctx.moveTo(fp.x, fp.y);
	var rl = r;

	// Subsequent points
	for (var i = 0; i < n; i++) {
		// Get radius of next point
		var rn = r * (b + ED.randomArray[i]) / b;

		// Control point 1
		var cp1 = new ED.Point(0, 0);
		cp1.setWithPolars(rl, i * phi + th);

		// Control point 2
		var cp2 = new ED.Point(0, 0);
		cp2.setWithPolars(rn, (i + 1) * phi - th);

		// Next point
		var pn = new ED.Point(0, 0);
		pn.setWithPolars(rn, (i + 1) * phi);

		// Assign next point
		rl = rn;

		// Next point
		if (i == n - 1) {
			ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, fp.x, fp.y);
		} else {
			ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, pn.x, pn.y);
		}

		// Control handle point
		if (i == 1) {
			point.x = pn.x;
			point.y = pn.y;
		}
	}

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "red";
	ctx.strokeStyle = "red";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Yellow centre
		ctx.beginPath();
		ctx.arc(0, 0, r * 0.8, 0, 2 * Math.PI, false);
		ctx.closePath();
		ctx.fillStyle = "rgba(255,255,190,1)";
		ctx.fill();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CNV.prototype.description = function() {
	return "CNV";
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.CNV.prototype.snomedCode = function() {
	return 314517003;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.CNV.prototype.diagnosticHierarchy = function() {
	return 2;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Conjunctivitis
 *
 * @class Conjunctivitis
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Conjunctivitis = function(_drawing, _parameterJSON) {
  // Set classname
  this.className = "Conjunctivitis";

  // Other parameters
  this.type = 'Papillary';
  this.mucopurulent = false;
  this.hyperaemia = "+";

  // Saved parameters
  this.savedParameterArray = ['type', 'mucopurulent', 'hyperaemia'];

  // Parameters in doodle control bar (parameter name: parameter label)
  this.controlParameterArray = {'type':'Type', 'mucopurulent':'Mucopurulent', 'hyperaemia':'Hyperaemia'};

  // Call superclass constructor
  ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Conjunctivitis.prototype = new ED.Doodle;
ED.Conjunctivitis.prototype.constructor = ED.Conjunctivitis;
ED.Conjunctivitis.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.Conjunctivitis.prototype.setPropertyDefaults = function() {
  this.isUnique = true;
  this.isMoveable = false;
  this.isRotatable = false;

  // Add complete validation arrays for other parameters
  this.parameterValidationArray['type'] = {
    kind: 'other',
    type: 'string',
    list: ['Papillary', 'Follicular'],
    animate: false
  };
  this.parameterValidationArray['mucopurulent'] = {
    kind: 'derived',
    type: 'bool',
    display: true
  };
  this.parameterValidationArray['hyperaemia'] = {
    kind: 'other',
    type: 'string',
    list: ['+', '++', '+++'],
    animate: false
  };
}

/**
 * Sets default parameters
 */
ED.Conjunctivitis.prototype.setParameterDefaults = function() {
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Conjunctivitis.prototype.draw = function(_point) {

  // Get context
  var ctx = this.drawing.context;

  // Call draw method in superclass
  ED.AntSeg.superclass.draw.call(this, _point);

  // Radius of limbus
  var ro = 380;
  var ri = -this.apexY;
  var rs = 500;

  // Calculate parameters for arcs
  var arcStart = -Math.PI/2;
  var arcEnd = 2 * Math.PI - Math.PI/2;

  // Boundary path
  ctx.beginPath();

  // Interpalpebral fissure
  var bh = 350;
  var bv = 150;
  ctx.lineTo(0, -ro);
  ctx.bezierCurveTo(-bh, -ro, -rs, -bv, -rs, 0);
  ctx.bezierCurveTo(-rs, +bv, -bh, +ro, 0, +ro);
  ctx.bezierCurveTo(+bh, +ro, +rs, +bv, +rs, 0);
  ctx.bezierCurveTo(+rs, -bv, +bh, -ro, 0, -ro);

  // Do a 360 arc
  ctx.arc(0, 0, ro, arcStart, arcEnd, false);

  // Edge attributes
  ctx.lineWidth = 4;
  var ptrn = ctx.createPattern(this.drawing.imageArray['NewVesselPattern'], 'repeat');
  ctx.fillStyle = ptrn;
  ctx.strokeStyle = "pink";

  if (this.hyperaemia == "+") ctx.filter = "opacity(10%)";
  if (this.hyperaemia == "++") ctx.filter = "opacity(30%)";
  if (this.hyperaemia == "+++") ctx.filter = "opacity(50%)";

  // Draw boundary path (also hit testing)
  this.drawBoundary(_point);

  // Other paths and drawing here
  if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
  }

  ctx.filter = "none";

  // Return value indicating successful hit test
  return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Conjunctivitis.prototype.description = function() {
  var returnValue = this.type + " conjunctivitis";

  if (this.mucopurulent) returnValue += ", mucopurulent,";

  returnValue += " with " + this.hyperaemia + " hyperaemia";

  return returnValue;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Conjunctival flap
 *
 * @class ConjunctivalFlap
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ConjunctivalFlap = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ConjunctivalFlap";

	// Derived parameters
	this.method = 'Fornix-based';

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.ConjunctivalFlap.prototype = new ED.Doodle;
ED.ConjunctivalFlap.prototype.constructor = ED.ConjunctivalFlap;
ED.ConjunctivalFlap.superclass = ED.Doodle.prototype;


/**
 * Sets handle attributes
 */
ED.ConjunctivalFlap.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.ConjunctivalFlap.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.isArcSymmetrical = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-640, -100);
	this.parameterValidationArray['apexY']['delta'] = 30;
	this.parameterValidationArray['arc']['range'].setMinAndMax(60 * Math.PI / 180, 160 * Math.PI / 180);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['method'] = {
		kind: 'derived',
		type: 'string',
		list: ['Fornix-based', 'Limbus-based'],
		animate: true
	};
}

/**
 * Sets default parameters
 */
ED.ConjunctivalFlap.prototype.setParameterDefaults = function() {
	this.arc = 120 * Math.PI / 180;
	this.setParameterFromString('method', 'Fornix-based');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.ConjunctivalFlap.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			if (_value < -380) returnArray['method'] = 'Fornix-based';
			else returnArray['method'] = 'Limbus-based';
			break;

		case 'method':
			switch (_value) {
				case 'Fornix-based':
					returnArray['apexY'] = -660;
					break;
				case 'Limbus-based':
					returnArray['apexY'] = -100;
					break;
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ConjunctivalFlap.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.NerveFibreDefect.superclass.draw.call(this, _point);

	// Radius of limbus
	var r = 380;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Offset angle for control points
	var phi = this.arc / 6;

	// Apex point
	var apex = new ED.Point(this.apexX, this.apexY);

	// Coordinates of corners of flap
	var right = new ED.Point(r * Math.sin(theta), -r * Math.cos(theta));
	var left = new ED.Point(-r * Math.sin(theta), -r * Math.cos(theta));

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, r, arcStart, arcEnd, true);

	// Curved flap, bp bezier proportion is adjustment factor
	var bp = 0.8;
	ctx.bezierCurveTo(left.x, left.y, bp * left.x, apex.y, apex.x, apex.y);
	ctx.bezierCurveTo(bp * right.x, apex.y, right.x, right.y, right.x, right.y);

	// Colour of fill
	ctx.fillStyle = "rgba(255,255,255,0.5)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "rgba(120,120,120,0.75)";;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(left);
	this.handleArray[3].location = this.transform.transformPoint(right);
	this.handleArray[4].location = this.transform.transformPoint(apex);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ConjunctivalFlap.prototype.description = function() {
	return (this.apexY < -280 ? "Fornix based " : "Limbus based ") + "flap";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * ConjunctivalSuture
 *
 * @class ConjunctivalSuture
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ConjunctivalSuture = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ConjunctivalSuture";

	// Private parameters
	this.boundaryWidth = 180;
	this.boundaryHeight = 180;

	// Derived parameters
	this.type = "Buried Mattress";
	this.material = 'Nylon';
	this.size = '10/0';
	
	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'rotation', 'isOrientated', 'type', 'material', 'size'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'isOrientated':'Orientated', 'type':'Type', 'material':'Material', 'size':'Size'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.ConjunctivalSuture.prototype = new ED.Doodle;
ED.ConjunctivalSuture.prototype.constructor = ED.ConjunctivalSuture;
ED.ConjunctivalSuture.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.ConjunctivalSuture.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Rotate, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.ConjunctivalSuture.prototype.setPropertyDefaults = function() {
	this.isOrientated = true;
	this.handleArray[2].isVisible = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(+80, +220);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-0, +0);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['type'] = {
		kind: 'derived',
		type: 'string',
		list: ['Purse String', 'Mattress', 'Buried Mattress', 'Interrupted', 'Continuous'],
		animate: false
	};
	this.parameterValidationArray['material'] = {
		kind: 'derived',
		type: 'string',
		list: ['Nylon', 'Prolene', 'Vicryl', 'Silk'],
		animate: false
	}
	this.parameterValidationArray['size'] = {
		kind: 'derived',
		type: 'string',
		list: ['11/0', '10/0', '9/0', '8/0', '7/0', '6/0'],
		animate: false
	}
	this.parameterValidationArray['isOrientated'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
}

/**
 * Sets default parameters (only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.ConjunctivalSuture.prototype.setParameterDefaults = function() {
	this.apexX = this.boundaryWidth/2;
	this.setParameterFromString('type', 'Purse String');

	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		var p = new ED.Point(doodle.originX, doodle.originY);

		var np = new ED.Point(0, 0);
		np.setWithPolars(p.length(), p.direction() + Math.PI / 6);

		this.move(np.x, np.y);
	} else {
		var np = new ED.Point(0, 0);
		var m = (this.drawing.eye == ED.eye.Right ? 11 : 1);
		np.setWithPolars(290, m * Math.PI / 6);
		this.move(np.x, np.y);
	}
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.ConjunctivalSuture.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'type':
			if (_value == 'Mattress' || _value == 'Continuous'){
				this.boundaryWidth = 160;
				this.boundaryHeight = 50;
				this.parameterValidationArray['apexX']['range'].setMinAndMax(+80, +220);
				this.handleArray[4].isVisible = true;
			}
			else{
				this.boundaryWidth = 100;
				this.boundaryHeight = 100;
				this.parameterValidationArray['apexX']['range'].setMinAndMax(+50, +50);
				this.handleArray[4].isVisible = false;
			}
			this.apexX = this.boundaryWidth/2;
			break;

		case 'isOrientated':
			if (_value == "true") {
				this.handleArray[2].isVisible = false;
			}
			else {
				this.handleArray[2].isVisible = true;
			}
			break;

		case 'apexX':
			this.boundaryWidth = this.apexX * 2;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ConjunctivalSuture.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ConjunctivalSuture.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Outline
	ctx.rect(-this.boundaryWidth/2, -this.boundaryHeight/2, this.boundaryWidth, this.boundaryHeight);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255,255,255,0)";
	ctx.strokeStyle = ctx.fillStyle;
	if (this.isSelected) ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Suture drawing
		var endLength = 20;
		var r = this.boundaryHeight/2;
		ctx.beginPath();
		switch (this.type) {
			case 'Purse String':
				ctx.arc(0, 0, r, 0, Math.PI * 2, true);
				ctx.moveTo(0 - endLength, r + endLength)
				ctx.lineTo(0, r);
				ctx.lineTo(0 + endLength, r + endLength);
				break;

			case 'Mattress':
				ctx.rect(-this.boundaryWidth/2, -this.boundaryHeight/2, this.boundaryWidth, this.boundaryHeight);
				var p = -this.boundaryWidth/2 + 2 * endLength;
				ctx.moveTo(p - endLength, r + endLength);
				ctx.lineTo(p, r);
				ctx.lineTo(p + endLength, r + endLength);
				break;

			case "Buried Mattress":
				var ti = 10;
				var bi = 40;
				ctx.moveTo(-r + ti, -r);
				ctx.lineTo(r - ti, -r);
				ctx.lineTo(r - bi, r);
				ctx.lineTo(-r + bi, r);
				ctx.lineTo(-r + ti, -r);
				ctx.moveTo(0 - endLength, r + endLength)
				ctx.lineTo(0, r);
				ctx.lineTo(0 + endLength, r + endLength);
				break;

			case "Interrupted":
				var cpdx = 10;
				var cpdy = 30
				ctx.moveTo(0, -r);
				ctx.bezierCurveTo(-cpdx, -r + cpdy, -cpdx, r - cpdy, 0, r);
				ctx.bezierCurveTo(cpdx, r - cpdy, cpdx, -r + cpdy, 0, -r);
				ctx.moveTo(0 - endLength, r + endLength)
				ctx.lineTo(0, r);
				ctx.lineTo(0 + endLength, r + endLength);
				break;

			case 'Continuous':
				var x = -this.boundaryWidth/2;
				ctx.moveTo(x, 0);
				while (x + 2 * endLength < this.boundaryWidth/2) {
					x += endLength;
					ctx.lineTo(x, - endLength);
					x += endLength;
					ctx.lineTo(x, + endLength);
				}
				ctx.lineTo(x + endLength, 0);
				ctx.closePath();
				break;
		}
		ctx.lineWidth = 4;
		ctx.strokeStyle = "blue";
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(-this.boundaryWidth/2, -this.boundaryHeight/2));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ConjunctivalSuture.prototype.description = function() {
	var returnValue;

	returnValue = this.size + " " + this.material + " " + this.type + " conjunctival suture at " + this.clockHour() + " o'clock";

	return returnValue;
}

/**
 * Cornea
 *
 * @class Cornea
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Cornea = function(_drawing, _parameterJSON) {
    // Set classname
    this.className = "Cornea";

    // Other parameters
    this.shape = "";
    this.pachymetry = 540;

    // Saved parameters
    this.savedParameterArray = ['shape', 'pachymetry', 'csOriginX', 'csApexX', 'csApexY'];

    // Call superclass constructor
    ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Cornea.prototype = new ED.Doodle;
ED.Cornea.prototype.constructor = ED.Cornea;
ED.Cornea.superclass = ED.Doodle.prototype;


/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Cornea.prototype.setParameterDefaults = function() {
    this.csOriginX = 50;
    this.csApexX = -363;
    this.csApexY = 0;
    this.setParameterFromString('shape', 'Normal');
    this.setParameterFromString('pachymetry', '540');
}

/**
 * This is basically duplicated from CorneaCrossSection, which could certainly benefit from some refactoring
 * further down the track
 */
ED.Cornea.prototype.setPropertyDefaults = function() {
    this.isSelectable = false;
    this.isDeletable = false;
    this.isMoveable = false;
    this.isRotatable = false;
    this.isUnique = true;
    this.willReport = true;

    // Update validation array for simple parameters
    this.parameterValidationArray['apexX']['range'].setMinAndMax(-365, -300);
    this.parameterValidationArray['apexY']['range'].setMinAndMax(-100, +100);

    // Other parameters
    this.parameterValidationArray['shape'] = {
        kind: 'other',
        type: 'string',
        list: ['Normal', 'Keratoconus', 'Keratoglobus'],
        animate: false
    };
    this.parameterValidationArray['pachymetry'] = {
        kind: 'other',
        type: 'int',
        range: new ED.Range(400, 700),
        precision: 1,
        animate: false
    };
}

/**
 * Transparent doodle can not be clicked
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Cornea.prototype.draw = function(_point) {
    return false;
}

/**
 * Report text
 * 
 * @returns {string}
 */
ED.Cornea.prototype.description = function()
{
    if (this.shape && this.shape != 'Normal')
        return this.shape;
    return '';
};
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Cornea Cross Section ***TODO***
 *
 * @class CorneaCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CorneaCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CorneaCrossSection";

	// Other parameters
	this.shape = "";
	this.pachymetry = 540;
	
	// Saved parameters
	this.savedParameterArray = ['shape', 'pachymetry', 'originX', 'apexX', 'apexY'];
	
	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {
		'shape':'Shape',
		'pachymetry':'Pachymetry',
	};
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

    this.linkedDoodleParameters = {
        'Cornea': {
            source: ['shape', 'pachymetry'],
            store: [['apexX', 'csApexX'], ['apexY', 'csApexY'], ['originX', 'csOriginX']]
        }
    };
}

/**
 * Sets superclass and constructor
 */
ED.CorneaCrossSection.prototype = new ED.Doodle;
ED.CorneaCrossSection.prototype.constructor = ED.CorneaCrossSection;
ED.CorneaCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CorneaCrossSection.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.CorneaCrossSection.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;
	
	// Update validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-365, -300);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-100, +100);
	
	// Other parameters
	this.parameterValidationArray['shape'] = {
		kind: 'other',
		type: 'string',
		list: ['Normal', 'Keratoconus', 'Keratoglobus'],
		animate: false
	};
	this.parameterValidationArray['pachymetry'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(400, 700),
		precision: 1,
		animate: false
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.CorneaCrossSection.prototype.setParameterDefaults = function() {
	this.originX = 50;
	this.apexX = -363;
	this.apexY = 0;
	this.setParameterFromString('shape', 'Normal');
	this.setParameterFromString('pachymetry', '540');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.CorneaCrossSection.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'pachymetry':
			returnArray['pachymetry'] = _value;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CorneaCrossSection.prototype.draw = function(_point) {
// 	console.log(this.apexX, this.apexY);
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CorneaCrossSection.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Top cut away
	ctx.moveTo(60, -480);
	ctx.lineTo(-80, -480);
	ctx.bezierCurveTo(-100, -440, -100, -440, -120, -380);

	// Front of cornea
	switch (this.shape) {
		case "Normal":
			ctx.bezierCurveTo(-240, -260, -320, -160, -320, 0);
			ctx.bezierCurveTo(-320, 160, -240, 260, -120, 380);
			break;
		
		case "Keratoconus":
			ctx.bezierCurveTo(-240, -260, this.apexX, this.apexY - 100, this.apexX, this.apexY);
			ctx.bezierCurveTo(this.apexX, this.apexY + 100, -240, 260, -120, 380);
			break;
			
		case "Keratoglobus":
			ctx.bezierCurveTo(-240, -260, -380, -100, -380, 100);
			ctx.bezierCurveTo(-380, 200, -240, 360, -120, 380);
			break;
	}

	// Bottom cut away
	ctx.bezierCurveTo(-100, 440, -100, 440, -80, 480);
	ctx.lineTo(60, 480);
	ctx.lineTo(0, 380);

	// Back of cornea
	var thickness = this.pachymetry/5;
	switch (this.shape) {
		case "Normal":
			ctx.bezierCurveTo(-80, 260, -220, 180, -220, 0);
			ctx.bezierCurveTo(-220, -180, -80, -260, 0, -380);
			break;
		
		case "Keratoconus":
			ctx.bezierCurveTo(-80, 260, this.apexX + thickness, this.apexY + 120, this.apexX + thickness, this.apexY);
			ctx.bezierCurveTo(this.apexX + thickness, this.apexY - 120, -80, -260, 0, -380);
			break;
			
		case "Keratoglobus":
			ctx.bezierCurveTo(-80, 260, -260, 220, -280, 100);
			ctx.bezierCurveTo(-280, -140, -120, -200, 0, -380);
			break;
	}

	// Close path
	ctx.closePath();

	// Set path attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(245, 245, 245, 0.5)";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Top sclera
		ctx.beginPath();
		ctx.moveTo(56, -478);
		ctx.lineTo(-78, -478);
		ctx.bezierCurveTo(-98, -440, -96, -440, -118, -378);
		ctx.lineTo(-4, -378);
		ctx.lineTo(56, -478);

		// Bottom scleral
		ctx.moveTo(56, 478);
		ctx.lineTo(-78, 478);
		ctx.bezierCurveTo(-98, 440, -96, 440, -118, 378);
		ctx.lineTo(-4, 378);
		ctx.closePath();

		ctx.fillStyle = "rgba(255,255,185,1)";
		ctx.fill();
	}
	
	// Apex handle not present if normal
	if (this.shape == "Keratoconus") {
		// Coordinates of handles (in canvas plane)
		this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

		// Draw handles if selected
		if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Corneal abrasion
 *
 * @class CornealAbrasion
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealAbrasion = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealAbrasion";

	// Private property
	this.isInVisualAxis = false;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CornealAbrasion.prototype = new ED.Doodle;
ED.CornealAbrasion.prototype.constructor = ED.CornealAbrasion;
ED.CornealAbrasion.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CornealAbrasion.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default dragging attributes
 */
ED.CornealAbrasion.prototype.setPropertyDefaults = function() {
	this.isSqueezable = true;
	this.isRotatable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.25, +2);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.25, +2);
}

/**
 * Sets default parameters
 */
ED.CornealAbrasion.prototype.setParameterDefaults = function() {
	this.scaleX = 1.5;
	this.scaleY = 1;
	this.setOriginWithDisplacements(0, 25);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealAbrasion.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CornealAbrasion.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// CornealAbrasion
	var r = 120;
	ctx.arc(0, 0, r, 0, Math.PI * 2, false);

	// Close path
	ctx.closePath();

	// Create fill
	var alpha = -this.apexY / 100;
	ctx.fillStyle = "rgba(0, 255, 0, 1)";

	// Semi -transparent stroke
	ctx.strokeStyle = "rgba(100,100,100,0.9)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CornealAbrasion.prototype.description = function() {
	var returnString = "";

	// Calculate size
	var averageScale = this.scaleX + this.scaleY;

	// Arbitrary cutoffs
	if (averageScale < 2) returnString = "Small ";
	else if (averageScale < 4) returnString = "Medium ";
	else returnString = "Large ";

	returnString += "corneal abrasion";

	return returnString;
}

/**
 * OpenEyes
 * MSC
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * 
 *
 * @class CornealEpithelialDefect
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealEpithelialDefect = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealEpithelialDefect";

	// Private parameters
	this.numberOfHandles = 4;
	this.initialRadius = 81;
	this.resetWidth = true;
	this.resetHeight = true;
	this.resetInfiltrate = true;
	
	// Other parameters
	this.height = Math.round(this.initialRadius * 2 / 54);
	this.width = Math.round(this.initialRadius * 2 / 54);

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'rotation', 'height', 'width'];
	
	// Parameters in doodle control bar
	this.controlParameterArray = {'height':'Height', 'width':'Width'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CornealEpithelialDefect.prototype = new ED.Doodle;
ED.CornealEpithelialDefect.prototype.constructor = ED.CornealEpithelialDefect;
ED.CornealEpithelialDefect.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CornealEpithelialDefect.prototype.setHandles = function() {
	// Array of handles
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	}

	// Allow top handle to rotate doodle
	/// ? Removed as need specific handles to be along X and Y axis - can change... **TODO**
// 	this.handleArray[0].isRotatable = true;
}

/**
 * Sets default properties
 */
ED.CornealEpithelialDefect.prototype.setPropertyDefaults = function() {
	// Create ranges to constrain handles
	this.handleVectorRangeArray = new Array();
	for (var i = 0; i < this.numberOfHandles; i++) {
		// Full circle in radians
		var cir = 2 * Math.PI;

		// Create a range object for each handle
		var n = this.numberOfHandles;
		var range = new Object;
		range.length = new ED.Range(+50, +380);
		range.angle = new ED.Range((((2 * n - 1) * cir / (2 * n)) + i * cir / n) % cir, ((1 * cir / (2 * n)) + i * cir / n) % cir);
		this.handleVectorRangeArray[i] = range;
	}
	
	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-350, +350);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-350, +350);
	
	// Validation arrays for other parameters
	this.parameterValidationArray['height'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(1, 14),
		precision: 1,
		animate: false
	};
	this.parameterValidationArray['width'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(1, 14),
		precision: 1,
		animate: false
	};
	this.parameterValidationArray['resetWidth'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
	this.parameterValidationArray['resetHeight'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.CornealEpithelialDefect.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'width':
			returnArray['resetWidth'] = true;
			break;

		case 'height':
			returnArray['resetHeight'] = true;
			break;
	}

	return returnArray;
}

/**
 * Sets default parameters
 */
ED.CornealEpithelialDefect.prototype.setParameterDefaults = function() {
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		var np = new ED.Point(doodle.originX + 100, doodle.originY);
		this.move(np.x, np.y);
	} else {
		this.move(150, 50);
	}

	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate with handles at equidistant points around circumference
	for (var i = 0; i < this.numberOfHandles; i++) {
		var point = new ED.Point(0, 0);
		point.setWithPolars(this.initialRadius, i * 2 * Math.PI / this.numberOfHandles);
		this.addPointToSquiggle(point);
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealEpithelialDefect.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CornealEpithelialDefect.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Bezier points
	var fp;
	var tp;
	var cp1;
	var cp2;

	// Angle of control point from radius line to point (this value makes path a circle Math.PI/12 for 8 points
	var phi = 2 * Math.PI / (3 * this.numberOfHandles);
	
	// Time intervals along bezier curve
	var T = [0.0,0.125,0.25,0.375,0.50,0.625,0.75,0.875,1];
	
	// If inputted a dimension, reset pointsArray, 
	// otherwise recalculate dimension
	var minY = '';
	var maxY = '';
	if (this.resetWidth) {
		this.squiggleArray[0].pointsArray[1].x = 0.5 * this.width * 54;
		this.squiggleArray[0].pointsArray[3].x = 0.5 * this.width * -54;

		this.resetWidth = false;
	}
	else {
		/// solve bezier to find min and max point along axis
		var maxX = '';
        var minX = '';
        var squiggle = this.squiggleArray[0];
		for (var i=0; i<this.numberOfHandles; i++) {
	        fp = this.squiggleArray[0].pointsArray[i];
			var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
	        tp = this.squiggleArray[0].pointsArray[toIndex];
	        var x1 = fp.x;
			var x2 = fp.tangentialControlPoint(+phi).x;
			var x3 = tp.tangentialControlPoint(-phi).x;
			var x4 = tp.x;
		            
            for (var j=0; j<T.length; j++) {
                var t = T[j];
                var x = (1-t)*(1-t)*(1-t)*x1 + 3*(1-t)*(1-t)*t*x2 + 3*(1-t)*t*t*x3 + t*t*t*x4;
                if (maxX == '' || x > maxX) {
                    maxX = x;
                }
                if (minX == '' || x < minX) {
                    minX = x;
                }
            }
        }
        this.width = Math.round((maxX - minX) / 54);
        this.w = this.width;
	}
	
	if (this.resetHeight) {
		this.squiggleArray[0].pointsArray[0].y = 0.5 * this.height * -54;
		this.squiggleArray[0].pointsArray[2].y = 0.5 * this.height * 54;

		this.resetHeight = false;
		minY = this.squiggleArray[0].pointsArray[0].y;
		maxY = this.squiggleArray[0].pointsArray[2].y;
	}
	else {
		// recalculate height/// solve bezier to find min and max point along axis
        var squiggle = this.squiggleArray[0];
		for (var i=0; i<this.numberOfHandles; i++) {
	        fp = this.squiggleArray[0].pointsArray[i];
			var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
	        tp = this.squiggleArray[0].pointsArray[toIndex];
	        var y1 = fp.y;
			var y2 = fp.tangentialControlPoint(+phi).y;
			var y3 = tp.tangentialControlPoint(-phi).y;
			var y4 = tp.y;
		            
            for (var j=0; j<T.length; j++) {
                var t = T[j];
                var y = (1-t)*(1-t)*(1-t)*y1 + 3*(1-t)*(1-t)*t*y2 + 3*(1-t)*t*t*y3 + t*t*t*y4;
                if (maxY == '' || y > maxY) {
                    maxY = y;
                }
                if (minY == '' || y < minY) {
                    minY = y;
                }
            }
        }
				
        this.height = Math.round((maxY - minY) / 54);
        this.h = this.height;
        		
	}
	
	
	// Start curve
	ctx.moveTo(this.squiggleArray[0].pointsArray[0].x, this.squiggleArray[0].pointsArray[0].y);

	// Complete curve segments
	for (var i = 0; i < this.numberOfHandles; i++) {
		// From and to points
		fp = this.squiggleArray[0].pointsArray[i];
		var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
		tp = this.squiggleArray[0].pointsArray[toIndex];

		// Control points
		cp1 = fp.tangentialControlPoint(+phi);
		cp2 = tp.tangentialControlPoint(-phi);
		
		// Draw Bezier curve
		ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);
	}

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 1;
	ctx.fillStyle = "rgba(50,205,50,0.8)";
	ctx.strokeStyle = "rgba(50,205,50,1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Coordinates of expert handles (in canvas plane)
	for (var i = 0; i < this.numberOfHandles /* * 2 */; i++) {
		this.handleArray[i].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[i]);
	}
			

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		
	}
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CornealEpithelialDefect.prototype.description = function() {
	return 'Epithelial defect H-W: ' + this.height + 'x' + this.width + 'mm';
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Corneal erosion
 *
 * @class CornealErosion
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealErosion = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealErosion";

	// Doodle specific property
	this.isInVisualAxis = false;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CornealErosion.prototype = new ED.Doodle;
ED.CornealErosion.prototype.constructor = ED.CornealErosion;
ED.CornealErosion.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CornealErosion.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default dragging attributes
 */
ED.CornealErosion.prototype.setPropertyDefaults = function() {
	this.isSqueezable = true;
	this.isRotatable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-150, +150);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-150, +150);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.25, +2);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.25, +2);
}

/**
 * Sets default parameters
 */
ED.CornealErosion.prototype.setParameterDefaults = function() {
	this.scaleX = 1.5;
	this.scaleY = 1;
	this.setOriginWithDisplacements(0, 25);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealErosion.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CornealErosion.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// CornealErosion
	var r = 120;
	ctx.arc(0, 0, r, 0, Math.PI * 2, false);

	// Close path
	ctx.closePath();

	// Properties
	ctx.lineWidth = 3;
	ctx.fillStyle = "rgba(230, 230, 230, 0.25)";
	ctx.strokeStyle = "rgba(100, 100, 100, 1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CornealErosion.prototype.groupDescription = function() {
	return "Removal of some corneal epithelium";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Corneal Oedema
 *
 * @class CornealGraft
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealGraft = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealGraft";

	// Private parameters
	this.pixelsPerMillimetre = 63.3333;
	this.sutureLength = 60;

	// Derived parameters
	this.diameter = 7.5;
	
	// Other parameters
	this.type = 'Penetrating';
	this.showSutures = true;
	this.sutureType = 'Interrupted';
	this.numberOfSutures = 16;
	this.opaque = false;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexY', 'type', 'showSutures', 'sutureType', 'numberOfSutures', 'opaque'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'type':'Type', 'showSutures':'Show Sutures', 'sutureType':'Suture type', 'numberOfSutures':'Sutures', 'opaque':'Opaque'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CornealGraft.prototype = new ED.Doodle;
ED.CornealGraft.prototype.constructor = ED.CornealGraft;
ED.CornealGraft.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CornealGraft.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.CornealGraft.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;
	this.isUnique = true;

	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-8.5 * this.pixelsPerMillimetre/2, -6.5 * this.pixelsPerMillimetre/2);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['type'] = {
		kind: 'derived',
		type: 'string',
		list: ['Penetrating', 'DMEK', 'DSEAK'],
		animate: false
	};
	this.parameterValidationArray['showSutures'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['diameter'] = {
		kind: 'derived',
		type: 'float',
		range: new ED.Range(6.5, 8.5),
		precision: 1,
		animate: true
	};
	this.parameterValidationArray['sutureType'] = {
		kind: 'derived',
		type: 'string',
		list: ['Interrupted', 'Continuous', 'None'],
		animate: false
	};
	this.parameterValidationArray['numberOfSutures'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(4, 32),
		animate: false
	};
	this.parameterValidationArray['opaque'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
}

/**
 * Sets default parameters
 */
ED.CornealGraft.prototype.setParameterDefaults = function() {
	this.setParameterFromString('diameter', '7.5');
	this.setParameterFromString('sutureType', 'Continuous');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.CornealGraft.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			returnArray['diameter'] = -2 * _value/this.pixelsPerMillimetre;
			break;

		case 'diameter':
			returnArray['apexY'] = -_value * this.pixelsPerMillimetre/2;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealGraft.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CornealGraft.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Circular graft
	var r = -this.apexY;

	// Outer 360 arc
	ctx.arc(0, 0, r,  0, Math.PI * 2, true);

	// Set attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "gray";
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.stroke();
	if (this.opaque) {
		ctx.fillStyle = "rgba(150, 150, 150, 0.8)";
		ctx.fill();
	}

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		if (this.showSutures) {
			// Sutures
			var ro = -this.apexY + this.sutureLength/2;
			var ri = -this.apexY - this.sutureLength/2
		
			ctx.beginPath();
			for (var i = 0; i < this.numberOfSutures; i++) {
				// Suture points
				var phi = i * 2 * Math.PI/this.numberOfSutures;
				var p1 = new ED.Point(0,0);
				p1.setWithPolars(ri, phi);
				var p2 = new ED.Point(0,0);
				p2.setWithPolars(ro, phi);

				// No sutures
				if (this.sutureType == 'None') {
					this.drawSpot(ctx, p1.x, p1.y, 3, "gray");
					this.drawSpot(ctx, p2.x, p2.y, 3, "gray");
				}

				// Inner suture point
				if (phi == 0) {
					ctx.moveTo(p1.x, p1.y);
				}
				else {
					if (this.sutureType == 'Interrupted') {
						ctx.moveTo(p1.x, p1.y);
					}
					else if (this.sutureType == 'Continuous') {
						ctx.lineTo(p1.x, p1.y);
					}
				}

				// Line to outer point
				if (this.sutureType != 'None') {
					ctx.lineTo(p2.x, p2.y);
				}
			}

			// Put in last link
			if (this.sutureType == 'Continuous') {
				ctx.closePath();
			}

			// Draw sutures
			ctx.strokeStyle = "gray";
			ctx.stroke();
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CornealGraft.prototype.description = function() {
	return "Corneal Graft";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * CornealGraftSuture
 *
 * @class CornealGraftSuture
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealGraftSuture = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealGraftSuture";

	// Private parameters
	this.pixelsPerMillimetre = 63.3333;
	
	// Other parameters
	this.tension = 'Loose';
	this.proudKnot = false;

	// Saved parameters
	this.savedParameterArray = ['radius', 'rotation', 'tension', 'proudKnot'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'tension':'Tension', 'proudKnot':'Proud Knot'};
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CornealGraftSuture.prototype = new ED.Doodle;
ED.CornealGraftSuture.prototype.constructor = ED.CornealGraftSuture;
ED.CornealGraftSuture.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.CornealGraftSuture.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	
	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['tension'] = {
		kind: 'derived',
		type: 'string',
		list: ['Loose', 'Tight'],
		animate: false
	};
	this.parameterValidationArray['proudKnot'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
}

/**
 * Sets default parameters
 */
ED.CornealGraftSuture.prototype.setParameterDefaults = function() {
	this.setParameterFromString('tension', 'Tight');
	this.setParameterFromString('proudKnot', 'False');
	
	var doodle = this.drawing.lastDoodleOfClass("CornealGraft");
	if (doodle) {
		this.radius = doodle.diameter * this.pixelsPerMillimetre/2;
		var theta = 360/doodle.numberOfSutures;
		this.setRotationWithDisplacements(0, -theta);
	}
	else {
		this.radius = 374;
		this.setRotationWithDisplacements(0, 30);
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealGraftSuture.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CornealGraftSuture.superclass.draw.call(this, _point);
	
	// Move according to graft diameter
	var doodle = this.drawing.lastDoodleOfClass("CornealGraft");
	if (doodle) {
		this.radius = doodle.diameter * this.pixelsPerMillimetre/2;
	}

	// Boundary path
	ctx.beginPath();

	var r = this.radius;
	ctx.rect(-20, -(r + 40), 40, 80);

	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = "rgba(255,255,255,0.0)";

	// Set line attributes
	ctx.lineWidth = 6;

	// Colour of outer line is dark gray
	ctx.strokeStyle = this.isSelected?"rgba(120,120,120,0.5)":"rgba(120,120,120,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();
		if (this.tension == "Loose") {
			ctx.moveTo(0, -r - 40);
			ctx.bezierCurveTo(-20, -r - 20, +20, -r + 20, 0, -r + 40);
		}
		else
		{
			ctx.moveTo(0, -r - 40);
			ctx.lineTo(0, -r + 40);
		}
		ctx.moveTo(-10, -r + 10);
		ctx.lineTo(0, -r + 20);
		ctx.lineTo(-10, -r + 30);

		ctx.lineWidth = 2;
		var colour = "rgba(0,0,120,0.7)"
		ctx.strokeStyle = colour;

		ctx.stroke();

		// Knot
		var d = this.proudKnot?8:4;
		this.drawSpot(ctx, 0, -r + 20, d, colour);
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CornealGraftSuture.prototype.description = function() {
	var returnString = "Corneal suture at ";

	returnString += this.clockHour() + " o'clock";

	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Lasik Flap
 *
 * @class CornealInlay
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealInlay = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealInlay";
	
	// Other parameters
	this.type = 'Type 1';
	
	// Saved parameters
	this.savedParameterArray = ['scaleX', 'scaleY', 'rotation', 'type'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'type':'Type'};
		
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CornealInlay.prototype = new ED.Doodle;
ED.CornealInlay.prototype.constructor = ED.CornealInlay;
ED.CornealInlay.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.CornealInlay.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.75, +1.00);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.75, +1.00);
	
	this.parameterValidationArray['type'] = {
		kind: 'other',
		type: 'string',
		list: ['Type 1', 'Type 2'],
		animate: false
	};
}

/**
 * Sets default parameters
 */
ED.CornealInlay.prototype.setParameterDefaults = function() {
	//this.apexY = -100;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealInlay.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CornealInlay.superclass.draw.call(this, _point);

	// CornealInlay raidius
	var ro = 200;
	var ri = 100;

	// Calculate parameters for arc
	var arcStart = 0;
	var arcEnd = 2 * Math.PI;

	// Boundary path
	ctx.beginPath();

	// Arcs
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);
	ctx.arc(0, 0, ri, arcStart, arcEnd, false);

	// Fill details
	ctx.lineWidth = 2;
	ctx.fillStyle = "rgba(155,155,155,0.8)";
	ctx.strokeStyle = ctx.fillStyle;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CornealInlay.prototype.description = function() {
	var	returnString = "Corneal inlay " +  this.type;

	return returnString;
}

/**
 * OpenEyes
 *
 * (C) OpenEyes Foundation, 2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Corneal Laceration drawing
 *
 * @class CornealLaceration
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealLaceration = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealLaceration";

	this.plane = 0;
	
	// derived parameter
	this.lacerationDepth = 0;
	this.lacType = "laceration";
	this.complete = false;
	this.irisProlapse = false;
	this.boundaryMin = -450;
	this.boundaryWidth = 900;
	this.numberOfHandles = 0;
	this.mousePoint = new ED.Point(-550,-550); //default off canvas so not visible

	// Saved parameters
	this.savedParameterArray = ['complete','lacerationDepth','numberOfHandles','irisProlapse'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {
		'lacerationDepth':'Laceration Depth %',
		'irisProlapse':'Iris prolapse'
	};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

}

/**
 * Sets superclass and constructor
 */
ED.CornealLaceration.prototype = new ED.Doodle;
ED.CornealLaceration.prototype.constructor = ED.CornealLaceration;
ED.CornealLaceration.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CornealLaceration.prototype.setHandles = function() {
	if (this.numberOfHandles>0) {
		for (var i = 0; i < this.numberOfHandles; i++) {
			this.handleArray[i] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
		}
	}
}

/**
 * Sets default dragging attributes
 */
ED.CornealLaceration.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;
	this.isFilled = false;
	this.isMoveable = false;

	this.parameterValidationArray['lacerationDepth'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(1, 100),
		animate: false
	};
	this.parameterValidationArray['lacType'] = {
		kind: 'derived',
		type: 'string',
		list: ['laceration', 'cornealscleral laceration'],
		animate: false
	};
	this.parameterValidationArray['irisProlapse'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};

	var d = this;

	//Complete doodle on double click
	d.drawing.canvas.addEventListener('dblclick', function(e) {
		if (d.isSelected && !d.complete) {
			//Deletion of handle upon completion removed DAC 20170411
			/*d.squiggleArray[0].pointsArray.shift();
			d.handleArray.shift();
			d.numberOfHandles--;*/
			d.complete = true;
			d.drawing.repaint();
		}
	}, false);

	//Draws straight line to mouse
	this.drawing.canvas.addEventListener('mousemove', function(e) {
		if (!d.complete) {
			var position = ED.findPosition(this, e);
			var mousePosDoodlePlane = d.drawing.inverseTransform.transformPoint(position); // coordinates of mouse in doodle plane
			d.mousePoint = new ED.Point(mousePosDoodlePlane.x, mousePosDoodlePlane.y);
			d.drawing.repaint();
		}
	}, false);

	//Draws handle at mousedown location
	this.drawing.canvas.addEventListener('mousedown', function(e) {
		if (d.draggingHandleIndex==null && d.isSelected && !d.complete) {
			var position = ED.findPosition(this, e);
			var mousePosDoodlePlane = d.drawing.inverseTransform.transformPoint(position); // coordinates of mouse in doodle plane
			if (mousePosDoodlePlane.x>d.boundaryMin && mousePosDoodlePlane.y>d.boundaryMin && mousePosDoodlePlane.x<(d.boundaryMin+d.boundaryWidth) && mousePosDoodlePlane.y<(d.boundaryMin+d.boundaryWidth)) {
				d.addHandle(mousePosDoodlePlane);
			}
		}
	}, false);

}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.CornealLaceration.prototype.setParameterDefaults = function() {
	// create the base squiggle
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);
	this.squiggleArray.push(squiggle);
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.CornealLaceration.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'handles':
		returnArray['lacType'] = this.calculateLacerationType();
		break;
		case 'complete':
			if (this.complete) {
				this.numberOfHandles = this.squiggleArray[0].pointsArray.length - 1;
				this.setHandles();
			}
	}
	return returnArray;
}


/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealLaceration.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CornealLaceration.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Draw rectangle for boundary drawing area over entire canvas if doodle incomplete
	if (!this.complete) {
		ctx.rect(this.boundaryMin, this.boundaryMin, this.boundaryWidth, this.boundaryWidth);
		this.hitTestMethod = 'path';
		ctx.lineWidth = 2;
	}
	// Otherwise draw boundary rectangle around the doodle
	else {
		this.hitTestMethod = 'stroke';
        var squiggle = this.squiggleArray[0];
		// drawing lines for hit test
		ctx.strokeStyle = "rgba(0, 0, 0, 0)";
        ctx.lineWidth = 10; // set wider for hit testing
        for (var i = this.numberOfHandles-1; i >= 0; i--) {
            ctx.lineTo(squiggle.pointsArray[i].x, squiggle.pointsArray[i].y);
        }
        ctx.stroke();
	}

	// Close path
	ctx.closePath();

	// Set attributes for border (colour changes to indicate drawing mode)

	this.isFilled = false;
	ctx.strokeStyle = "rgba(255, 255, 255, 0)";
	if (this.isSelected && !this.complete) ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		if (this.numberOfHandles>0) {
			// Get coordinates of mouse in doodle plane
			// Draw straight line between points in squiggle array
			var squiggle = this.squiggleArray[0];
			ctx.beginPath();
			// Squiggle attributes
			ctx.lineWidth = 5;
			ctx.strokeStyle = "blue";


			// Iterate through squiggle points
			for (var i = this.numberOfHandles-1; i >= 0; i--) {
				ctx.lineTo(squiggle.pointsArray[i].x, squiggle.pointsArray[i].y);
			}
			// Line to mouse coordinates, if selected, incomplete, and within boundary
			if (this.isSelected && this.draggingHandleIndex==null && !this.complete) {
					if (this.mousePoint.x>this.boundaryMin && this.mousePoint.y>this.boundaryMin && this.mousePoint.x<(this.boundaryMin+this.boundaryWidth) && this.mousePoint.y<(this.boundaryMin+this.boundaryWidth)) {
					ctx.lineTo(this.mousePoint.x,this.mousePoint.y);
				}
			}
			ctx.stroke();
		}

		// Draw circle to indicate position for next handle
		if (!this.complete && this.isSelected && this.mousePoint.x>this.boundaryMin && this.mousePoint.y>this.boundaryMin && this.mousePoint.x<(this.boundaryMin+this.boundaryWidth) && this.mousePoint.y<(this.boundaryMin+this.boundaryWidth)) {
			ctx.beginPath();
			ctx.arc(this.mousePoint.x,this.mousePoint.y,25,0,2*Math.PI);
			ctx.strokeStyle="red";
			ctx.fillStyle="yellow";
			ctx.fill();
			ctx.stroke();
		}
	}

	// Coordinates of handles (in canvas plane)
	if (this.numberOfHandles>0) {
		for (var i = 0; i < this.numberOfHandles; i++) {
			this.handleArray[i].location=this.transform.transformPoint(this.squiggleArray[0].pointsArray[i]);
		}
	}

	// Draw handles if selected but not if for drawing
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}


ED.CornealLaceration.prototype.description = function() {
	var s = this.squiggleArray[0];	
	//Linear distance of laceration (scale 380px:6mm)
	var linearDistance = (this.numberOfHandles>=2) ? 6*( Math.sqrt(Math.pow(s.pointsArray[0].x - s.pointsArray[this.numberOfHandles-1].x,2) + Math.pow(s.pointsArray[0].y - s.pointsArray[this.numberOfHandles-1].y,2)) )/380 : 0;	
	var linearDistanceShort = linearDistance.toFixed(2);
	this.lacType = this.calculateLacerationType();
	
	var text = "";
	
	if (this.lacerationDepth == 100) text += 'Full thickness ' + this.lacType + ' ' + linearDistanceShort +'mm';
	else  if (this.lacerationDepth > 0) text += 'Partial thickness ' +  this.lacType + ' ' + linearDistanceShort +'mm, '+ this.lacerationDepth + '%';
	else text += this.lacType + ' ' + linearDistanceShort + 'mm';

    if (this.irisProlapse) {
    	text += ' with iris prolapse';
    }
    
	return text;
}
 	
//Computes laceration type
ED.CornealLaceration.prototype.calculateLacerationType = function() {
	var i=0;
	var scleralInvolvement = false;
	while (!scleralInvolvement && i<this.numberOfHandles) { 
		var p = this.squiggleArray[0].pointsArray[i];
		//Distance of handle from the origin
		var distance = Math.sqrt(p.x*p.x + p.y*p.y);
		//Tests whether a handle is within the sclera
		if (distance > 380) scleralInvolvement = true;
		i++;
	}

	var lacType = (scleralInvolvement) ? "corneoscleral laceration" : "corneal laceration";
	return lacType;
}

ED.CornealLaceration.prototype.addHandle = function(_position) {
	// Add point to squiggle array
	this.squiggleArray[0].pointsArray.splice(0, 0, _position);
	// Add handle to handle array
	this.handleArray.splice(0,0,(new ED.Doodle.Handle(null, true, ED.Mode.Handles, false)));
	// Increase handle counter
	this.numberOfHandles++;
		
	this.lacType = this.calculateLacerationType();
	this.updateDependentParameters('handles');
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.CornealLaceration.prototype.snomedCodes = function() {
	var result = [[95725002, 3]];
	if (this.irisProlapse) {
		result.push([77676001, 3]);
	}

    return result;
}


/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Corneal Oedema
 *
 * @class CornealOedema
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealOedema = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealOedema";

	// Private parameters
	this.numberOfHandles = 4;
	this.initialRadius = 360;

	// Derived parameters
	this.intensity = 'Mild';
	this.i = 1;
	
	// Other parameters
	this.stromal = true;
	this.epithelial = false;
	this.endothelial = false;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexX', 'apexY', 'rotation', 'intensity', 'stromal', 'epithelial', 'endothelial','i'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'intensity':'Intensity',  'epithelial':'Epithelial', 'stromal':'Stromal','endothelial':'Endothelial'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CornealOedema.prototype = new ED.Doodle;
ED.CornealOedema.prototype.constructor = ED.CornealOedema;
ED.CornealOedema.superclass = ED.Doodle.prototype;

/**=
 * Sets handle attributes
 */
ED.CornealOedema.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
	// Array of handles
// 	for (var i = 0; i < this.numberOfHandles; i++) {
// 		this.handleArray[i] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
// 	}
}

/**
 * Sets default properties
 */
ED.CornealOedema.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-380, -80);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['intensity'] = {
		kind: 'derived',
		type: 'string',
		list: ['Mild', 'Moderate', 'Severe'],
		animate: false
	};
	this.parameterValidationArray['stromal'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['epithelial'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['endothelial'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['epi'] = {
		kind: 'other',
		type: 'int',
		range: [0,1],
		animate: false
	};
	this.parameterValidationArray['str'] = {
		kind: 'other',
		type: 'int',
		range: [0,1],
		animate: false
	};
	this.parameterValidationArray['endo'] = {
		kind: 'other',
		type: 'int',
		range: [0,1],
		animate: false
	};
	this.parameterValidationArray['i'] = {
		kind: 'other',
		type: 'int',
		range: [1, 2, 3],
		animate: false
	};

	/*
	// Create ranges to constrain handles
	this.handleVectorRangeArray = new Array();
	for (var i = 0; i < this.numberOfHandles; i++) {
		// Full circle in radians
		var cir = 2 * Math.PI;

		// Create a range object for each handle
		var n = this.numberOfHandles;
		var range = new Object;
		range.length = new ED.Range(+50, +380);
		range.angle = new ED.Range((((2 * n - 1) * cir / (2 * n)) + i * cir / n) % cir, ((1 * cir / (2 * n)) + i * cir / n) % cir);
		this.handleVectorRangeArray[i] = range;
	}
	*/
}

/**
 * Sets default parameters
 */
ED.CornealOedema.prototype.setParameterDefaults = function() {
	this.apexY = -this.initialRadius;
	this.setParameterFromString('stromal', 'true');
	this.setParameterFromString('epithelial', 'false');
	this.setParameterFromString('endothelial', 'false');

	// Put control handle at 45 degrees
	this.rotation = Math.PI / 4;

/*
	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate with handles at equidistant points around circumference
	for (var i = 0; i < this.numberOfHandles; i++) {
		var point = new ED.Point(0, 0);
		point.setWithPolars(this.initialRadius, i * 2 * Math.PI / this.numberOfHandles);
		this.addPointToSquiggle(point);
	}
*/
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.CornealOedema.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'intensity':
			switch (_value) {
				case 'Mild':
					returnArray['i'] = 1;
					break;
				case 'Moderate':
					returnArray['i'] = 2;
					break;
				case 'Severe':
					returnArray['i'] = 3;
					break;
			}
			break;
			
		case 'epithelial':
			if (_value == true) returnArray['epi'] = 1;
			else if (_value == false) returnArray['epi'] = 0;
			break;
		
		case 'stromal':
			if (_value == true) returnArray['str'] = 1;
			else if (_value == false) returnArray['str'] = 0;
			break;
			
		case 'endothelial':
			if (_value == true) returnArray['endo'] = 1;
			else if (_value == false) returnArray['endo'] = 0;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealOedema.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CornealOedema.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();
	
	/*
	// Bezier points
	var fp;
	var tp;
	var cp1;
	var cp2;

	// Angle of control point from radius line to point (this value makes path a circle Math.PI/12 for 8 points
	var phi = 2 * Math.PI / (3 * this.numberOfHandles);

	// Start curve
	ctx.moveTo(this.squiggleArray[0].pointsArray[0].x, this.squiggleArray[0].pointsArray[0].y);

	// Complete curve segments
	for (var i = 0; i < this.numberOfHandles; i++) {
		// From and to points
		fp = this.squiggleArray[0].pointsArray[i];
		var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
		tp = this.squiggleArray[0].pointsArray[toIndex];

		// Control points
		cp1 = fp.tangentialControlPoint(+phi);
		cp2 = tp.tangentialControlPoint(-phi);

		// Draw Bezier curve
		ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);
	}

	// Close path
	ctx.closePath();
	*/

	// Round lesion
	var r = Math.sqrt(this.apexX * this.apexX + this.apexY * this.apexY);
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Set attributes
	ctx.lineWidth = 4;
	switch (this.intensity) {
		case 'Mild':
			ctx.fillStyle = "rgba(0, 0, 255, 0.2)";
			break;
		case 'Moderate':
			ctx.fillStyle = ctx.createPattern(this.drawing.imageArray['OedemaPattern'], 'repeat');
			break;
		case 'Severe':
			ctx.fillStyle = ctx.createPattern(this.drawing.imageArray['OedemaPatternBullous'], 'repeat');
			break;
	}
	ctx.strokeStyle = ctx.fillStyle;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		if (false) {
			var ptrn = ctx.createPattern(this.drawing.imageArray['OedemaPatternBullous'], 'repeat');
			ctx.fillStyle = ptrn;
			ctx.fill();
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));
// 	for (var i = 0; i < this.numberOfHandles; i++) {
// 		this.handleArray[i].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[i]);
// 	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CornealOedema.prototype.description = function() {
	return "Corneal oedema";
}

/**
 * OpenEyes
 * MSC
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * 
 *
 * @class CornealOedemaCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealOedemaCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealOedemaCrossSection";

	// Private parameters
	this.initialRadius = 360;
	
	// Derived parameters
	this.intensity = 'Mild';
	this.i = 1;
	this.epi = 0;
	this.str = 1;
	this.endo = 0;
	
	// Other parameters
	this.stromal = true;
	this.epithelial = false;
	this.endothelial = false;
	
	// Other parameters
	this.height = Math.round(this.initialRadius * 2 / 54);
	this.width = Math.round(this.initialRadius * 2 / 54);
	
	this.h = Math.round(this.initialRadius * 2 / 54);
	this.w = Math.round(this.initialRadius * 2 / 54);
	
	this.minY = this.initialRadius * -1;
	this.maxY = this.initialRadius;
	
	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexX', 'apexY', 'rotation', 'intensity', 'stromal', 'epithelial', 'endothelial','i'];
	
	// Parameters in doodle control bar
	this.controlParameterArray = {};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CornealOedemaCrossSection.prototype = new ED.Doodle;
ED.CornealOedemaCrossSection.prototype.constructor = ED.CornealOedemaCrossSection;
ED.CornealOedemaCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CornealOedemaCrossSection.prototype.setHandles = function() {
}

/**
 * Sets default properties
 */
ED.CornealOedemaCrossSection.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
		
	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(+50, +50);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-500, +500);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-380, -80);
	
	// Validation arrays for other parameters
	this.parameterValidationArray['intensity'] = {
		kind: 'derived',
		type: 'string',
		list: ['Mild', 'Moderate', 'Severe'],
		animate: false
	};
	this.parameterValidationArray['stromal'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['epithelial'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['endothelial'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['i'] = {
		kind: 'other',
		type: 'int',
		range: [1, 2, 3],
		animate: false
	};
	this.parameterValidationArray['epi'] = {
		kind: 'other',
		type: 'int',
		range: [0,1],
		animate: false
	};
	this.parameterValidationArray['str'] = {
		kind: 'other',
		type: 'int',
		range: [0,1],
		animate: false
	};
	this.parameterValidationArray['endo'] = {
		kind: 'other',
		type: 'int',
		range: [0,1],
		animate: false
	};
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.CornealOedemaCrossSection.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'i':
			if (_value === 3) returnArray['intensity'] = 'Severe';
			else if (_value === 2) returnArray['intensity'] = 'Moderate';
			else returnArray['intensity'] = 'Mild';
			break;
			
	}

	return returnArray;
}

/**
 * Sets default parameters
 */
ED.CornealOedemaCrossSection.prototype.setParameterDefaults = function() {
	this.originX = 50; // as is in Cornea cross section doodle to dulicate bezier control points
	
	this.apexY = -this.initialRadius;
/*
	this.setParameterFromString('stromal', 'true');
	this.setParameterFromString('epithelial', 'false');
	this.setParameterFromString('endothelial', 'false');
*/

}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealOedemaCrossSection.prototype.draw = function(_point) {
	
	// Get context
	var ctx = this.drawing.context;

	var cornea = this.drawing.lastDoodleOfClass('CorneaCrossSection');
	var cornealThickness = cornea.pachymetry/5;

	// Call draw method in superclass
	ED.CornealOedemaCrossSection.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();
	
	// Calculate segment extent in terms of time along curve
	var r = Math.sqrt(this.apexX * this.apexX + this.apexY * this.apexY);
	var startY = this.originY - r;
	var endY = this.originY + r;
	
	var startT = (startY + 380) / 760;
	if (startT<0) startT = 0;
	var endT = (endY + 380) / 760;
	if (endT>1) endT = 1;
		
	if (startT < 0.5) {
		
		var superiorBezier = new Object;
		var superiorBezierBack = new Object;

		// define start and end time points
		var tI0 = startT * 2;
		var tI1 = (endT < 0.5) ? endT * 2 : 1;
		
		// default bezier points (as in cornea cross section)
		if (cornea && cornea.shape == "Keratoconus") {
			superiorBezier.SP = new ED.Point(-120, -380 - this.originY);
			superiorBezier.CP1 = new ED.Point(-240, -260 - this.originY);
			superiorBezier.CP2 = new ED.Point(cornea.apexX, cornea.apexY - 100 - this.originY);
			superiorBezier.EP = new ED.Point(cornea.apexX, cornea.apexY - this.originY);
			
			superiorBezierBack.SP = new ED.Point(-120 + 120, -380 - this.originY);
			superiorBezierBack.CP1 = new ED.Point(-240 + 160, -260 - this.originY);
			superiorBezierBack.CP2 = new ED.Point(cornea.apexX + cornealThickness, cornea.apexY - 120 - this.originY);
			superiorBezierBack.EP = new ED.Point(cornea.apexX + cornealThickness, cornea.apexY - this.originY);
		}
		else if (cornea && cornea.shape == "Keratoglobus") {
			superiorBezier.SP = new ED.Point(-120, -380 - this.originY);
			superiorBezier.CP1 = new ED.Point(-240, -260 - this.originY);
			superiorBezier.CP2 = new ED.Point(-380, -100 - this.originY);
			superiorBezier.EP = new ED.Point(-380, 100 - this.originY);
			
			superiorBezierBack.SP = new ED.Point(-120 + 120, -380 - this.originY);
			superiorBezierBack.CP1 = new ED.Point(-240 + 120, -200 - this.originY);
			superiorBezierBack.CP2 = new ED.Point(-380 + 100, -140 - this.originY);
			superiorBezierBack.EP = new ED.Point(-380 + 100, 100 - this.originY);
		}
		else {
			superiorBezier.SP = new ED.Point(-120, -380 - this.originY);
			superiorBezier.CP1 = new ED.Point(-240, -260 - this.originY);
			superiorBezier.CP2 = new ED.Point(-320, -160 - this.originY);
			superiorBezier.EP = new ED.Point(-320, 0 - this.originY);
			
			superiorBezierBack.SP = new ED.Point(-120 + 120, -380 - this.originY);
			superiorBezierBack.CP1 = new ED.Point(-240 + 160, -260 - this.originY);
			superiorBezierBack.CP2 = new ED.Point(-320 + 100, -160 - this.originY);
			superiorBezierBack.EP = new ED.Point(-320 + 100, 0 - this.originY);
		}
		
			
		if (tI0 > 0) {
		// Trim start of curve			
			
			// front of cornea
			var sq0 = new ED.Point(0,0);
			sq0.y = (1-tI0)*(1-tI0)*(1-tI0)*superiorBezier.SP.y + 3*(1-tI0)*(1-tI0)*tI0*superiorBezier.CP1.y + 3*(1-tI0)*tI0*tI0*superiorBezier.CP2.y + tI0*tI0*tI0*superiorBezier.EP.y;
			sq0.x = (1-tI0)*(1-tI0)*(1-tI0)*superiorBezier.SP.x + 3*(1-tI0)*(1-tI0)*tI0*superiorBezier.CP1.x + 3*(1-tI0)*tI0*tI0*superiorBezier.CP2.x + tI0*tI0*tI0*superiorBezier.EP.x;
			
			var iP23 = new ED.Point(0,0);
			iP23.x = superiorBezier.CP1.x + tI0 * (superiorBezier.CP2.x - superiorBezier.CP1.x);
			iP23.y = superiorBezier.CP1.y + tI0 * (superiorBezier.CP2.y - superiorBezier.CP1.y);
			
			var iP34 = new ED.Point(0,0);
			iP34.x = superiorBezier.CP2.x + tI0 * (superiorBezier.EP.x - superiorBezier.CP2.x);
			iP34.y = superiorBezier.CP2.y + tI0 * (superiorBezier.EP.y - superiorBezier.CP2.y);
			
			var iP2334 = new ED.Point(0,0);
			iP2334.x = iP23.x + tI0 * (iP34.x - iP23.x);
			iP2334.y = iP23.y + tI0 * (iP34.y - iP23.y);
			
			superiorBezier.SP = sq0;
			superiorBezier.CP1 = iP2334;
			superiorBezier.CP2 = iP34;
			
			
			// back of cornea
			var sq0b = new ED.Point(0,0);
			sq0b.y = (1-tI0)*(1-tI0)*(1-tI0)*superiorBezierBack.SP.y + 3*(1-tI0)*(1-tI0)*tI0*superiorBezierBack.CP1.y + 3*(1-tI0)*tI0*tI0*superiorBezierBack.CP2.y + tI0*tI0*tI0*superiorBezierBack.EP.y;
			sq0b.x = (1-tI0)*(1-tI0)*(1-tI0)*superiorBezierBack.SP.x + 3*(1-tI0)*(1-tI0)*tI0*superiorBezierBack.CP1.x + 3*(1-tI0)*tI0*tI0*superiorBezierBack.CP2.x + tI0*tI0*tI0*superiorBezierBack.EP.x;
			
			var iP23b = new ED.Point(0,0);
			iP23b.x = superiorBezierBack.CP1.x + tI0 * (superiorBezierBack.CP2.x - superiorBezierBack.CP1.x);
			iP23b.y = superiorBezierBack.CP1.y + tI0 * (superiorBezierBack.CP2.y - superiorBezierBack.CP1.y);
			
			var iP34b = new ED.Point(0,0);
			iP34b.x = superiorBezierBack.CP2.x + tI0 * (superiorBezierBack.EP.x - superiorBezierBack.CP2.x);
			iP34b.y = superiorBezierBack.CP2.y + tI0 * (superiorBezierBack.EP.y - superiorBezierBack.CP2.y);
			
			var iP2334b = new ED.Point(0,0);
			iP2334b.x = iP23b.x + tI0 * (iP34b.x - iP23b.x);
			iP2334b.y = iP23b.y + tI0 * (iP34b.y - iP23b.y);
			
			superiorBezierBack.SP = sq0b;
			superiorBezierBack.CP1 = iP2334b;
			superiorBezierBack.CP2 = iP34b;
		}
		
		if (tI1 < 1) {
		// Trim end of curve
			
			// front of cornea
			var iq1 = new ED.Point(0,0);
			iq1.y = (1-tI1)*(1-tI1)*(1-tI1)*superiorBezier.SP.y + 3*(1-tI1)*(1-tI1)*tI1*superiorBezier.CP1.y + 3*(1-tI1)*tI1*tI1*superiorBezier.CP2.y + tI1*tI1*tI1*superiorBezier.EP.y;
			iq1.x = (1-tI1)*(1-tI1)*(1-tI1)*superiorBezier.SP.x + 3*(1-tI1)*(1-tI1)*tI1*superiorBezier.CP1.x + 3*(1-tI1)*tI1*tI1*superiorBezier.CP2.x + tI1*tI1*tI1*superiorBezier.EP.x;

			var iP12 = new ED.Point(0,0);
			iP12.x = superiorBezier.SP.x + tI1 * (superiorBezier.CP1.x - superiorBezier.SP.x);
			iP12.y = superiorBezier.SP.y + tI1 * (superiorBezier.CP1.y - superiorBezier.SP.y);
			
			var iP23 = new ED.Point(0,0);
			iP23.x = superiorBezier.CP1.x + tI1 * (superiorBezier.CP2.x - superiorBezier.CP1.x);
			iP23.y = superiorBezier.CP1.y + tI1 * (superiorBezier.CP2.y - superiorBezier.CP1.y);
			
			var iP1223 = new ED.Point(0,0);
			iP1223.x = iP12.x + tI1 * (iP23.x - iP12.x);
			iP1223.y = iP12.y + tI1 * (iP23.y - iP12.y);
			
			superiorBezier.CP1 = iP12;
			superiorBezier.CP2 = iP1223;
			superiorBezier.EP = iq1;
			
			
			// back of cornea
			var iq1b = new ED.Point(0,0);
			iq1b.y = (1-tI1)*(1-tI1)*(1-tI1)*superiorBezierBack.SP.y + 3*(1-tI1)*(1-tI1)*tI1*superiorBezierBack.CP1.y + 3*(1-tI1)*tI1*tI1*superiorBezierBack.CP2.y + tI1*tI1*tI1*superiorBezierBack.EP.y;
			iq1b.x = (1-tI1)*(1-tI1)*(1-tI1)*superiorBezierBack.SP.x + 3*(1-tI1)*(1-tI1)*tI1*superiorBezierBack.CP1.x + 3*(1-tI1)*tI1*tI1*superiorBezierBack.CP2.x + tI1*tI1*tI1*superiorBezierBack.EP.x;

			var iP12b = new ED.Point(0,0);
			iP12b.x = superiorBezierBack.SP.x + tI1 * (superiorBezierBack.CP1.x - superiorBezierBack.SP.x);
			iP12b.y = superiorBezierBack.SP.y + tI1 * (superiorBezierBack.CP1.y - superiorBezierBack.SP.y);
			
			var iP23b = new ED.Point(0,0);
			iP23b.x = superiorBezierBack.CP1.x + tI1 * (superiorBezierBack.CP2.x - superiorBezierBack.CP1.x);
			iP23b.y = superiorBezierBack.CP1.y + tI1 * (superiorBezierBack.CP2.y - superiorBezierBack.CP1.y);
			
			var iP1223b = new ED.Point(0,0);
			iP1223b.x = iP12b.x + tI1 * (iP23b.x - iP12b.x);
			iP1223b.y = iP12b.y + tI1 * (iP23b.y - iP12b.y);
			
			superiorBezierBack.CP1 = iP12b;
			superiorBezierBack.CP2 = iP1223b;
			superiorBezierBack.EP = iq1b;
		}
	}
	
	
	if (endT > 0.5) {
		
		var inferiorBezier = new Object;
		var inferiorBezierBack = new Object;
		
		// define start and end time points
		var tS0 = (startT > 0.5) ? (startT - 0.5) * 2 : 0;
		var tS1 = (endT - 0.5) * 2;
		
		// default bezier points (as in cornea cross section)
		if (cornea && cornea.shape == "Keratoconus") {
			inferiorBezier.SP = new ED.Point(cornea.apexX, cornea.apexY - this.originY);
			inferiorBezier.CP1 = new ED.Point(cornea.apexX, cornea.apexY + 100 - this.originY);
			inferiorBezier.CP2 = new ED.Point(-240, 260 - this.originY);
			inferiorBezier.EP = new ED.Point(-120, 380 - this.originY);
			
			inferiorBezierBack.SP = new ED.Point(cornea.apexX + cornealThickness, cornea.apexY - this.originY);
			inferiorBezierBack.CP1 = new ED.Point(cornea.apexX + cornealThickness, cornea.apexY + 120 - this.originY);
			inferiorBezierBack.CP2 = new ED.Point(-240 + 160, 260 - this.originY);
			inferiorBezierBack.EP = new ED.Point(-120 + 120, 380 - this.originY);
		}
		else if (cornea && cornea.shape == "Keratoglobus") {
			inferiorBezier.SP = new ED.Point(-380, 100 - this.originY);
			inferiorBezier.CP1 = new ED.Point(-380, 200 - this.originY);
			inferiorBezier.CP2 = new ED.Point(-240, 360 - this.originY);
			inferiorBezier.EP = new ED.Point(-120, 380 - this.originY);
			
			inferiorBezierBack.SP = new ED.Point(-380 + 100, 100 - this.originY);
			inferiorBezierBack.CP1 = new ED.Point(-380 + 120, 220 - this.originY);
			inferiorBezierBack.CP2 = new ED.Point(-240 + 160, 260 - this.originY);
			inferiorBezierBack.EP = new ED.Point(-120 + 120, 380 - this.originY);
		}
		else {
			inferiorBezier.SP = new ED.Point(-320, -0 - this.originY);
			inferiorBezier.CP1 = new ED.Point(-320, 160 - this.originY);
			inferiorBezier.CP2 = new ED.Point(-240, 260 - this.originY);
			inferiorBezier.EP = new ED.Point(-120, 380 - this.originY);
			
			inferiorBezierBack.SP = new ED.Point(-320 + 100, -0 - this.originY);
			inferiorBezierBack.CP1 = new ED.Point(-320 + 100, 160 - this.originY);
			inferiorBezierBack.CP2 = new ED.Point(-240 + 160, 260 - this.originY);
			inferiorBezierBack.EP = new ED.Point(-120 + 120, 380 - this.originY);
		}			
		
		
		if (tS0 > 0) {
		// Trim start of curve
		
			// front of cornea			
			var sq0 = new ED.Point(0,0);
			sq0.y = (1-tS0)*(1-tS0)*(1-tS0)*inferiorBezier.SP.y + 3*(1-tS0)*(1-tS0)*tS0*inferiorBezier.CP1.y + 3*(1-tS0)*tS0*tS0*inferiorBezier.CP2.y + tS0*tS0*tS0*inferiorBezier.EP.y;
			sq0.x = (1-tS0)*(1-tS0)*(1-tS0)*inferiorBezier.SP.x + 3*(1-tS0)*(1-tS0)*tS0*inferiorBezier.CP1.x + 3*(1-tS0)*tS0*tS0*inferiorBezier.CP2.x + tS0*tS0*tS0*inferiorBezier.EP.x;
			
			var sP23 = new ED.Point(0,0);
			sP23.x = inferiorBezier.CP1.x + tS0 * (inferiorBezier.CP2.x - inferiorBezier.CP1.x);
			sP23.y = inferiorBezier.CP1.y + tS0 * (inferiorBezier.CP2.y - inferiorBezier.CP1.y);
			
			var sP34 = new ED.Point(0,0);
			sP34.x = inferiorBezier.CP2.x + tS0 * (inferiorBezier.EP.x - inferiorBezier.CP2.x);
			sP34.y = inferiorBezier.CP2.y + tS0 * (inferiorBezier.EP.y - inferiorBezier.CP2.y);
			
			var sP2334 = new ED.Point(0,0);
			sP2334.x = sP23.x + tS0 * (sP34.x - sP23.x);
			sP2334.y = sP23.y + tS0 * (sP34.y - sP23.y);
			
			inferiorBezier.SP = sq0;
			inferiorBezier.CP1 = sP2334;
			inferiorBezier.CP2 = sP34;
			
			// back of cornea
			var sq0b = new ED.Point(0,0);
			sq0b.y = (1-tS0)*(1-tS0)*(1-tS0)*inferiorBezierBack.SP.y + 3*(1-tS0)*(1-tS0)*tS0*inferiorBezierBack.CP1.y + 3*(1-tS0)*tS0*tS0*inferiorBezierBack.CP2.y + tS0*tS0*tS0*inferiorBezierBack.EP.y;
			sq0b.x = (1-tS0)*(1-tS0)*(1-tS0)*inferiorBezierBack.SP.x + 3*(1-tS0)*(1-tS0)*tS0*inferiorBezierBack.CP1.x + 3*(1-tS0)*tS0*tS0*inferiorBezierBack.CP2.x + tS0*tS0*tS0*inferiorBezierBack.EP.x;
			
			var sP23b = new ED.Point(0,0);
			sP23b.x = inferiorBezierBack.CP1.x + tS0 * (inferiorBezierBack.CP2.x - inferiorBezierBack.CP1.x);
			sP23b.y = inferiorBezierBack.CP1.y + tS0 * (inferiorBezierBack.CP2.y - inferiorBezierBack.CP1.y);
			
			var sP34b = new ED.Point(0,0);
			sP34b.x = inferiorBezierBack.CP2.x + tS0 * (inferiorBezierBack.EP.x - inferiorBezierBack.CP2.x);
			sP34b.y = inferiorBezierBack.CP2.y + tS0 * (inferiorBezierBack.EP.y - inferiorBezierBack.CP2.y);
			
			var sP2334b = new ED.Point(0,0);
			sP2334b.x = sP23b.x + tS0 * (sP34b.x - sP23b.x);
			sP2334b.y = sP23b.y + tS0 * (sP34b.y - sP23b.y);
			
			inferiorBezierBack.SP = sq0b;
			inferiorBezierBack.CP1 = sP2334b;
			inferiorBezierBack.CP2 = sP34b;
		}
		
		if (tS1 < 1) {
		// Trim end of curve
		
			// front of cornea
			var sq1 = new ED.Point(0,0);
			sq1.y = (1-tS1)*(1-tS1)*(1-tS1)*inferiorBezier.SP.y + 3*(1-tS1)*(1-tS1)*tS1*inferiorBezier.CP1.y + 3*(1-tS1)*tS1*tS1*inferiorBezier.CP2.y + tS1*tS1*tS1*inferiorBezier.EP.y;
			sq1.x = (1-tS1)*(1-tS1)*(1-tS1)*inferiorBezier.SP.x + 3*(1-tS1)*(1-tS1)*tS1*inferiorBezier.CP1.x + 3*(1-tS1)*tS1*tS1*inferiorBezier.CP2.x + tS1*tS1*tS1*inferiorBezier.EP.x;

			var sP12 = new ED.Point(0,0);
			sP12.x = inferiorBezier.SP.x + tS1 * (inferiorBezier.CP1.x - inferiorBezier.SP.x);
			sP12.y = inferiorBezier.SP.y + tS1 * (inferiorBezier.CP1.y - inferiorBezier.SP.y);
			
			var sP23 = new ED.Point(0,0);
			sP23.x = inferiorBezier.CP1.x + tS1 * (inferiorBezier.CP2.x - inferiorBezier.CP1.x);
			sP23.y = inferiorBezier.CP1.y + tS1 * (inferiorBezier.CP2.y - inferiorBezier.CP1.y);
			
			var sP1223 = new ED.Point(0,0);
			sP1223.x = sP12.x + tS1 * (sP23.x - sP12.x);
			sP1223.y = sP12.y + tS1 * (sP23.y - sP12.y);

			inferiorBezier.CP1 = sP12;
			inferiorBezier.CP2 = sP1223;
			inferiorBezier.EP = sq1;
			
			
			// back of cornea
			var sq1b = new ED.Point(0,0);
			sq1b.y = (1-tS1)*(1-tS1)*(1-tS1)*inferiorBezierBack.SP.y + 3*(1-tS1)*(1-tS1)*tS1*inferiorBezierBack.CP1.y + 3*(1-tS1)*tS1*tS1*inferiorBezierBack.CP2.y + tS1*tS1*tS1*inferiorBezierBack.EP.y;
			sq1b.x = (1-tS1)*(1-tS1)*(1-tS1)*inferiorBezierBack.SP.x + 3*(1-tS1)*(1-tS1)*tS1*inferiorBezierBack.CP1.x + 3*(1-tS1)*tS1*tS1*inferiorBezierBack.CP2.x + tS1*tS1*tS1*inferiorBezierBack.EP.x;

			var sP12b = new ED.Point(0,0);
			sP12b.x = inferiorBezierBack.SP.x + tS1 * (inferiorBezierBack.CP1.x - inferiorBezierBack.SP.x);
			sP12b.y = inferiorBezierBack.SP.y + tS1 * (inferiorBezierBack.CP1.y - inferiorBezierBack.SP.y);
			
			var sP23b = new ED.Point(0,0);
			sP23b.x = inferiorBezierBack.CP1.x + tS1 * (inferiorBezierBack.CP2.x - inferiorBezierBack.CP1.x);
			sP23b.y = inferiorBezierBack.CP1.y + tS1 * (inferiorBezierBack.CP2.y - inferiorBezierBack.CP1.y);
			
			var sP1223b = new ED.Point(0,0);
			sP1223b.x = sP12b.x + tS1 * (sP23b.x - sP12b.x);
			sP1223b.y = sP12b.y + tS1 * (sP23b.y - sP12b.y);

			inferiorBezierBack.CP1 = sP12b;
			inferiorBezierBack.CP2 = sP1223b;
			inferiorBezierBack.EP = sq1b;
		}
	}
	
	if (inferiorBezier) {
		ctx.moveTo(inferiorBezierBack.EP.x, inferiorBezierBack.EP.y);
		ctx.bezierCurveTo(inferiorBezierBack.CP2.x, inferiorBezierBack.CP2.y, inferiorBezierBack.CP1.x, inferiorBezierBack.CP1.y, inferiorBezierBack.SP.x, inferiorBezierBack.SP.y);
		ctx.lineTo(inferiorBezier.SP.x, inferiorBezier.SP.y);
		ctx.bezierCurveTo(inferiorBezier.CP1.x, inferiorBezier.CP1.y, inferiorBezier.CP2.x, inferiorBezier.CP2.y, inferiorBezier.EP.x, inferiorBezier.EP.y);
	}
	if (superiorBezier) {
		ctx.moveTo(superiorBezierBack.EP.x, superiorBezierBack.EP.y);
		ctx.bezierCurveTo(superiorBezierBack.CP2.x, superiorBezierBack.CP2.y, superiorBezierBack.CP1.x, superiorBezierBack.CP1.y, superiorBezierBack.SP.x, superiorBezierBack.SP.y);
		ctx.lineTo(superiorBezier.SP.x, superiorBezier.SP.y);
		ctx.bezierCurveTo(superiorBezier.CP1.x, superiorBezier.CP1.y, superiorBezier.CP2.x, superiorBezier.CP2.y, superiorBezier.EP.x, superiorBezier.EP.y);
	}
	
	
	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 0;
	if (this.str == 1) {
		switch (this.intensity) {
			case 'Mild':
				ctx.fillStyle = "rgba(0, 0, 255, 0.2)";
				break;
			case 'Moderate':
				ctx.fillStyle = ctx.createPattern(this.drawing.imageArray['OedemaPattern'], 'repeat');
				break;
			case 'Severe':
				ctx.fillStyle = ctx.createPattern(this.drawing.imageArray['OedemaPatternBullous'], 'repeat');
				break;
		}
	}
	else ctx.fillStyle = "rgba(0,0,0,0)";
	ctx.strokeStyle = "rgba(0,0,0,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
		
	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// epithelium
		if (this.epi == 1) {
			ctx.beginPath();
			
			if (inferiorBezier) {
				ctx.moveTo(inferiorBezier.SP.x, inferiorBezier.SP.y);
				ctx.bezierCurveTo(inferiorBezier.CP1.x, inferiorBezier.CP1.y, inferiorBezier.CP2.x, inferiorBezier.CP2.y, inferiorBezier.EP.x, inferiorBezier.EP.y);
			}
			if (superiorBezier) {
				ctx.moveTo(superiorBezier.SP.x, superiorBezier.SP.y);
				ctx.bezierCurveTo(superiorBezier.CP1.x, superiorBezier.CP1.y, superiorBezier.CP2.x, superiorBezier.CP2.y, superiorBezier.EP.x, superiorBezier.EP.y);
			}
			switch (this.intensity) {
				case 'Mild':
					ctx.strokeStyle = "rgba(0, 0, 255, 0.2)";
					break;
				case 'Moderate':
					ctx.strokeStyle = "rgba(0, 0, 255, 0.3)";
					break;
				case 'Severe':
					ctx.strokeStyle = "rgba(0, 0, 255, 0.4)";
					break;
			}
			ctx.lineWidth = 8;
			ctx.stroke();
		}
		
		// endothelium
		if (this.endo == 1) {
			ctx.beginPath();
			
			if (inferiorBezier) {
				ctx.moveTo(inferiorBezierBack.SP.x, inferiorBezierBack.SP.y);
				ctx.bezierCurveTo(inferiorBezierBack.CP1.x, inferiorBezierBack.CP1.y, inferiorBezierBack.CP2.x, inferiorBezierBack.CP2.y, inferiorBezierBack.EP.x, inferiorBezierBack.EP.y);
			}
			if (superiorBezier) {
				ctx.moveTo(superiorBezierBack.SP.x, superiorBezierBack.SP.y);
				ctx.bezierCurveTo(superiorBezierBack.CP1.x, superiorBezierBack.CP1.y, superiorBezierBack.CP2.x, superiorBezierBack.CP2.y, superiorBezierBack.EP.x, superiorBezierBack.EP.y);
			}
			switch (this.intensity) {
				case 'Mild':
					ctx.strokeStyle = "rgba(0, 0, 255, 0.2)";
					break;
				case 'Moderate':
					ctx.strokeStyle = "rgba(0, 0, 255, 0.3)";
					break;
				case 'Severe':
					ctx.strokeStyle = "rgba(0, 0, 255, 0.4)";
					break;
			}
			ctx.lineWidth = 8;
			ctx.stroke();
		}
	}
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
	
}



/**
 * OpenEyes
 * MSC
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * TODO: infiltrate control point definitions 
 *
 * @class CornealOpacity
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealOpacity = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealOpacity";

	// Private parameters
	this.numberOfHandles = 4;
	this.initialRadius = 81;
	this.resetWidth = true;
	this.resetInfiltrate = true;

	this.bezierTimeIntervals = [0.0,0.125,0.25,0.375,0.50,0.625,0.75,0.875,1];
	this.minX = this.minY = this.initialRadius * -1;
	this.maxX = this.maxY = this.initialRadius;
	
	// Other parameters
	this.height = Math.round(this.initialRadius * 2 / 54);
	this.width = Math.round(this.initialRadius * 2 / 54);
	this.depth = 33;
	this.infiltrateWidth = 0;
		
	this.h = Math.round(this.initialRadius * 2 / 54);
	this.w = Math.round(this.initialRadius * 2 / 54);
	this.d = 33;
	this.iW = 0;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'rotation', 'height', 'width', 'depth', 'infiltrateWidth','h','w','d','iW','minY','maxY'];
	
	// Parameters in doodle control bar
	this.controlParameterArray = {'height':'Height', 'width':'Width', 'depth':'Depth (%)', 'infiltrateWidth':'Infiltrate width'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CornealOpacity.prototype = new ED.Doodle;
ED.CornealOpacity.prototype.constructor = ED.CornealOpacity;
ED.CornealOpacity.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CornealOpacity.prototype.setHandles = function() {
	// Array of handles
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	}

	// Allow top handle to rotate doodle
	/// ? Removed as need specific handles to be along X and Y axis - can change... **TODO**
// 	this.handleArray[0].isRotatable = true;
}

/**
 * Sets default properties
 */
ED.CornealOpacity.prototype.setPropertyDefaults = function() {
	// Create ranges to constrain handles
	this.handleVectorRangeArray = new Array();
	for (var i = 0; i < this.numberOfHandles; i++) {
		// Full circle in radians
		var cir = 2 * Math.PI;

		// Create a range object for each handle
		/// **TODO**: Ideally relative to canvas centre, not doodle - when update originX or originY
		var n = this.numberOfHandles;
		var range = new Object;
		range.length = new ED.Range(+50, +380);
		range.angle = new ED.Range((((2 * n - 1) * cir / (2 * n)) + i * cir / n) % cir, ((1 * cir / (2 * n)) + i * cir / n) % cir);
		this.handleVectorRangeArray[i] = range;
	}
	
	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-350, +350);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-350, +350);
	
	// Validation arrays for other parameters
	this.parameterValidationArray['height'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(1, 14),
		precision: 1,
		animate: false
	};
	this.parameterValidationArray['width'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(1, 14),
		precision: 1,
		animate: false
	};
	this.parameterValidationArray['depth'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(1, 100),
		precision: 1,
		animate: false
	};
	this.parameterValidationArray['infiltrateWidth'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(0, 15),
		precision: 1,
		animate: false
	};
	this.parameterValidationArray['h'] = {
		kind: 'other',
		type: 'int',
		range: [1, 14],
		animate: false
	};
	this.parameterValidationArray['w'] = {
		kind: 'other',
		type: 'int',
		range: [1, 14],
		animate: false
	};
	this.parameterValidationArray['iW'] = {
		kind: 'other',
		type: 'int',
		range: [0, 15],
		animate: false
	};
	this.parameterValidationArray['d'] = {
		kind: 'other',
		type: 'int',
		range: [1, 100],
		animate: false
	};
	this.parameterValidationArray['resetWidth'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
	this.parameterValidationArray['resetInfiltrate'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
	this.parameterValidationArray['minY'] = {
		kind: 'other',
		type: 'int',
		range: [-500,500],
		animate: false
	};
	this.parameterValidationArray['maxY'] = {
		kind: 'other',
		type: 'int',
		range: [-500,500],
		animate: false
	};
	
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.CornealOpacity.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'width':
			returnArray['resetWidth'] = true;
			returnArray['w'] = parseInt(_value);
			break;

		case 'height':
			this.squiggleArray[0].pointsArray[0].y = 0.5 * _value * -54;
			this.squiggleArray[0].pointsArray[2].y = 0.5 * _value * 54;
			returnArray['h'] = parseInt(_value);
			returnArray['minY'] = this.calculateMinY();
			returnArray['maxY'] = this.calculateMaxY();
			break;
			
		case 'infiltrateWidth':
			returnArray['resetInfiltrate'] = true;
			returnArray['iW'] = parseInt(_value);
			break;
		
		case 'depth':
			returnArray['d'] = parseInt(_value);
			break;
			
		case 'h':
			returnArray['h'] = _value;
			break;
		
		case 'd':
			returnArray['depth'] = _value;
			break;
			
		case 'w':
			returnArray['w'] = _value;
			break;
		
		case 'iW':
			returnArray['infiltrateWidth'] = _value;
			break;
			
		case 'minY':
			returnArray['minY'] = _value;
			break;
			
		case 'maxY':
			returnArray['maxY'] = _value;
			break;
			
		case 'handles':
			returnArray['w'] = this.calculateWidth();
			returnArray['h'] = this.calculateHeight();
			returnArray['height'] = this.calculateHeight();
			returnArray['minY'] = this.calculateMinY();
			returnArray['maxY'] = this.calculateMaxY();
			break;
	}

	return returnArray;
}

/**
 * Sets default parameters
 */
ED.CornealOpacity.prototype.setParameterDefaults = function() {
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		var np = new ED.Point(doodle.originX + 100, 1);
		this.move(np.x, np.y);
	} else {
		this.move(100, 1);
	}

	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate with handles at equidistant points around circumference
	for (var i = 0; i < this.numberOfHandles; i++) {
		var point = new ED.Point(0, 0);
		point.setWithPolars(this.initialRadius, i * 2 * Math.PI / this.numberOfHandles);
		this.addPointToSquiggle(point);
	}
	for (var i = 0; i < this.numberOfHandles; i++) {
		var point = new ED.Point(0, 0);
		point.setWithPolars(this.initialRadius, i * 2 * Math.PI / this.numberOfHandles);
		this.addPointToSquiggle(point);
	}
};

// Angle of control point from radius line to point (this value makes path a circle Math.PI/12 for 8 points
ED.CornealOpacity.prototype.getPhi = function()
{
	return 2 * Math.PI / (3 * this.numberOfHandles);
};

ED.CornealOpacity.prototype.calculateWidth = function()
{
	/// solve bezier to find min and max point along axis
	var maxX = '';
	var minX = '';

	var phi = this.getPhi();

	var squiggle = this.squiggleArray[0];
	for (var i=0; i<this.numberOfHandles; i++) {
		fp = this.squiggleArray[0].pointsArray[i];
		var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
		tp = this.squiggleArray[0].pointsArray[toIndex];
		var x1 = fp.x;
		var x2 = fp.tangentialControlPoint(+phi).x;
		var x3 = tp.tangentialControlPoint(-phi).x;
		var x4 = tp.x;

		for (var j=0; j<this.bezierTimeIntervals.length; j++) {
			var t = this.bezierTimeIntervals[j];
			var x = (1-t)*(1-t)*(1-t)*x1 + 3*(1-t)*(1-t)*t*x2 + 3*(1-t)*t*t*x3 + t*t*t*x4;
			if (maxX == '' || x > maxX) {
				maxX = x;
			}
			if (minX == '' || x < minX) {
				minX = x;
			}
		}
	}
	this.maxX = maxX;
	this.minX = minX;
	return Math.round((maxX - minX) / 54);
};

ED.CornealOpacity.prototype.calculateHeight = function()
{
	// recalculate height /// solve bezier to find min and max point along axis
	var minY = this.calculateMinY();
	var maxY = this.calculateMaxY();

	return Math.round((maxY - minY) / 54);
};

ED.CornealOpacity.prototype.calculateMinY = function() {
	// recalculate height/// solve bezier to find min and max point along axis
	var phi = this.getPhi();
	var minY = '';

	var squiggle = this.squiggleArray[0];
	for (var i=0; i<this.numberOfHandles; i++) {
		fp = this.squiggleArray[0].pointsArray[i];
		var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
		tp = this.squiggleArray[0].pointsArray[toIndex];
		var y1 = fp.y;
		var y2 = fp.tangentialControlPoint(+phi).y;
		var y3 = tp.tangentialControlPoint(-phi).y;
		var y4 = tp.y;

		for (var j=0; j<this.bezierTimeIntervals.length; j++) {
			var t = this.bezierTimeIntervals[j];
			var y = (1-t)*(1-t)*(1-t)*y1 + 3*(1-t)*(1-t)*t*y2 + 3*(1-t)*t*t*y3 + t*t*t*y4;
			if (minY == '' || y <= minY) {
				minY = y;
			}
		}
	}
	return minY;
}
ED.CornealOpacity.prototype.calculateMaxY = function() {
	// recalculate height/// solve bezier to find min and max point along axis
	var phi = this.getPhi();
	var minY = '';
	var maxY = '';

	var squiggle = this.squiggleArray[0];
	for (var i=0; i<this.numberOfHandles; i++) {
		fp = this.squiggleArray[0].pointsArray[i];
		var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
		tp = this.squiggleArray[0].pointsArray[toIndex];
		var y1 = fp.y;
		var y2 = fp.tangentialControlPoint(+phi).y;
		var y3 = tp.tangentialControlPoint(-phi).y;
		var y4 = tp.y;

		for (var j=0; j<this.bezierTimeIntervals.length; j++) {
			var t = this.bezierTimeIntervals[j];
			var y = (1-t)*(1-t)*(1-t)*y1 + 3*(1-t)*(1-t)*t*y2 + 3*(1-t)*t*t*y3 + t*t*t*y4;
			if (maxY == '' || y > maxY) {
				maxY = y;
			}
			if (minY == '' || y < minY) {
				minY = y;
			}
		}
	}

	return maxY;
}


/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealOpacity.prototype.draw = function(_point) {
	
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CornealOpacity.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Bezier points
	var fp;
	var tp;
	var cp1;
	var cp2;

	var phi = this.getPhi();
	
	// If inputted a dimension, reset pointsArray,
	// otherwise recalculate dimension
	if (this.resetWidth) {
		this.squiggleArray[0].pointsArray[1].x = 0.5 * this.width * 54;
		this.squiggleArray[0].pointsArray[3].x = 0.5 * this.width * -54;

		this.resetWidth = false;
	}
	else {
		this.width = this.calculateWidth();
	}
	
	
	// Start curve
	ctx.moveTo(this.squiggleArray[0].pointsArray[0].x, this.squiggleArray[0].pointsArray[0].y);

	// Complete curve segments
	for (var i = 0; i < this.numberOfHandles; i++) {
		// From and to points
		fp = this.squiggleArray[0].pointsArray[i];
		var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
		tp = this.squiggleArray[0].pointsArray[toIndex];

		// Control points
		cp1 = fp.tangentialControlPoint(+phi);
		cp2 = tp.tangentialControlPoint(-phi);
		
		// Draw Bezier curve
		ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);
	}

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "gray";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Coordinates of expert handles (in canvas plane)
	for (var i = 0; i < this.numberOfHandles /* * 2 */; i++) {
		this.handleArray[i].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[i]);
	}
			

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		
		// Infiltrate
		if (this.infiltrateWidth > 0) {
			// Convert infiltrate width to doodle scale
			var iW = this.infiltrateWidth * 54;
			var n = this.numberOfHandles;
			
			var infiltratePoints = [];

			// If do not exist, create extra handles for infiltrate boundary
// 			if (this.resetInfiltrate) {
				// redefine infiltrate control points based on width
				this.resetInfiltrate = false;
				for (var i=0; i<this.numberOfHandles; i++) {
					var handle = this.squiggleArray[0].pointsArray[i];
					var x = Math.abs(handle.x);
					var y = Math.abs(handle.y);
					
					// Length of new handle from origin
					var h = Math.sqrt(x*x + y*y) + iW;
					
					// Angle of handle from origin
					var theta = Math.atan(y/x);
					
					// Height of new point above origin
					var o = h * Math.sin(theta);
					// X displacement of new point from origin
					var a = h * Math.cos(theta);
					
					// get sign of handle coordinates
					var xS = (handle.x>=0) ? 1 : -1;
					var yS = (handle.y>=0) ? 1 : -1;
					
					var p = new ED.Point(a * xS, o * yS);
					infiltratePoints.push(p);
					
					this.squiggleArray[0].pointsArray[n+i] = p;				
				}
// 			}
			
			// Draw infiltrate
			ctx.beginPath();
			ctx.moveTo(this.squiggleArray[0].pointsArray[4].x, this.squiggleArray[0].pointsArray[4].y);
			// Complete curve segments
			for (var j=0; j< this.numberOfHandles; j++) {
				// From and to points
				fp = this.squiggleArray[0].pointsArray[j + n];
				var toIndex = (j < this.numberOfHandles - 1) ? j + 1 + n : this.numberOfHandles;
				tp = this.squiggleArray[0].pointsArray[toIndex];
		
				// Control points
				cp1 = fp.tangentialControlPoint(+phi);
				cp2 = tp.tangentialControlPoint(-phi);
		
				// Draw Bezier curve
				ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);
			}
			ctx.fillStyle = "rgba(0,0,0,0.2)";
			ctx.fill();
			
			// Flood fill shape on ontop of gradient
			ctx.beginPath();
			ctx.moveTo(this.squiggleArray[0].pointsArray[0].x, this.squiggleArray[0].pointsArray[0].y);
			// Complete curve segments
			for (var i = 0; i < this.numberOfHandles; i++) {
				// From and to points
				fp = this.squiggleArray[0].pointsArray[i];
				var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
				tp = this.squiggleArray[0].pointsArray[toIndex];
		
				// Control points
				cp1 = fp.tangentialControlPoint(+phi);
				cp2 = tp.tangentialControlPoint(-phi);
		
				// Draw Bezier curve
				ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);
			}
			ctx.fillStyle = "gray";
			ctx.stroke();
			ctx.fill();
		}
	}
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CornealOpacity.prototype.description = function() {
	return 'Corneal opacity: H-W: ' + this.height + 'x' + this.width + 'mm // Stromal depth: ' + this.depth + '% // Infiltrate width: ' + this.infiltrateWidth + 'mm';
}

/**
 * OpenEyes
 * MSC
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * TODO: shape contour, fix length of line calculation for corneas where the apex is not along the origin
 *
 * @class CornealOpacityCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealOpacityCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealOpacityCrossSection";

	// Private parameters
	this.initialRadius = 81;
	
	// Other parameters
	this.height = Math.round(this.initialRadius * 2 / 54);
	this.width = Math.round(this.initialRadius * 2 / 54);
	this.depth = 33;
	this.infiltrateWidth = 0;
	
	this.h = Math.round(this.initialRadius * 2 / 54);
	this.w = Math.round(this.initialRadius * 2 / 54);
	this.d = 33;
	this.iW = 0;
	
	this.minY = this.initialRadius * -1;
	this.maxY = this.initialRadius;
	
	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'height', 'width', 'depth', 'infiltrateWidth','h','w','d','iW','minY','maxY'];
	
	// Parameters in doodle control bar
	this.controlParameterArray = {'height':'Height', 'width':'Width', 'depth':'Depth (%)', 'infiltrateWidth':'Infiltrate width'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

    this.linkedDoodleParameters = {
        'CornealOpacity': {
            source: ['yMidPoint','d','h','w','iW','originY','minY','maxY']
        }
    };
}

/**
 * Sets superclass and constructor
 */
ED.CornealOpacityCrossSection.prototype = new ED.Doodle;
ED.CornealOpacityCrossSection.prototype.constructor = ED.CornealOpacityCrossSection;
ED.CornealOpacityCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CornealOpacityCrossSection.prototype.setHandles = function() {
}

/**
 * Sets default properties
 */
ED.CornealOpacityCrossSection.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
		
	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(+50, +50);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-500, +500);
	
	// Validation arrays for other parameters
	this.parameterValidationArray['height'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(1, 14),
		precision: 1,
		animate: false
	};
	this.parameterValidationArray['width'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(1, 14),
		precision: 1,
		animate: false
	};
	this.parameterValidationArray['depth'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(1, 100),
		precision: 1,
		animate: false
	};
	this.parameterValidationArray['infiltrateWidth'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(0, 15),
		precision: 1,
		animate: false
	};
	this.parameterValidationArray['h'] = {
		kind: 'other',
		type: 'int',
		range: [1, 14],
		animate: false
	};
	this.parameterValidationArray['w'] = {
		kind: 'other',
		type: 'int',
		range: [1, 14],
		animate: false
	};this.parameterValidationArray['iW'] = {
		kind: 'other',
		type: 'int',
		range: [0, 15],
		animate: false
	};
	this.parameterValidationArray['d'] = {
		kind: 'other',
		type: 'int',
		range: [1, 100],
		animate: false
	};
	this.parameterValidationArray['minY'] = {
		kind: 'other',
		type: 'int',
		range: [-500,500],
		animate: false
	};
	this.parameterValidationArray['maxY'] = {
		kind: 'other',
		type: 'int',
		range: [-500,500],
		animate: false
	};
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.CornealOpacityCrossSection.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'width':
			returnArray['w'] = parseInt(_value);
			break;

		case 'height':
			returnArray['h'] = parseInt(_value);
			break;
			
		case 'infiltrateWidth':
			returnArray['iW'] = parseInt(_value);
			break;
		
		case 'depth':
			returnArray['d'] = parseInt(_value);
			break;
			
		case 'h':
			returnArray['height'] = _value;
			break;
		
		case 'd':
			returnArray['depth'] = _value;
			break;
			
		case 'w':
			returnArray['width'] = _value;
			break;
		
		case 'iW':
			returnArray['infiltrateWidth'] = _value;
			break;

	}

	return returnArray;
}

/**
 * Sets default parameters
 */
ED.CornealOpacityCrossSection.prototype.setParameterDefaults = function() {

	this.originX = 50; // as is in Cornea cross section doodle to dulicate bezier control points
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealOpacityCrossSection.prototype.draw = function(_point) {

	// Get context
	var ctx = this.drawing.context;

	var cornea = this.drawing.lastDoodleOfClass('CorneaCrossSection');
	var cornealThickness = cornea.pachymetry/5;

	// Call draw method in superclass
	ED.CornealOpacityCrossSection.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();
	
	// Calculate segment extent in terms of time along curve
	var startY = this.minY + this.originY;
	var endY = this.maxY + this.originY;
	
	var startT = (startY + 380) / 760;
	if (startT<0) startT = 0;
	var endT = (endY + 380) / 760;
	if (endT>1) endT = 1;
		
	if (startT < 0.5) {
		
		var superiorBezier = new Object;
		var superiorBezierBack = new Object;

		// define start and end time points
		var tI0 = startT * 2;
		var tI1 = (endT < 0.5) ? endT * 2 : 1;
		
		// default bezier points (as in cornea cross section)
		if (cornea && cornea.shape == "Keratoconus") {
			superiorBezier.SP = new ED.Point(-120, -380 - this.originY);
			superiorBezier.CP1 = new ED.Point(-240, -260 - this.originY);
			superiorBezier.CP2 = new ED.Point(cornea.apexX, cornea.apexY - 100 - this.originY);
			superiorBezier.EP = new ED.Point(cornea.apexX, cornea.apexY - this.originY);
			
			superiorBezierBack.SP = new ED.Point(-120 + 120*this.depth/100, -380 - this.originY);
			superiorBezierBack.CP1 = new ED.Point(-240 + 160*this.depth/100, -260 - this.originY);
			superiorBezierBack.CP2 = new ED.Point(cornea.apexX + cornealThickness*this.depth/100, cornea.apexY - 120 - this.originY);
			superiorBezierBack.EP = new ED.Point(cornea.apexX + cornealThickness*this.depth/100, cornea.apexY - this.originY);
		}
		else if (cornea && cornea.shape == "Keratoglobus") {
			superiorBezier.SP = new ED.Point(-120, -380 - this.originY);
			superiorBezier.CP1 = new ED.Point(-240, -260 - this.originY);
			superiorBezier.CP2 = new ED.Point(-380, -100 - this.originY);
			superiorBezier.EP = new ED.Point(-380, 100 - this.originY);
			
			superiorBezierBack.SP = new ED.Point(-120 + 120*this.depth/100, -380 - this.originY);
			superiorBezierBack.CP1 = new ED.Point(-240 + 120*this.depth/100, -200 - this.originY);
			superiorBezierBack.CP2 = new ED.Point(-380 + 100*this.depth/100, -140 - this.originY);
			superiorBezierBack.EP = new ED.Point(-380 + 100*this.depth/100, 100 - this.originY);
		}
		else {
			superiorBezier.SP = new ED.Point(-120, -380 - this.originY);
			superiorBezier.CP1 = new ED.Point(-240, -260 - this.originY);
			superiorBezier.CP2 = new ED.Point(-320, -160 - this.originY);
			superiorBezier.EP = new ED.Point(-320, 0 - this.originY);
			
			superiorBezierBack.SP = new ED.Point(-120 + 120*this.depth/100, -380 - this.originY);
			superiorBezierBack.CP1 = new ED.Point(-240 + 160*this.depth/100, -260 - this.originY);
			superiorBezierBack.CP2 = new ED.Point(-320 + 100*this.depth/100, -160 - this.originY);
			superiorBezierBack.EP = new ED.Point(-320 + 100*this.depth/100, 0 - this.originY);
		}
		
			
		if (tI0 > 0) {
		// Trim start of curve			
			
			// front of cornea
			var sq0 = new ED.Point(0,0);
			sq0.y = (1-tI0)*(1-tI0)*(1-tI0)*superiorBezier.SP.y + 3*(1-tI0)*(1-tI0)*tI0*superiorBezier.CP1.y + 3*(1-tI0)*tI0*tI0*superiorBezier.CP2.y + tI0*tI0*tI0*superiorBezier.EP.y;
			sq0.x = (1-tI0)*(1-tI0)*(1-tI0)*superiorBezier.SP.x + 3*(1-tI0)*(1-tI0)*tI0*superiorBezier.CP1.x + 3*(1-tI0)*tI0*tI0*superiorBezier.CP2.x + tI0*tI0*tI0*superiorBezier.EP.x;
			
			var iP23 = new ED.Point(0,0);
			iP23.x = superiorBezier.CP1.x + tI0 * (superiorBezier.CP2.x - superiorBezier.CP1.x);
			iP23.y = superiorBezier.CP1.y + tI0 * (superiorBezier.CP2.y - superiorBezier.CP1.y);
			
			var iP34 = new ED.Point(0,0);
			iP34.x = superiorBezier.CP2.x + tI0 * (superiorBezier.EP.x - superiorBezier.CP2.x);
			iP34.y = superiorBezier.CP2.y + tI0 * (superiorBezier.EP.y - superiorBezier.CP2.y);
			
			var iP2334 = new ED.Point(0,0);
			iP2334.x = iP23.x + tI0 * (iP34.x - iP23.x);
			iP2334.y = iP23.y + tI0 * (iP34.y - iP23.y);
			
			superiorBezier.SP = sq0;
			superiorBezier.CP1 = iP2334;
			superiorBezier.CP2 = iP34;
			
			
			// back of cornea
			var sq0b = new ED.Point(0,0);
			sq0b.y = (1-tI0)*(1-tI0)*(1-tI0)*superiorBezierBack.SP.y + 3*(1-tI0)*(1-tI0)*tI0*superiorBezierBack.CP1.y + 3*(1-tI0)*tI0*tI0*superiorBezierBack.CP2.y + tI0*tI0*tI0*superiorBezierBack.EP.y;
			sq0b.x = (1-tI0)*(1-tI0)*(1-tI0)*superiorBezierBack.SP.x + 3*(1-tI0)*(1-tI0)*tI0*superiorBezierBack.CP1.x + 3*(1-tI0)*tI0*tI0*superiorBezierBack.CP2.x + tI0*tI0*tI0*superiorBezierBack.EP.x;
			
			var iP23b = new ED.Point(0,0);
			iP23b.x = superiorBezierBack.CP1.x + tI0 * (superiorBezierBack.CP2.x - superiorBezierBack.CP1.x);
			iP23b.y = superiorBezierBack.CP1.y + tI0 * (superiorBezierBack.CP2.y - superiorBezierBack.CP1.y);
			
			var iP34b = new ED.Point(0,0);
			iP34b.x = superiorBezierBack.CP2.x + tI0 * (superiorBezierBack.EP.x - superiorBezierBack.CP2.x);
			iP34b.y = superiorBezierBack.CP2.y + tI0 * (superiorBezierBack.EP.y - superiorBezierBack.CP2.y);
			
			var iP2334b = new ED.Point(0,0);
			iP2334b.x = iP23b.x + tI0 * (iP34b.x - iP23b.x);
			iP2334b.y = iP23b.y + tI0 * (iP34b.y - iP23b.y);
			
			superiorBezierBack.SP = sq0b;
			superiorBezierBack.CP1 = iP2334b;
			superiorBezierBack.CP2 = iP34b;
		}
		
		if (tI1 < 1) {
		// Trim end of curve
			
			// front of cornea
			var iq1 = new ED.Point(0,0);
			iq1.y = (1-tI1)*(1-tI1)*(1-tI1)*superiorBezier.SP.y + 3*(1-tI1)*(1-tI1)*tI1*superiorBezier.CP1.y + 3*(1-tI1)*tI1*tI1*superiorBezier.CP2.y + tI1*tI1*tI1*superiorBezier.EP.y;
			iq1.x = (1-tI1)*(1-tI1)*(1-tI1)*superiorBezier.SP.x + 3*(1-tI1)*(1-tI1)*tI1*superiorBezier.CP1.x + 3*(1-tI1)*tI1*tI1*superiorBezier.CP2.x + tI1*tI1*tI1*superiorBezier.EP.x;

			var iP12 = new ED.Point(0,0);
			iP12.x = superiorBezier.SP.x + tI1 * (superiorBezier.CP1.x - superiorBezier.SP.x);
			iP12.y = superiorBezier.SP.y + tI1 * (superiorBezier.CP1.y - superiorBezier.SP.y);
			
			var iP23 = new ED.Point(0,0);
			iP23.x = superiorBezier.CP1.x + tI1 * (superiorBezier.CP2.x - superiorBezier.CP1.x);
			iP23.y = superiorBezier.CP1.y + tI1 * (superiorBezier.CP2.y - superiorBezier.CP1.y);
			
			var iP1223 = new ED.Point(0,0);
			iP1223.x = iP12.x + tI1 * (iP23.x - iP12.x);
			iP1223.y = iP12.y + tI1 * (iP23.y - iP12.y);
			
			superiorBezier.CP1 = iP12;
			superiorBezier.CP2 = iP1223;
			superiorBezier.EP = iq1;
			
			
			// back of cornea
			var iq1b = new ED.Point(0,0);
			iq1b.y = (1-tI1)*(1-tI1)*(1-tI1)*superiorBezierBack.SP.y + 3*(1-tI1)*(1-tI1)*tI1*superiorBezierBack.CP1.y + 3*(1-tI1)*tI1*tI1*superiorBezierBack.CP2.y + tI1*tI1*tI1*superiorBezierBack.EP.y;
			iq1b.x = (1-tI1)*(1-tI1)*(1-tI1)*superiorBezierBack.SP.x + 3*(1-tI1)*(1-tI1)*tI1*superiorBezierBack.CP1.x + 3*(1-tI1)*tI1*tI1*superiorBezierBack.CP2.x + tI1*tI1*tI1*superiorBezierBack.EP.x;

			var iP12b = new ED.Point(0,0);
			iP12b.x = superiorBezierBack.SP.x + tI1 * (superiorBezierBack.CP1.x - superiorBezierBack.SP.x);
			iP12b.y = superiorBezierBack.SP.y + tI1 * (superiorBezierBack.CP1.y - superiorBezierBack.SP.y);
			
			var iP23b = new ED.Point(0,0);
			iP23b.x = superiorBezierBack.CP1.x + tI1 * (superiorBezierBack.CP2.x - superiorBezierBack.CP1.x);
			iP23b.y = superiorBezierBack.CP1.y + tI1 * (superiorBezierBack.CP2.y - superiorBezierBack.CP1.y);
			
			var iP1223b = new ED.Point(0,0);
			iP1223b.x = iP12b.x + tI1 * (iP23b.x - iP12b.x);
			iP1223b.y = iP12b.y + tI1 * (iP23b.y - iP12b.y);
			
			superiorBezierBack.CP1 = iP12b;
			superiorBezierBack.CP2 = iP1223b;
			superiorBezierBack.EP = iq1b;
		}
	}
	
	
	if (endT > 0.5) {
		
		var inferiorBezier = new Object;
		var inferiorBezierBack = new Object;
		
		// define start and end time points
		var tS0 = (startT > 0.5) ? (startT - 0.5) * 2 : 0;
		var tS1 = (endT - 0.5) * 2;
		
		// default bezier points (as in cornea cross section)
		if (cornea && cornea.shape == "Keratoconus") {
			inferiorBezier.SP = new ED.Point(cornea.apexX, cornea.apexY - this.originY);
			inferiorBezier.CP1 = new ED.Point(cornea.apexX, cornea.apexY + 100 - this.originY);
			inferiorBezier.CP2 = new ED.Point(-240, 260 - this.originY);
			inferiorBezier.EP = new ED.Point(-120, 380 - this.originY);
			
			inferiorBezierBack.SP = new ED.Point(cornea.apexX + cornealThickness*this.depth/100, cornea.apexY - this.originY);
			inferiorBezierBack.CP1 = new ED.Point(cornea.apexX + cornealThickness*this.depth/100, cornea.apexY + 120 - this.originY);
			inferiorBezierBack.CP2 = new ED.Point(-240 + 160*this.depth/100, 260 - this.originY);
			inferiorBezierBack.EP = new ED.Point(-120 + 120*this.depth/100, 380 - this.originY);
		}
		else if (cornea && cornea.shape == "Keratoglobus") {
			inferiorBezier.SP = new ED.Point(-380, 100 - this.originY);
			inferiorBezier.CP1 = new ED.Point(-380, 200 - this.originY);
			inferiorBezier.CP2 = new ED.Point(-240, 360 - this.originY);
			inferiorBezier.EP = new ED.Point(-120, 380 - this.originY);
			
			inferiorBezierBack.SP = new ED.Point(-380 + 100*this.depth/100, 100 - this.originY);
			inferiorBezierBack.CP1 = new ED.Point(-380 + 120*this.depth/100, 220 - this.originY);
			inferiorBezierBack.CP2 = new ED.Point(-240 + 160*this.depth/100, 260 - this.originY);
			inferiorBezierBack.EP = new ED.Point(-120 + 120*this.depth/100, 380 - this.originY);
		}
		else {
			inferiorBezier.SP = new ED.Point(-320, -0 - this.originY);
			inferiorBezier.CP1 = new ED.Point(-320, 160 - this.originY);
			inferiorBezier.CP2 = new ED.Point(-240, 260 - this.originY);
			inferiorBezier.EP = new ED.Point(-120, 380 - this.originY);
			
			inferiorBezierBack.SP = new ED.Point(-320 + 100*this.depth/100, -0 - this.originY);
			inferiorBezierBack.CP1 = new ED.Point(-320 + 100*this.depth/100, 160 - this.originY);
			inferiorBezierBack.CP2 = new ED.Point(-240 + 160*this.depth/100, 260 - this.originY);
			inferiorBezierBack.EP = new ED.Point(-120 + 120*this.depth/100, 380 - this.originY);
		}			
		
		
		if (tS0 > 0) {
		// Trim start of curve
		
			// front of cornea			
			var sq0 = new ED.Point(0,0);
			sq0.y = (1-tS0)*(1-tS0)*(1-tS0)*inferiorBezier.SP.y + 3*(1-tS0)*(1-tS0)*tS0*inferiorBezier.CP1.y + 3*(1-tS0)*tS0*tS0*inferiorBezier.CP2.y + tS0*tS0*tS0*inferiorBezier.EP.y;
			sq0.x = (1-tS0)*(1-tS0)*(1-tS0)*inferiorBezier.SP.x + 3*(1-tS0)*(1-tS0)*tS0*inferiorBezier.CP1.x + 3*(1-tS0)*tS0*tS0*inferiorBezier.CP2.x + tS0*tS0*tS0*inferiorBezier.EP.x;
			
			var sP23 = new ED.Point(0,0);
			sP23.x = inferiorBezier.CP1.x + tS0 * (inferiorBezier.CP2.x - inferiorBezier.CP1.x);
			sP23.y = inferiorBezier.CP1.y + tS0 * (inferiorBezier.CP2.y - inferiorBezier.CP1.y);
			
			var sP34 = new ED.Point(0,0);
			sP34.x = inferiorBezier.CP2.x + tS0 * (inferiorBezier.EP.x - inferiorBezier.CP2.x);
			sP34.y = inferiorBezier.CP2.y + tS0 * (inferiorBezier.EP.y - inferiorBezier.CP2.y);
			
			var sP2334 = new ED.Point(0,0);
			sP2334.x = sP23.x + tS0 * (sP34.x - sP23.x);
			sP2334.y = sP23.y + tS0 * (sP34.y - sP23.y);
			
			inferiorBezier.SP = sq0;
			inferiorBezier.CP1 = sP2334;
			inferiorBezier.CP2 = sP34;
			
			// back of cornea
			var sq0b = new ED.Point(0,0);
			sq0b.y = (1-tS0)*(1-tS0)*(1-tS0)*inferiorBezierBack.SP.y + 3*(1-tS0)*(1-tS0)*tS0*inferiorBezierBack.CP1.y + 3*(1-tS0)*tS0*tS0*inferiorBezierBack.CP2.y + tS0*tS0*tS0*inferiorBezierBack.EP.y;
			sq0b.x = (1-tS0)*(1-tS0)*(1-tS0)*inferiorBezierBack.SP.x + 3*(1-tS0)*(1-tS0)*tS0*inferiorBezierBack.CP1.x + 3*(1-tS0)*tS0*tS0*inferiorBezierBack.CP2.x + tS0*tS0*tS0*inferiorBezierBack.EP.x;
			
			var sP23b = new ED.Point(0,0);
			sP23b.x = inferiorBezierBack.CP1.x + tS0 * (inferiorBezierBack.CP2.x - inferiorBezierBack.CP1.x);
			sP23b.y = inferiorBezierBack.CP1.y + tS0 * (inferiorBezierBack.CP2.y - inferiorBezierBack.CP1.y);
			
			var sP34b = new ED.Point(0,0);
			sP34b.x = inferiorBezierBack.CP2.x + tS0 * (inferiorBezierBack.EP.x - inferiorBezierBack.CP2.x);
			sP34b.y = inferiorBezierBack.CP2.y + tS0 * (inferiorBezierBack.EP.y - inferiorBezierBack.CP2.y);
			
			var sP2334b = new ED.Point(0,0);
			sP2334b.x = sP23b.x + tS0 * (sP34b.x - sP23b.x);
			sP2334b.y = sP23b.y + tS0 * (sP34b.y - sP23b.y);
			
			inferiorBezierBack.SP = sq0b;
			inferiorBezierBack.CP1 = sP2334b;
			inferiorBezierBack.CP2 = sP34b;
		}
		
		if (tS1 < 1) {
		// Trim end of curve
		
			// front of cornea
			var sq1 = new ED.Point(0,0);
			sq1.y = (1-tS1)*(1-tS1)*(1-tS1)*inferiorBezier.SP.y + 3*(1-tS1)*(1-tS1)*tS1*inferiorBezier.CP1.y + 3*(1-tS1)*tS1*tS1*inferiorBezier.CP2.y + tS1*tS1*tS1*inferiorBezier.EP.y;
			sq1.x = (1-tS1)*(1-tS1)*(1-tS1)*inferiorBezier.SP.x + 3*(1-tS1)*(1-tS1)*tS1*inferiorBezier.CP1.x + 3*(1-tS1)*tS1*tS1*inferiorBezier.CP2.x + tS1*tS1*tS1*inferiorBezier.EP.x;

			var sP12 = new ED.Point(0,0);
			sP12.x = inferiorBezier.SP.x + tS1 * (inferiorBezier.CP1.x - inferiorBezier.SP.x);
			sP12.y = inferiorBezier.SP.y + tS1 * (inferiorBezier.CP1.y - inferiorBezier.SP.y);
			
			var sP23 = new ED.Point(0,0);
			sP23.x = inferiorBezier.CP1.x + tS1 * (inferiorBezier.CP2.x - inferiorBezier.CP1.x);
			sP23.y = inferiorBezier.CP1.y + tS1 * (inferiorBezier.CP2.y - inferiorBezier.CP1.y);
			
			var sP1223 = new ED.Point(0,0);
			sP1223.x = sP12.x + tS1 * (sP23.x - sP12.x);
			sP1223.y = sP12.y + tS1 * (sP23.y - sP12.y);

			inferiorBezier.CP1 = sP12;
			inferiorBezier.CP2 = sP1223;
			inferiorBezier.EP = sq1;
			
			
			// back of cornea
			var sq1b = new ED.Point(0,0);
			sq1b.y = (1-tS1)*(1-tS1)*(1-tS1)*inferiorBezierBack.SP.y + 3*(1-tS1)*(1-tS1)*tS1*inferiorBezierBack.CP1.y + 3*(1-tS1)*tS1*tS1*inferiorBezierBack.CP2.y + tS1*tS1*tS1*inferiorBezierBack.EP.y;
			sq1b.x = (1-tS1)*(1-tS1)*(1-tS1)*inferiorBezierBack.SP.x + 3*(1-tS1)*(1-tS1)*tS1*inferiorBezierBack.CP1.x + 3*(1-tS1)*tS1*tS1*inferiorBezierBack.CP2.x + tS1*tS1*tS1*inferiorBezierBack.EP.x;

			var sP12b = new ED.Point(0,0);
			sP12b.x = inferiorBezierBack.SP.x + tS1 * (inferiorBezierBack.CP1.x - inferiorBezierBack.SP.x);
			sP12b.y = inferiorBezierBack.SP.y + tS1 * (inferiorBezierBack.CP1.y - inferiorBezierBack.SP.y);
			
			var sP23b = new ED.Point(0,0);
			sP23b.x = inferiorBezierBack.CP1.x + tS1 * (inferiorBezierBack.CP2.x - inferiorBezierBack.CP1.x);
			sP23b.y = inferiorBezierBack.CP1.y + tS1 * (inferiorBezierBack.CP2.y - inferiorBezierBack.CP1.y);
			
			var sP1223b = new ED.Point(0,0);
			sP1223b.x = sP12b.x + tS1 * (sP23b.x - sP12b.x);
			sP1223b.y = sP12b.y + tS1 * (sP23b.y - sP12b.y);

			inferiorBezierBack.CP1 = sP12b;
			inferiorBezierBack.CP2 = sP1223b;
			inferiorBezierBack.EP = sq1b;
		}
	}
	
	if (inferiorBezier) {
		ctx.moveTo(inferiorBezierBack.EP.x, inferiorBezierBack.EP.y);
		ctx.bezierCurveTo(inferiorBezierBack.CP2.x, inferiorBezierBack.CP2.y, inferiorBezierBack.CP1.x, inferiorBezierBack.CP1.y, inferiorBezierBack.SP.x, inferiorBezierBack.SP.y);
		ctx.lineTo(inferiorBezier.SP.x, inferiorBezier.SP.y);
		ctx.bezierCurveTo(inferiorBezier.CP1.x, inferiorBezier.CP1.y, inferiorBezier.CP2.x, inferiorBezier.CP2.y, inferiorBezier.EP.x, inferiorBezier.EP.y);
	}
	if (superiorBezier) {
		ctx.moveTo(superiorBezierBack.EP.x, superiorBezierBack.EP.y);
		ctx.bezierCurveTo(superiorBezierBack.CP2.x, superiorBezierBack.CP2.y, superiorBezierBack.CP1.x, superiorBezierBack.CP1.y, superiorBezierBack.SP.x, superiorBezierBack.SP.y);
		ctx.lineTo(superiorBezier.SP.x, superiorBezier.SP.y);
		ctx.bezierCurveTo(superiorBezier.CP1.x, superiorBezier.CP1.y, superiorBezier.CP2.x, superiorBezier.CP2.y, superiorBezier.EP.x, superiorBezier.EP.y);
	}
	
	
	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "gray";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
		
	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		
		// Infiltrate
		if (this.infiltrateWidth > 0) {
			// Re do all calculations, with extra length and width proportional to infiltrate width
			var iEndY = this.maxY + this.originY + 0.5 * this.infiltrateWidth * 2 * 54;
			var iStartY = this.minY + this.originY - 0.5 * this.infiltrateWidth * 2 * 54;
			
			var iStartT = (iStartY + 380) / 760;
			if (iStartT<0) iStartT = 0;
			var iEndT = (iEndY + 380) / 760;
			if (iEndT>1) iEndT = 1;
			
			var averageDimension = (this.height + this.width) / 2;
			var averageDimensionTotal = (this.height + this.width + 4*this.infiltrateWidth) / 2;
			
			var infiltrateScale = this.depth / averageDimension * averageDimensionTotal;
			if (infiltrateScale > 100) infiltrateScale = 100;
				
			if (iStartT < 0.5) {
				
				var iSuperiorBezier = new Object;
				var iSuperiorBezierBack = new Object;
		
				// define start and end time points
				var itI0 = iStartT * 2;
				var itI1 = (iEndT < 0.5) ? iEndT * 2 : 1;
				var ibtI0 = itI0 * infiltrateScale/100;
/* 				if (ibtI0 < itI0)  */ibtI0 = itI0;
				var ibtI1 = itI1 * infiltrateScale/100;
/* 				if (ibtI1 > itI1) */ ibtI1 = itI1;
						
				// default bezier points (as in cornea cross section)
				if (cornea && cornea.shape == "Keratoconus") {
					iSuperiorBezier.SP = new ED.Point(-120, -380 - this.originY);
					iSuperiorBezier.CP1 = new ED.Point(-240, -260 - this.originY);
					iSuperiorBezier.CP2 = new ED.Point(cornea.apexX, cornea.apexY - 100 - this.originY);
					iSuperiorBezier.EP = new ED.Point(cornea.apexX, cornea.apexY - this.originY);
					
					iSuperiorBezierBack.SP = new ED.Point(-120 + 120*infiltrateScale/100, -380 - this.originY);
					iSuperiorBezierBack.CP1 = new ED.Point(-240 + 160*infiltrateScale/100, -260 - this.originY);
					iSuperiorBezierBack.CP2 = new ED.Point(cornea.apexX + cornealThickness*infiltrateScale/100, cornea.apexY - 120 - this.originY);
					iSuperiorBezierBack.EP = new ED.Point(cornea.apexX + cornealThickness*infiltrateScale/100, cornea.apexY - this.originY);
				}
				else if (cornea && cornea.shape == "Keratoglobus") {
					iSuperiorBezier.SP = new ED.Point(-120, -380 - this.originY);
					iSuperiorBezier.CP1 = new ED.Point(-240, -260 - this.originY);
					iSuperiorBezier.CP2 = new ED.Point(-380, -100 - this.originY);
					iSuperiorBezier.EP = new ED.Point(-380, 100 - this.originY);
					
					iSuperiorBezierBack.SP = new ED.Point(-120 + 120*infiltrateScale/100, -380 - this.originY);
					iSuperiorBezierBack.CP1 = new ED.Point(-240 + 120*infiltrateScale/100, -200 - this.originY);
					iSuperiorBezierBack.CP2 = new ED.Point(-380 + 100*infiltrateScale/100, -140 - this.originY);
					iSuperiorBezierBack.EP = new ED.Point(-380 + 100*infiltrateScale/100, 100 - this.originY);
				}
				else {
					iSuperiorBezier.SP = new ED.Point(-120, -380 - this.originY);
					iSuperiorBezier.CP1 = new ED.Point(-240, -260 - this.originY);
					iSuperiorBezier.CP2 = new ED.Point(-320, -160 - this.originY);
					iSuperiorBezier.EP = new ED.Point(-320, 0 - this.originY);
					
					iSuperiorBezierBack.SP = new ED.Point(-120 + 120*infiltrateScale/100, -380 - this.originY);
					iSuperiorBezierBack.CP1 = new ED.Point(-240 + 160*infiltrateScale/100, -260 - this.originY);
					iSuperiorBezierBack.CP2 = new ED.Point(-320 + 100*infiltrateScale/100, -160 - this.originY);
					iSuperiorBezierBack.EP = new ED.Point(-320 + 100*infiltrateScale/100, 0 - this.originY);
				}
				
					
				if (itI0 > 0) {
				// Trim start of curve
				
					// front of cornea			
					var isq0 = new ED.Point(0,0);
					isq0.y = (1-itI0)*(1-itI0)*(1-itI0)*iSuperiorBezier.SP.y + 3*(1-itI0)*(1-itI0)*itI0*iSuperiorBezier.CP1.y + 3*(1-itI0)*itI0*itI0*iSuperiorBezier.CP2.y + itI0*itI0*itI0*iSuperiorBezier.EP.y;
					isq0.x = (1-itI0)*(1-itI0)*(1-itI0)*iSuperiorBezier.SP.x + 3*(1-itI0)*(1-itI0)*itI0*iSuperiorBezier.CP1.x + 3*(1-itI0)*itI0*itI0*iSuperiorBezier.CP2.x + itI0*itI0*itI0*iSuperiorBezier.EP.x;
					
					var iiP23 = new ED.Point(0,0);
					iiP23.x = iSuperiorBezier.CP1.x + itI0 * (iSuperiorBezier.CP2.x - iSuperiorBezier.CP1.x);
					iiP23.y = iSuperiorBezier.CP1.y + itI0 * (iSuperiorBezier.CP2.y - iSuperiorBezier.CP1.y);
					
					var iiP34 = new ED.Point(0,0);
					iiP34.x = iSuperiorBezier.CP2.x + itI0 * (iSuperiorBezier.EP.x - iSuperiorBezier.CP2.x);
					iiP34.y = iSuperiorBezier.CP2.y + itI0 * (iSuperiorBezier.EP.y - iSuperiorBezier.CP2.y);
					
					var iiP2334 = new ED.Point(0,0);
					iiP2334.x = iiP23.x + itI0 * (iiP34.x - iiP23.x);
					iiP2334.y = iiP23.y + itI0 * (iiP34.y - iiP23.y);
					
					iSuperiorBezier.SP = isq0;
					iSuperiorBezier.CP1 = iiP2334;
					iSuperiorBezier.CP2 = iiP34;
				}
				if (ibtI0 > 0) {
		
					// back of cornea
					var isq0b = new ED.Point(0,0);
					isq0b.y = (1-ibtI0)*(1-ibtI0)*(1-ibtI0)*iSuperiorBezierBack.SP.y + 3*(1-ibtI0)*(1-ibtI0)*ibtI0*iSuperiorBezierBack.CP1.y + 3*(1-ibtI0)*ibtI0*ibtI0*iSuperiorBezierBack.CP2.y + ibtI0*ibtI0*ibtI0*iSuperiorBezierBack.EP.y;
					isq0b.x = (1-ibtI0)*(1-ibtI0)*(1-ibtI0)*iSuperiorBezierBack.SP.x + 3*(1-ibtI0)*(1-ibtI0)*ibtI0*iSuperiorBezierBack.CP1.x + 3*(1-ibtI0)*ibtI0*ibtI0*iSuperiorBezierBack.CP2.x + ibtI0*ibtI0*ibtI0*iSuperiorBezierBack.EP.x;
					
					var iiP23b = new ED.Point(0,0);
					iiP23b.x = iSuperiorBezierBack.CP1.x + ibtI0 * (iSuperiorBezierBack.CP2.x - iSuperiorBezierBack.CP1.x);
					iiP23b.y = iSuperiorBezierBack.CP1.y + ibtI0 * (iSuperiorBezierBack.CP2.y - iSuperiorBezierBack.CP1.y);
					
					var iiP34b = new ED.Point(0,0);
					iiP34b.x = iSuperiorBezierBack.CP2.x + ibtI0 * (iSuperiorBezierBack.EP.x - iSuperiorBezierBack.CP2.x);
					iiP34b.y = iSuperiorBezierBack.CP2.y + ibtI0 * (iSuperiorBezierBack.EP.y - iSuperiorBezierBack.CP2.y);
					
					var iiP2334b = new ED.Point(0,0);
					iiP2334b.x = iiP23b.x + ibtI0 * (iiP34b.x - iiP23b.x);
					iiP2334b.y = iiP23b.y + ibtI0 * (iiP34b.y - iiP23b.y);
					
					iSuperiorBezierBack.SP = isq0b;
					iSuperiorBezierBack.CP1 = iiP2334b;
					iSuperiorBezierBack.CP2 = iiP34b;
				}
				
				if (itI1 < 1) {
				// Trim end of curve
					
					// front of cornea
					var iiq1 = new ED.Point(0,0);
					iiq1.y = (1-itI1)*(1-itI1)*(1-itI1)*iSuperiorBezier.SP.y + 3*(1-itI1)*(1-itI1)*itI1*iSuperiorBezier.CP1.y + 3*(1-itI1)*itI1*itI1*iSuperiorBezier.CP2.y + itI1*itI1*itI1*iSuperiorBezier.EP.y;
					iiq1.x = (1-itI1)*(1-itI1)*(1-itI1)*iSuperiorBezier.SP.x + 3*(1-itI1)*(1-itI1)*itI1*iSuperiorBezier.CP1.x + 3*(1-itI1)*itI1*itI1*iSuperiorBezier.CP2.x + itI1*itI1*itI1*iSuperiorBezier.EP.x;
		
					var iiP12 = new ED.Point(0,0);
					iiP12.x = iSuperiorBezier.SP.x + itI1 * (iSuperiorBezier.CP1.x - iSuperiorBezier.SP.x);
					iiP12.y = iSuperiorBezier.SP.y + itI1 * (iSuperiorBezier.CP1.y - iSuperiorBezier.SP.y);
					
					var iiP23 = new ED.Point(0,0);
					iiP23.x = iSuperiorBezier.CP1.x + itI1 * (iSuperiorBezier.CP2.x - iSuperiorBezier.CP1.x);
					iiP23.y = iSuperiorBezier.CP1.y + itI1 * (iSuperiorBezier.CP2.y - iSuperiorBezier.CP1.y);
					
					var iiP1223 = new ED.Point(0,0);
					iiP1223.x = iiP12.x + itI1 * (iiP23.x - iiP12.x);
					iiP1223.y = iiP12.y + itI1 * (iiP23.y - iiP12.y);
					
					iSuperiorBezier.CP1 = iiP12;
					iSuperiorBezier.CP2 = iiP1223;
					iSuperiorBezier.EP = iiq1;
				
				}
				if (ibtI1 > 0) {
					// back of cornea
					var iiq1b = new ED.Point(0,0);
					iiq1b.y = (1-ibtI1)*(1-ibtI1)*(1-ibtI1)*iSuperiorBezierBack.SP.y + 3*(1-ibtI1)*(1-ibtI1)*ibtI1*iSuperiorBezierBack.CP1.y + 3*(1-ibtI1)*ibtI1*ibtI1*iSuperiorBezierBack.CP2.y + ibtI1*ibtI1*ibtI1*iSuperiorBezierBack.EP.y;
					iiq1b.x = (1-ibtI1)*(1-ibtI1)*(1-ibtI1)*iSuperiorBezierBack.SP.x + 3*(1-ibtI1)*(1-ibtI1)*ibtI1*iSuperiorBezierBack.CP1.x + 3*(1-ibtI1)*ibtI1*ibtI1*iSuperiorBezierBack.CP2.x + ibtI1*ibtI1*ibtI1*iSuperiorBezierBack.EP.x;
		
					var iiP12b = new ED.Point(0,0);
					iiP12b.x = iSuperiorBezierBack.SP.x + ibtI1 * (iSuperiorBezierBack.CP1.x - iSuperiorBezierBack.SP.x);
					iiP12b.y = iSuperiorBezierBack.SP.y + ibtI1 * (iSuperiorBezierBack.CP1.y - iSuperiorBezierBack.SP.y);
					
					var iiP23b = new ED.Point(0,0);
					iiP23b.x = iSuperiorBezierBack.CP1.x + ibtI1 * (iSuperiorBezierBack.CP2.x - iSuperiorBezierBack.CP1.x);
					iiP23b.y = iSuperiorBezierBack.CP1.y + ibtI1 * (iSuperiorBezierBack.CP2.y - iSuperiorBezierBack.CP1.y);
					
					var iiP1223b = new ED.Point(0,0);
					iiP1223b.x = iiP12b.x + ibtI1 * (iiP23b.x - iiP12b.x);
					iiP1223b.y = iiP12b.y + ibtI1 * (iiP23b.y - iiP12b.y);
					
					iSuperiorBezierBack.CP1 = iiP12b;
					iSuperiorBezierBack.CP2 = iiP1223b;
					iSuperiorBezierBack.EP = iiq1b;
				}
			
			}
			
			
			if (iEndT > 0.5) {
				
				var iInferiorBezier = new Object;
				var iInferiorBezierBack = new Object;
				
				// define start and end time points
				var itS0 = (iStartT > 0.5) ? (iStartT - 0.5) * 2 : 0;
				var itS1 = (iEndT - 0.5) * 2;
				var ibtS0 = itS0 * infiltrateScale/100;
/* 				if (ibtS0<tS0) */ ibtS0 = itS0;
				var ibtS1 = itS1 * infiltrateScale/100;
/* 				if (ibtS1>tS1) */ ibtS1 = itS1;
				
				// default bezier points (as in cornea cross section)
				if (cornea && cornea.shape == "Keratoconus") {
					iInferiorBezier.SP = new ED.Point(cornea.apexX, cornea.apexY - this.originY);
					iInferiorBezier.CP1 = new ED.Point(cornea.apexX, cornea.apexY + 100 - this.originY);
					iInferiorBezier.CP2 = new ED.Point(-240, 260 - this.originY);
					iInferiorBezier.EP = new ED.Point(-120, 380 - this.originY);
					
					iInferiorBezierBack.SP = new ED.Point(cornea.apexX + cornealThickness*infiltrateScale/100, cornea.apexY - this.originY);
					iInferiorBezierBack.CP1 = new ED.Point(cornea.apexX + cornealThickness*infiltrateScale/100, cornea.apexY + 120 - this.originY);
					iInferiorBezierBack.CP2 = new ED.Point(-240 + 160*infiltrateScale/100, 260 - this.originY);
					iInferiorBezierBack.EP = new ED.Point(-120 + 120*infiltrateScale/100, 380 - this.originY);
				}
				else if (cornea && cornea.shape == "Keratoglobus") {
					iInferiorBezier.SP = new ED.Point(-380, 100 - this.originY);
					iInferiorBezier.CP1 = new ED.Point(-380, 200 - this.originY);
					iInferiorBezier.CP2 = new ED.Point(-240, 360 - this.originY);
					iInferiorBezier.EP = new ED.Point(-120, 380 - this.originY);
					
					iInferiorBezierBack.SP = new ED.Point(-380 + 100*infiltrateScale/100, 100 - this.originY);
					iInferiorBezierBack.CP1 = new ED.Point(-380 + 120*infiltrateScale/100, 220 - this.originY);
					iInferiorBezierBack.CP2 = new ED.Point(-240 + 160*infiltrateScale/100, 260 - this.originY);
					iInferiorBezierBack.EP = new ED.Point(-120 + 120*infiltrateScale/100, 380 - this.originY);
				}
				else {
					iInferiorBezier.SP = new ED.Point(-320, -0 - this.originY);
					iInferiorBezier.CP1 = new ED.Point(-320, 160 - this.originY);
					iInferiorBezier.CP2 = new ED.Point(-240, 260 - this.originY);
					iInferiorBezier.EP = new ED.Point(-120, 380 - this.originY);
					
					iInferiorBezierBack.SP = new ED.Point(-320 + 100*infiltrateScale/100, -0 - this.originY);
					iInferiorBezierBack.CP1 = new ED.Point(-320 + 100*infiltrateScale/100, 160 - this.originY);
					iInferiorBezierBack.CP2 = new ED.Point(-240 + 160*infiltrateScale/100, 260 - this.originY);
					iInferiorBezierBack.EP = new ED.Point(-120 + 120*infiltrateScale/100, 380 - this.originY);
				}	
				
				if (itS0 > 0) {
				// Trim start of curve	
				
					// front of cornea		
					var isq0 = new ED.Point(0,0);
					isq0.y = (1-itS0)*(1-itS0)*(1-itS0)*iInferiorBezier.SP.y + 3*(1-itS0)*(1-itS0)*itS0*iInferiorBezier.CP1.y + 3*(1-itS0)*itS0*itS0*iInferiorBezier.CP2.y + itS0*itS0*itS0*iInferiorBezier.EP.y;
					isq0.x = (1-itS0)*(1-itS0)*(1-itS0)*iInferiorBezier.SP.x + 3*(1-itS0)*(1-itS0)*itS0*iInferiorBezier.CP1.x + 3*(1-itS0)*itS0*itS0*iInferiorBezier.CP2.x + itS0*itS0*itS0*iInferiorBezier.EP.x;
					
					var isP23 = new ED.Point(0,0);
					isP23.x = iInferiorBezier.CP1.x + itS0 * (iInferiorBezier.CP2.x - iInferiorBezier.CP1.x);
					isP23.y = iInferiorBezier.CP1.y + itS0 * (iInferiorBezier.CP2.y - iInferiorBezier.CP1.y);
					
					var isP34 = new ED.Point(0,0);
					isP34.x = iInferiorBezier.CP2.x + itS0 * (iInferiorBezier.EP.x - iInferiorBezier.CP2.x);
					isP34.y = iInferiorBezier.CP2.y + itS0 * (iInferiorBezier.EP.y - iInferiorBezier.CP2.y);
					
					var isP2334 = new ED.Point(0,0);
					isP2334.x = isP23.x + itS0 * (isP34.x - isP23.x);
					isP2334.y = isP23.y + itS0 * (isP34.y - isP23.y);
					
					iInferiorBezier.SP = isq0;
					iInferiorBezier.CP1 = isP2334;
					iInferiorBezier.CP2 = isP34;
				}
				if (ibtS0 > 0) {	
					// back of cornea
					var isq0b = new ED.Point(0,0);
					isq0b.y = (1-ibtS0)*(1-ibtS0)*(1-ibtS0)*iInferiorBezierBack.SP.y + 3*(1-ibtS0)*(1-ibtS0)*ibtS0*iInferiorBezierBack.CP1.y + 3*(1-ibtS0)*ibtS0*ibtS0*iInferiorBezierBack.CP2.y + ibtS0*ibtS0*ibtS0*iInferiorBezierBack.EP.y;
					isq0b.x = (1-ibtS0)*(1-ibtS0)*(1-ibtS0)*iInferiorBezierBack.SP.x + 3*(1-ibtS0)*(1-ibtS0)*ibtS0*iInferiorBezierBack.CP1.x + 3*(1-ibtS0)*ibtS0*ibtS0*iInferiorBezierBack.CP2.x + ibtS0*ibtS0*ibtS0*iInferiorBezierBack.EP.x;
					
					var isP23b = new ED.Point(0,0);
					isP23b.x = iInferiorBezierBack.CP1.x + ibtS0 * (iInferiorBezierBack.CP2.x - iInferiorBezierBack.CP1.x);
					isP23b.y = iInferiorBezierBack.CP1.y + ibtS0 * (iInferiorBezierBack.CP2.y - iInferiorBezierBack.CP1.y);
					
					var isP34b = new ED.Point(0,0);
					isP34b.x = iInferiorBezierBack.CP2.x + ibtS0 * (iInferiorBezierBack.EP.x - iInferiorBezierBack.CP2.x);
					isP34b.y = iInferiorBezierBack.CP2.y + ibtS0 * (iInferiorBezierBack.EP.y - iInferiorBezierBack.CP2.y);
					
					var isP2334b = new ED.Point(0,0);
					isP2334b.x = isP23b.x + ibtS0 * (isP34b.x - isP23b.x);
					isP2334b.y = isP23b.y + ibtS0 * (isP34b.y - isP23b.y);
					
					iInferiorBezierBack.SP = isq0b;
					iInferiorBezierBack.CP1 = isP2334b;
					iInferiorBezierBack.CP2 = isP34b;
				}
				
				if (itS1 < 1) {
				// Trim end of curve
				
					// front of cornea
					var isq1 = new ED.Point(0,0);
					isq1.y = (1-itS1)*(1-itS1)*(1-itS1)*iInferiorBezier.SP.y + 3*(1-itS1)*(1-itS1)*itS1*iInferiorBezier.CP1.y + 3*(1-itS1)*itS1*itS1*iInferiorBezier.CP2.y + itS1*itS1*itS1*iInferiorBezier.EP.y;
					isq1.x = (1-itS1)*(1-itS1)*(1-itS1)*iInferiorBezier.SP.x + 3*(1-itS1)*(1-itS1)*itS1*iInferiorBezier.CP1.x + 3*(1-itS1)*itS1*itS1*iInferiorBezier.CP2.x + itS1*itS1*itS1*iInferiorBezier.EP.x;
		
					var isP12 = new ED.Point(0,0);
					isP12.x = iInferiorBezier.SP.x + itS1 * (iInferiorBezier.CP1.x - iInferiorBezier.SP.x);
					isP12.y = iInferiorBezier.SP.y + itS1 * (iInferiorBezier.CP1.y - iInferiorBezier.SP.y);
					
					var isP23 = new ED.Point(0,0);
					isP23.x = iInferiorBezier.CP1.x + itS1 * (iInferiorBezier.CP2.x - iInferiorBezier.CP1.x);
					isP23.y = iInferiorBezier.CP1.y + itS1 * (iInferiorBezier.CP2.y - iInferiorBezier.CP1.y);
					
					var isP1223 = new ED.Point(0,0);
					isP1223.x = isP12.x + itS1 * (isP23.x - isP12.x);
					isP1223.y = isP12.y + itS1 * (isP23.y - isP12.y);
		
					iInferiorBezier.CP1 = isP12;
					iInferiorBezier.CP2 = isP1223;
					iInferiorBezier.EP = isq1;
					
					// back of cornea
					var isq1b = new ED.Point(0,0);
					isq1b.y = (1-ibtS1)*(1-ibtS1)*(1-ibtS1)*iInferiorBezierBack.SP.y + 3*(1-ibtS1)*(1-ibtS1)*ibtS1*iInferiorBezierBack.CP1.y + 3*(1-ibtS1)*ibtS1*ibtS1*iInferiorBezierBack.CP2.y + ibtS1*ibtS1*ibtS1*iInferiorBezierBack.EP.y;
					isq1b.x = (1-ibtS1)*(1-ibtS1)*(1-ibtS1)*iInferiorBezierBack.SP.x + 3*(1-ibtS1)*(1-ibtS1)*ibtS1*iInferiorBezierBack.CP1.x + 3*(1-ibtS1)*ibtS1*ibtS1*iInferiorBezierBack.CP2.x + ibtS1*ibtS1*ibtS1*iInferiorBezierBack.EP.x;
		
					var isP12b = new ED.Point(0,0);
					isP12b.x = iInferiorBezierBack.SP.x + ibtS1 * (iInferiorBezierBack.CP1.x - iInferiorBezierBack.SP.x);
					isP12b.y = iInferiorBezierBack.SP.y + ibtS1 * (iInferiorBezierBack.CP1.y - iInferiorBezierBack.SP.y);
					
					var isP23b = new ED.Point(0,0);
					isP23b.x = iInferiorBezierBack.CP1.x + ibtS1 * (iInferiorBezierBack.CP2.x - iInferiorBezierBack.CP1.x);
					isP23b.y = iInferiorBezierBack.CP1.y + ibtS1 * (iInferiorBezierBack.CP2.y - iInferiorBezierBack.CP1.y);
					
					var isP1223b = new ED.Point(0,0);
					isP1223b.x = isP12b.x + ibtS1 * (isP23b.x - isP12b.x);
					isP1223b.y = isP12b.y + ibtS1 * (isP23b.y - isP12b.y);
		
					iInferiorBezierBack.CP1 = isP12b;
					iInferiorBezierBack.CP2 = isP1223b;
					iInferiorBezierBack.EP = isq1b;
					
				}
				
			}

			// Draw infiltrate
			ctx.beginPath();
			
			if (iInferiorBezier) {
				ctx.moveTo(iInferiorBezierBack.EP.x, iInferiorBezierBack.EP.y); // starts at bottom of back inferior bezier
				ctx.bezierCurveTo(iInferiorBezierBack.CP2.x, iInferiorBezierBack.CP2.y, iInferiorBezierBack.CP1.x, iInferiorBezierBack.CP1.y, iInferiorBezierBack.SP.x, iInferiorBezierBack.SP.y);				
			}
			
			
			if (iSuperiorBezierBack && iSuperiorBezierBack.EP.y>=iSuperiorBezierBack.SP.y) {
				ctx.moveTo(iSuperiorBezierBack.EP.x, iSuperiorBezierBack.EP.y); // start at bottom of back superior curve (closest to midpoint)
				ctx.bezierCurveTo(iSuperiorBezierBack.CP2.x, iSuperiorBezierBack.CP2.y, iSuperiorBezierBack.CP1.x, iSuperiorBezierBack.CP1.y, iSuperiorBezierBack.SP.x, iSuperiorBezierBack.SP.y);
				ctx.lineTo(iSuperiorBezier.SP.x, iSuperiorBezier.SP.y);
				ctx.bezierCurveTo(iSuperiorBezier.CP1.x, iSuperiorBezier.CP1.y, iSuperiorBezier.CP2.x, iSuperiorBezier.CP2.y, iSuperiorBezier.EP.x, iSuperiorBezier.EP.y); // end at bottom of front superior bezier (near midpoint)
			}
			else if (iSuperiorBezier) {
				ctx.lineTo(iSuperiorBezier.SP.x, iSuperiorBezier.SP.y);
				ctx.bezierCurveTo(iSuperiorBezier.CP1.x, iSuperiorBezier.CP1.y, iSuperiorBezier.CP2.x, iSuperiorBezier.CP2.y, iSuperiorBezier.EP.x, iSuperiorBezier.EP.y);
			}
			
			if (iInferiorBezier) {
				ctx.lineTo(iInferiorBezier.SP.x, iInferiorBezier.SP.y); // top of inferior bezier at the front
				ctx.bezierCurveTo(iInferiorBezier.CP1.x, iInferiorBezier.CP1.y, iInferiorBezier.CP2.x, iInferiorBezier.CP2.y, iInferiorBezier.EP.x, iInferiorBezier.EP.y); // ends at bottom of front inferior bezier
			}
			if (iInferiorBezierBack && iInferiorBezierBack.EP.y>=iInferiorBezierBack.SP.y) {
				ctx.lineTo(iInferiorBezierBack.EP.x, iInferiorBezierBack.EP.y);
			}
			else ctx.lineTo(iSuperiorBezierBack.EP.x,iSuperiorBezierBack.EP.y);
			
			ctx.fillStyle = "rgba(0,0,0,0.2)";
			ctx.fill();
			
			// fill opacity on top of
			ctx.beginPath();
			if (inferiorBezier) {
				ctx.moveTo(inferiorBezierBack.EP.x, inferiorBezierBack.EP.y);
				ctx.bezierCurveTo(inferiorBezierBack.CP2.x, inferiorBezierBack.CP2.y, inferiorBezierBack.CP1.x, inferiorBezierBack.CP1.y, inferiorBezierBack.SP.x, inferiorBezierBack.SP.y);
				ctx.lineTo(inferiorBezier.SP.x, inferiorBezier.SP.y);
				ctx.bezierCurveTo(inferiorBezier.CP1.x, inferiorBezier.CP1.y, inferiorBezier.CP2.x, inferiorBezier.CP2.y, inferiorBezier.EP.x, inferiorBezier.EP.y);
			}
			if (superiorBezier) {
				ctx.moveTo(superiorBezierBack.EP.x, superiorBezierBack.EP.y);
				ctx.bezierCurveTo(superiorBezierBack.CP2.x, superiorBezierBack.CP2.y, superiorBezierBack.CP1.x, superiorBezierBack.CP1.y, superiorBezierBack.SP.x, superiorBezierBack.SP.y);
				ctx.lineTo(superiorBezier.SP.x, superiorBezier.SP.y);
				ctx.bezierCurveTo(superiorBezier.CP1.x, superiorBezier.CP1.y, superiorBezier.CP2.x, superiorBezier.CP2.y, superiorBezier.EP.x, superiorBezier.EP.y);
			}
			ctx.fillStyle = "gray";
			ctx.fill();
		}
	}
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
	
}



/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * 
 *
 * @class CornealPigmentation
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealPigmentation = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealPigmentation";
	
	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexY', 'apexX', 'scaleX','scaleY', 'rotation', 'level', 'type'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'level':'Level', 'type':'Type'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CornealPigmentation.prototype = new ED.Doodle;
ED.CornealPigmentation.prototype.constructor = ED.CornealPigmentation;
ED.CornealPigmentation.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CornealPigmentation.prototype.setHandles = function() {
	
	// pigmentation density
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	
	// shape
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
	this.handleArray[4].isRotatable = true;
}

/**
 * Sets default properties
 */
ED.CornealPigmentation.prototype.setPropertyDefaults = function() {
	this.isSqueezable = true;
	
/*
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.2, +3);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.2, +3);
	
*/
	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-400, +400);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-400, +400);
	
	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['level'] = {
		kind: 'derived',
		type: 'string',
		list: ['Endothelium', 'Epithelial', 'Subepithelial', 'Anterior stromal', 'Mid stromal', 'Posterior stromal', 'Descemet\'s'],
		animate: true
	};
	this.parameterValidationArray['type'] = {
		kind: 'derived',
		type: 'string',
		list: ['Iron', 'Melanin', 'Blood', 'Copper', 'Lead', 'Organic', 'Unknown'],
		animate: true
	};
	
	this.handleVectorRangeArray = new Array();
	var range = new Object;
	range.length = new ED.Range(+1, +150);
	range.angle = new ED.Range(0.5*Math.PI, 0.5*Math.PI);
	this.handleVectorRangeArray[0] = range;
}

/**
 * Sets default parameters
 */
ED.CornealPigmentation.prototype.setParameterDefaults = function() {
	this.setParameterFromString('level', 'Endothelium');
  this.setParameterFromString('type', 'Melanin');
	this.apexY = -150;
	this.apexX = 30;
	
	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	var point = new ED.Point(40, 0);
	this.addPointToSquiggle(point);

}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealPigmentation.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CornealPigmentation.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Invisible boundary
	ctx.ellipse(0, 0, Math.abs(this.apexY), Math.abs(this.apexX), 0.5 * Math.PI, 0, 2 * Math.PI);
	
	// Set line attributes  
	ctx.lineWidth = 1;
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";
	ctx.fillStyle = "rgba(0,0,0,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Coordinates of expert handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[0]);
	
	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Pigment dots
		
		// Colours
		var fill = "brown";
		
		// Pigmentation density
		var pD = this.squiggleArray[0].pointsArray[0].x;
		
		// Radius
		var dr = 2;

		// Calculate shape area
		var A = Math.PI * Math.abs(this.apexX * this.apexY);
		
		// Calculate number of dots within boundary
		var n = A / 250 * (pD / 30);
		
		var p = new ED.Point(0, 0);
		
		// Calculate random positions for dots
/*
		var xS;
		var yS;
		for (var z=1; z<5; z++) {
			/// ED.randomArray is too short (length == 200)	, but using Math.random() means non reproducible, so do quarter at a time for more dots!
			var xS = (z < 3) ? -1 : 1;
			var yS = (z % 2 == 0) ? -1 : 1;
*/
			
			for (var i = 0; i < n; i++) {
				var j = (i < 150) ? i : (i < 199) ? i - 50 : (i < 249) ? i - 100 : (i < 299) ? i - 150 : (i < 349) ? i - 200 : i - 250;

				var k = (i < 200) ? i : (i < 398) ? (i - 199) : (i < 397) ? (i - 298) : (i - 396);

				var r = Math.sqrt(n * ED.randomArray[k]);
				var rX = this.apexX * ED.randomArray[k];
				var rY = this.apexY * ED.randomArray[j];
				var theta = 2 * Math.PI * ED.randomArray[j + 50];
								
/*
				p.x = Math.abs(rX * Math.cos(theta*r)) * xS;
				p.y = Math.abs(rY * Math.sin(theta*r)) * yS;
*/
				p.x = rX * Math.cos(theta*r);
				p.y = rY * Math.sin(theta*r);
				
				// Draw dot
				this.drawSpot(ctx, p.x, p.y, dr, fill);
			}
// 		}
		
		// Additionally draw spots at boundarys to ensure indicated
		this.drawSpot(ctx, 0, Math.abs(this.apexY), dr, fill);
		this.drawSpot(ctx, 0, -1 * Math.abs(this.apexY), dr, fill);
		this.drawSpot(ctx, Math.abs(this.apexX), 0, dr, fill);
		this.drawSpot(ctx, -1 * Math.abs(this.apexX), 0, dr, fill);
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CornealPigmentation.prototype.description = function() {
	
	// old ratio check method
	// var ratio = Math.abs(this.apexX / this.apexY);
	// var str = (ratio<2.5 && ratio>0.3) ? "Corneal pigmentation" : "Krukenberg spindle";
	if (this.type === 'Melanin' && this.level === 'Endothelium') {
		return 'Krukenberg spindle';
	}

	return 'Corneal pigmentation: ' + this.type + ', ' + this.level;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Corneal scar
 *
 * @class CornealScar
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealScar = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealScar";

	// Doodle specific property
	this.isInVisualAxis = false;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CornealScar.prototype = new ED.Doodle;
ED.CornealScar.prototype.constructor = ED.CornealScar;
ED.CornealScar.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CornealScar.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.CornealScar.prototype.setPropertyDefaults = function() {
	this.isSqueezable = true;
	this.isRotatable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-100, -10);
}

/**
 * Sets default parameters
 */
ED.CornealScar.prototype.setParameterDefaults = function() {
	this.apexY = -50;
	this.scaleX = 0.7;
	this.scaleY = 0.5;

	this.setOriginWithDisplacements(0, 25);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealScar.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CornealScar.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// CornealScar
	var r = 100;
	ctx.arc(0, 0, r, 0, Math.PI * 2, false);

	// Close path
	ctx.closePath();

	// Create fill
	var alpha = -this.apexY / 100;
	ctx.fillStyle = "rgba(100,100,100," + alpha.toFixed(2) + ")";

	// Transparent stroke
	ctx.strokeStyle = "rgba(100,100,100,0.9)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Work out whether visual axis is involved
		var centre = new ED.Point(0, 0);
		var visualAxis = this.drawing.transform.transformPoint(centre);
		var ctx = this.drawing.context;
		if (ctx.isPointInPath(visualAxis.x, visualAxis.y)) this.isInVisualAxis = true;
		else this.isInVisualAxis = false;
	}

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CornealScar.prototype.description = function() {
	var returnString = "";

	// Calculate size
	var averageScale = this.scaleX + this.scaleY;

	// Arbitrary cutoffs
	if (averageScale < 2) returnString = "Small ";
	else if (averageScale < 4) returnString = "Medium ";
	else returnString = "Large ";

	returnString += "corneal scar";

	if (this.isInVisualAxis) returnString += " involving visual axis";

	return returnString;
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.CornealScar.prototype.snomedCode = function() {
	return 95726001;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.CornealScar.prototype.diagnosticHierarchy = function() {
	return 2;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Corneal Striae
 *
 * @class CornealStriae
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealStriae = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealStriae";

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CornealStriae.prototype = new ED.Doodle;
ED.CornealStriae.prototype.constructor = ED.CornealStriae;
ED.CornealStriae.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.CornealStriae.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealStriae.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CornealStriae.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// CornealStriae
	var r = 300;
	ctx.arc(0, 0, r, 0, Math.PI * 2, false);

	// Close path
	ctx.closePath();

	// Create fill
	ctx.fillStyle = "rgba(100,100,100,0)";
	ctx.strokeStyle = "rgba(100,100,100,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		var st = -300;
		var d = 50;
		var w = 30;
		var s = 80;
		var x = -2 * s;

		ctx.beginPath();

		for (var i = 0; i < 5; i++) {
			ctx.moveTo(x + s * i, st);
			ctx.bezierCurveTo(x + s * i - w, st + 1 * d, x + s * i - w, st + 2 * d, x + s * i, st + 3 * d);
			ctx.bezierCurveTo(x + s * i + w, st + 4 * d, x + s * i + w, st + 5 * d, x + s * i, st + 6 * d);
			ctx.bezierCurveTo(x + s * i - w, st + 7 * d, x + s * i - w, st + 8 * d, x + s * i, st + 9 * d);
			ctx.bezierCurveTo(x + s * i + w, st + 10 * d, x + s * i + w, st + 11 * d, x + s * i, st + 12 * d);
		}

		ctx.lineWidth = 20;
		ctx.strokeStyle = "rgba(100,100,100,0.6)";
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	//     this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	// 	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CornealStriae.prototype.description = function() {
	return "Striate keratopathy";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * CornealSuture
 *
 * @class CornealSuture
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CornealSuture = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CornealSuture";
	
	// Derived parameters
	this.removed = false;
	
	// Saved parameters
	this.savedParameterArray = ['radius', 'rotation','removed'];
	
	this.controlParameterArray = {'removed':'Removed'};
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CornealSuture.prototype = new ED.Doodle;
ED.CornealSuture.prototype.constructor = ED.CornealSuture;
ED.CornealSuture.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.CornealSuture.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	
	this.parameterValidationArray['removed'] = {
		kind: 'derived',
		type: 'bool',
		animate: false
	}
}

/**
 * Sets default parameters
 */
ED.CornealSuture.prototype.setParameterDefaults = function() {
	this.radius = 374;
	this.setRotationWithDisplacements(10, 20);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CornealSuture.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CornealSuture.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	var r = this.radius;
	ctx.rect(-20, -(r + 40), 40, 80);

	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = "rgba(255,255,255,0.0)";

	// Set line attributes
	ctx.lineWidth = 6;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "rgba(120,120,120,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();
		ctx.moveTo(0, -r - 40);
		ctx.lineTo(0, -r + 40);
		ctx.moveTo(-10, -r + 10);
		ctx.lineTo(0, -r + 20);
		ctx.lineTo(-10, -r + 30);

		ctx.lineWidth = 2;
		if (this.removed) ctx.strokeStyle = "rgba(150,150,150,0.6)";
		else {
			var colour = "rgba(0,0,120,0.7)"
			ctx.strokeStyle = colour;
		}
	
		ctx.stroke();

		// Knot
		this.drawSpot(ctx, 0, -r + 20, 4, colour);
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CornealSuture.prototype.description = function() {
	var returnString = "Corneal suture at ";

	returnString += this.clockHour() + " o'clock";

	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * A cortical cataract
 *
 * @class CorticalCataract
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CorticalCataract = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CorticalCataract";

	// Derived parameters
	this.grade = 'Mild';

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CorticalCataract.prototype = new ED.Doodle;
ED.CorticalCataract.prototype.constructor = ED.CorticalCataract;
ED.CorticalCataract.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CorticalCataract.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.CorticalCataract.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isRotatable = false;
	this.isUnique = true;
	this.parentClass = "Lens";
	this.inFrontOfClassArray = ["Lens", "PostSubcapCataract", "NuclearCataract"];

	// Update validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-180, -20);
	this.parameterValidationArray['originX']['range'].setMinAndMax(-500, +500);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-500, +500);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['grade'] = {
		kind: 'derived',
		type: 'string',
		list: ['Mild', 'Moderate', 'White'],
		animate: true
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.CorticalCataract.prototype.setParameterDefaults = function() {
	this.setParameterFromString('grade', 'Mild');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.CorticalCataract.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			if (_value < -120) returnArray['grade'] = 'Mild';
			else if (_value < -60) returnArray['grade'] = 'Moderate';
			else returnArray['grade'] = 'White';
			break;

		case 'grade':
			switch (_value) {
				case 'Mild':
					returnArray['apexY'] = -180;
					break;
				case 'Moderate':
					returnArray['apexY'] = -100;
					break;
				case 'White':
					returnArray['apexY'] = -20;
					break;
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CorticalCataract.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CorticalCataract.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Parameters
	var n = 16; // Number of cortical spokes
	var ro = 240; // Outer radius of cataract
	var rs = 230; // Outer radius of spoke
	var theta = 2 * Math.PI / n; // Angle of outer arc of cortical shard
	var phi = theta / 2; // Half theta
	var ri = -this.apexY; // Radius of inner clear area

	// Draw cortical spokes
	var sp = new ED.Point(0, 0);
	sp.setWithPolars(rs, -phi);
	ctx.moveTo(sp.x, sp.y);

	for (var i = 0; i < n; i++) {
		var startAngle = i * theta - phi;
		var endAngle = startAngle + theta;

		var op = new ED.Point(0, 0);
		op.setWithPolars(rs, startAngle);
		ctx.lineTo(op.x, op.y);

		//ctx.arc(0, 0, ro, startAngle, endAngle, false);
		var ip = new ED.Point(0, 0);
		ip.setWithPolars(ri, i * theta);
		ctx.lineTo(ip.x, ip.y);
	}

	ctx.lineTo(sp.x, sp.y);

	// Surrounding ring
	ctx.moveTo(ro, 0);
	ctx.arc(0, 0, ro, 0, 2 * Math.PI, true);

	// Set boundary path attributes
	ctx.lineWidth = 4;
	ctx.lineJoin = 'bevel';
	ctx.fillStyle = "rgba(200,200,200,0.75)";
	ctx.strokeStyle = "rgba(200,200,200,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CorticalCataract.prototype.description = function() {
	return this.getParameter('grade') + " cortical cataract";
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.CorticalCataract.prototype.snomedCode = function() {
	return 193576003;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.CorticalCataract.prototype.diagnosticHierarchy = function() {
	return 3;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Cortical Cataract Cross Section ***TODO***
 *
 * @class CorticalCataractCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CorticalCataractCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CorticalCataractCrossSection";

	// Derived parameters
	this.grade = 'Mild';

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CorticalCataractCrossSection.prototype = new ED.Doodle;
ED.CorticalCataractCrossSection.prototype.constructor = ED.CorticalCataractCrossSection;
ED.CorticalCataractCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CorticalCataractCrossSection.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.CorticalCataractCrossSection.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isRotatable = false;
	this.isUnique = true;
	this.parentClass = "LensCrossSection";
	this.inFrontOfClassArray = ["LensCrossSection", "NuclearCataractCrossSection"];

	// Update validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-180, -20);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['grade'] = {
		kind: 'derived',
		type: 'string',
		list: ['Mild', 'Moderate', 'White'],
		animate: true
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.CorticalCataractCrossSection.prototype.setParameterDefaults = function() {
	this.originX = 44;
	this.setParameterFromString('grade', 'Mild');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.CorticalCataractCrossSection.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			if (_value < -120) returnArray['grade'] = 'Mild';
			else if (_value < -60) returnArray['grade'] = 'Moderate';
			else returnArray['grade'] = 'White';
			break;

		case 'grade':
			switch (_value) {
				case 'Mild':
					returnArray['apexY'] = -180;
					break;
				case 'Moderate':
					returnArray['apexY'] = -100;
					break;
				case 'White':
					returnArray['apexY'] = -20;
					break;
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CorticalCataractCrossSection.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CorticalCataractCrossSection.superclass.draw.call(this, _point);

	// Height of cross section (half value of ro in AntSeg doodle)
	var h = 240;

	// Radius of curvature of lens
	var r = 300;

	// Displacement lens from centre
	var ld = 100;

	// Thickness of lens
	//var lt = 100;

	// Angle of arc
	var theta = Math.asin(h / r);

	// X coordinate of centre of circle
	var x = r * Math.cos(theta);

	// Radius of cortical cataract (half way between capsule and nucleus)
	var rco = r - 30;

	// Calculate nucleus angles
	theta = Math.acos(x / rco);

	// Calculate cataract angles
	var phi = Math.asin(-this.apexY / rco);

	// Boundary path
	ctx.beginPath();

	// Draw cataract with two sections of circumference of circle
	ctx.arc(ld - x, 0, rco, phi, theta, false);
	ctx.arc(ld + x, 0, rco, Math.PI - theta, Math.PI - phi, false);

	// Move to upper half and draw it
	var l = rco * Math.cos(phi);
	ctx.moveTo(ld - x + l, this.apexY);
	ctx.arc(ld - x, 0, rco, -phi, -theta, true);
	ctx.arc(ld + x, 0, rco, Math.PI + theta, Math.PI + phi, true);

	// Set line attributes
	ctx.lineWidth = 30;
	ctx.lineCap = 'round';
	ctx.lineJoin = 'round';
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(200,200,200,0.75)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(ld, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Cotton Wool Spot
 *
 * @class CottonWoolSpot
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CottonWoolSpot = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CottonWoolSpot";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CottonWoolSpot.prototype = new ED.Doodle;
ED.CottonWoolSpot.prototype.constructor = ED.CottonWoolSpot;
ED.CottonWoolSpot.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CottonWoolSpot.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Set default properties
 */
ED.CottonWoolSpot.prototype.setPropertyDefaults = function() {
	this.isSqueezable = true;
	this.isOrientated = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.5);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.CottonWoolSpot.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(-150, 150);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CottonWoolSpot.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CottonWoolSpot.superclass.draw.call(this, _point);

	// Dimensions of haemorrhage
	var r = 80;
	var h = 50;
	var d = h / 3;

	// Boundary path
	ctx.beginPath();

	// Cotton wool spot
	ctx.moveTo(-r, -h);
	ctx.lineTo(-r + d, -h + 1 * d);
	ctx.lineTo(-r, -h + 2 * d);
	ctx.lineTo(-r + d, -h + 3 * d);
	ctx.lineTo(-r, -h + 4 * d);
	ctx.lineTo(-r + d, -h + 5 * d);
	ctx.lineTo(-r, -h + 6 * d);
	ctx.bezierCurveTo(-r + d, -h + 7 * d, r - d, -h + 7 * d, r, -h + 6 * d);
	ctx.lineTo(r - d, -h + 5 * d);
	ctx.lineTo(r, -h + 4 * d);
	ctx.lineTo(r - d, -h + 3 * d);
	ctx.lineTo(r, -h + 2 * d);
	ctx.lineTo(r - d, -h + 1 * d);
	ctx.lineTo(r, -h);
	ctx.bezierCurveTo(r - d, -h - d, -r + d, -h - d, -r, -h);

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "gray";
	ctx.fillStyle = "rgba(220,220,220,0.5)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(r, -h));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.CottonWoolSpot.prototype.groupDescription = function() {
	return "Cotton wool spots";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Cryotherapy
 *
 * @class Cryo
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Cryo = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Cryo";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Cryo.prototype = new ED.Doodle;
ED.Cryo.prototype.constructor = ED.Cryo;
ED.Cryo.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Cryo.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.Cryo.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-80, -40);
}

/**
 * Sets default parameters
 */
ED.Cryo.prototype.setParameterDefaults = function() {
	this.apexY = -40;

	// Put control handle at 45 degrees
	this.rotation = Math.PI / 4;

	// Displacement from fovea, and from last doodle
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		var p = new ED.Point(doodle.originX, doodle.originY);

		var np = new ED.Point(0, 0);
		np.setWithPolars(p.length(), p.direction() + Math.PI / 6);

		this.move(np.x, np.y);
	} else {
		this.move((this.drawing.eye == ED.eye.Right ? -1 : 1) * 200, -300);
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Cryo.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Cryo.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Circular scar
	var r = Math.sqrt(this.apexX * this.apexX + this.apexY * this.apexY);

	// Circular scar
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set line attributes
	ctx.lineWidth = 8;
	var ptrn = ctx.createPattern(this.drawing.imageArray['CryoPattern'], 'repeat');
	ctx.fillStyle = ptrn;
	ctx.strokeStyle = "rgba(80, 40, 0, 1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Cryo.prototype.groupDescription = function() {
	return "Cryotherapy";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Cutter Peripheral iridectomy
 *
 * @class CutterPI
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CutterPI = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CutterPI";

	// Saved parameters
	this.savedParameterArray = ['rotation'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CutterPI.prototype = new ED.Doodle;
ED.CutterPI.prototype.constructor = ED.CutterPI;
ED.CutterPI.superclass = ED.Doodle.prototype;

/**
 * Sets default properties
 */
ED.CutterPI.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
}

/**
 * Sets default parameters
 */
ED.CutterPI.prototype.setParameterDefaults = function() {
	this.setRotationWithDisplacements(160, 40);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CutterPI.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CutterPI.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Draw base
	ctx.arc(0, -324, 40, 0, 2 * Math.PI, true);

	// Colour of fill
	ctx.fillStyle = "rgba(255,255,255,1)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "rgba(120,120,120,0.75)";;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CutterPI.prototype.groupDescription = function() {
	return "Cutter iridectomy/s";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Cypass (single)
 *
 * @class Cypass
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Cypass = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Cypass";

	// Private parameters
	this.limbus = -400;

    // Derived parameters
    this.miotic = 'Miochol';
    this.viscoelastic = 'Viscoelastic';
    this.complication = 'Haemorrhage +';

	// Saved parameters
	this.savedParameterArray = ['rotation', 'radius', 'miotic', 'viscoelastic', 'complication'];

    this.controlParameterArray = {
        'miotic':'Miotic',
        'viscoelastic':'Viscoelastic',
        'complication':'Complication',
    };

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Cypass.prototype = new ED.Doodle;
ED.Cypass.prototype.constructor = ED.Cypass;
ED.Cypass.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.Cypass.prototype.setPropertyDefaults = function() {
    this.isScaleable = false;
    this.isMoveable = false;
    this.isUnique = true;

    this.parameterValidationArray['miotic'] = {
        kind: 'derived',
        type: 'string',
        list: ['Miochol', 'Carbachol', 'Pilocarpine 2%'],
        animate: true
    };

    this.parameterValidationArray['viscoelastic'] = {
        kind: 'derived',
        type: 'string',
        list: ['Viscoelastic'],
        animate: true
    };

    this.parameterValidationArray['complication'] = {
        kind: 'derived',
        type: 'string',
        list: ['Haemorrhage +', 'Haemorrhage ++', 'Haemorrhage +++'],
        animate: true
    };
}

/**
 * Sets default parameters
 */
ED.Cypass.prototype.setParameterDefaults = function() {

    this.radius = 462;
    this.setRotationWithDisplacements(315, 270);

    this.parameterValidationArray['radius']['range'].setMinAndMax(415, 480);

    this.setParameterFromString('miotic', 'Miochol');
    this.setParameterFromString('viscoelastic', 'Viscoelastic');
    this.setParameterFromString('complication', 'Haemorrhage +');
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Cypass.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;
    var r = this.radius;

	// Call draw method in superclass
	ED.Cypass.superclass.draw.call(this, _point);

	// Set line attributes
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";
	ctx.fillStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		var ring = {w: 14, h: 36},
            ringDistance = 19;

		//Corneal incision
        ctx.beginPath();
        ctx.moveTo(360,-60);
        ctx.lineTo(360,60);
        ctx.strokeStyle = "rgba(0, 0, 0, 1)";
        ctx.stroke();
        ctx.closePath();

		// Body
		ctx.beginPath();

		//the body
        ctx.rect(-200-(r), -10, 300, 20);

        //rings
        for (var i = 1; i < 4; i++) {
            ctx.rect( (99-(r)-5) - (i*ringDistance), -18, ring.w, ring.h);
        }

        //collar
        ctx.rect(99-(r), -(18), ring.w + 6, ring.h);

		ctx.fillStyle = "rgba(112, 96, 0, 1)";
		ctx.fill();
        ctx.closePath();

        //fenestrations
        ctx.beginPath();
        for (var i = 1; i < 6; i++) {
            ctx.arc((-200-(r)+5)+(i*40), 0, 5, 0, 2 * Math.PI, false);
        }
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
        ctx.fill();
        ctx.closePath();

        //we redraw an invisible device body to be draggable
        ctx.beginPath();
        ctx.rect(-200-(r), -15, 300, 30);
        ctx.fillStyle = "rgba(0, 0, 0, 0)";
        ctx.fill();
	}

	// Return value indicating successful hittest
	return this.isClicked;
};

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Cypass.prototype.description = function() {
	var desc = '';

    desc += "Miotic: " + this.miotic + "\n";
    desc += "Viscoelastic: " + this.viscoelastic + "\n";
    desc += "Complication: " + this.complication + "\n";
    desc += "Cypass stent at " + this.clockHour(-3) + " o'clock";

    return desc;
};

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Cystoid Macular Oedema
 *
 * @class CystoidMacularOedema
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.CystoidMacularOedema = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "CystoidMacularOedema";

	// Saved parameters
	this.savedParameterArray = ['scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.CystoidMacularOedema.prototype = new ED.Doodle;
ED.CystoidMacularOedema.prototype.constructor = ED.CystoidMacularOedema;
ED.CystoidMacularOedema.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.CystoidMacularOedema.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default dragging attributes
 */
ED.CystoidMacularOedema.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;

	// Update validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.5);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.CystoidMacularOedema.prototype.setParameterDefaults = function() {

	// Set size according to template
	if (this.drawing.hasDoodleOfClass('Fundus')) {
		this.scaleX = 0.5;
		this.scaleY = this.scaleX;
		this.originX = this.drawing.eye == ED.eye.Right ? -100 : 100;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.CystoidMacularOedema.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.CystoidMacularOedema.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Invisible boundary
	ctx.arc(0, 0, 120, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Colours
		var fill = "rgba(255, 255, 138, 0.5)";
		var stroke = "rgba(255, 82, 0, 0.7)";

		// Peripheral cysts
		var point = new ED.Point(0, 0);
		var n = 8;
		for (var i = 0; i < n; i++) {
			var angle = i * 2 * Math.PI / n;
			point.setWithPolars(80, angle);
			this.drawCircle(ctx, point.x, point.y, 40, fill, 2, stroke);
		}

		// Large central cyst
		this.drawCircle(ctx, 0, 0, 60, fill, 2, stroke);
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(84, -84));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.CystoidMacularOedema.prototype.description = function() {
	return "Cystoid macular oedema";
}


/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.CystoidMacularOedema.prototype.snomedCode = function() {
	return 193387007;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.CystoidMacularOedema.prototype.diagnosticHierarchy = function() {
	return 2;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * The optic disc
 *
 * @class DendriticUlcer
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.DendriticUlcer = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "DendriticUlcer";

	// Private parameters
	this.numberOfHandles = 8;
	this.initialRadius = 120;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexX', 'apexY', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.DendriticUlcer.prototype = new ED.Doodle;
ED.DendriticUlcer.prototype.constructor = ED.DendriticUlcer;
ED.DendriticUlcer.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.DendriticUlcer.prototype.setHandles = function() {
	// Array of handles
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	}

	// Allow top handle to rotate doodle
	this.handleArray[0].isRotatable = true;
}

/**
 * Sets default properties
 */
ED.DendriticUlcer.prototype.setPropertyDefaults = function() {
	// Create ranges to constrain handles
	this.handleVectorRangeArray = new Array();
	for (var i = 0; i < this.numberOfHandles; i++) {
		// Full circle in radians
		var cir = 2 * Math.PI;

		// Create a range object for each handle
		var n = this.numberOfHandles;
		var range = new Object;
		range.length = new ED.Range(+50, +290);
		range.angle = new ED.Range((((2 * n - 1) * cir / (2 * n)) + i * cir / n) % cir, ((1 * cir / (2 * n)) + i * cir / n) % cir);
		this.handleVectorRangeArray[i] = range;
	}

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-50, +50);

	this.addAtBack = true;
}

/**
 * Sets default parameters
 */
ED.DendriticUlcer.prototype.setParameterDefaults = function() {
	this.apexY = 50;
	this.setOriginWithDisplacements(200, 150);

	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate with handles at  points around circumference
	var outer = true;
	for (var i = 0; i < this.numberOfHandles; i++) {
		var point = new ED.Point(0, 0);
		if (outer) {
			point.setWithPolars(this.initialRadius, i * 2 * Math.PI / this.numberOfHandles);
			outer = false;
		}
		else {
			point.setWithPolars(this.initialRadius/2, i * 2 * Math.PI / this.numberOfHandles);
			outer = true;
		}
		this.addPointToSquiggle(point);
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.DendriticUlcer.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.DendriticUlcer.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Bezier points
	var fp;
	var tp;
	var cp1;
	var cp2;

	// Angle of control point from radius line to point (this value makes path a circle Math.PI/12 for 8 points
	var phi = 2 * Math.PI / (3 * this.numberOfHandles);

	// Start curve
	ctx.moveTo(this.squiggleArray[0].pointsArray[0].x, this.squiggleArray[0].pointsArray[0].y);

	// Complete curve segments
	for (var i = 0; i < this.numberOfHandles; i++) {
		// From and to points
		fp = this.squiggleArray[0].pointsArray[i];
		var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
		tp = this.squiggleArray[0].pointsArray[toIndex];

		// Control points
		cp1 = fp.tangentialControlPoint(+phi);
		cp2 = tp.tangentialControlPoint(-phi);

		// Draw Bezier curve
		ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);
	}

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(0, 255, 0, 0.5)";
	ctx.strokeStyle = "rgba(0, 100, 0, 1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
// 		Drusen
// 		p = new ED.Point(0,0);
// 		fill = "yellow";
// 		var dr = 4;
// 		n = Math.abs(Math.floor((-this.apexY + 50) / 5));
// 		for (var i = 0; i < n; i++) {
// 			p.setWithPolars(this.initialRadius * 0.8 * ED.randomArray[i + 10], 2 * Math.PI * ED.randomArray[i + 100]);
// 			this.drawSpot(ctx, p.x, p.y, dr * 2, fill);
// 		}
	}

	// Coordinates of handles (in canvas plane)
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[i]);
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.DendriticUlcer.prototype.description = function() {
	return 'Dendritic ulcer';
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
// ED.DendriticUlcer.prototype.snomedCode = function() {
// 	return 11111111;
// }

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * DiabeticNV template with disc and arcades
 *
 * @class DiabeticNV
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.DiabeticNV = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "DiabeticNV";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.DiabeticNV.prototype = new ED.Doodle;
ED.DiabeticNV.prototype.constructor = ED.DiabeticNV;
ED.DiabeticNV.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.DiabeticNV.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Set default properties
 */
ED.DiabeticNV.prototype.setPropertyDefaults = function() {}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.DiabeticNV.prototype.setParameterDefaults = function() {
	var n = this.drawing.numberOfDoodlesOfClass(this.className);

	switch (n) {
		case 0:
			this.originX = (this.drawing.eye == ED.eye.Right) ? 300 : -300;
			this.originY = -100;
			break;
		case 1:
			this.originX = (this.drawing.eye == ED.eye.Right) ? -176 : 176;
			this.originY = -236;
			break;
		case 2:
			this.originX = (this.drawing.eye == ED.eye.Right) ? -176 : 176;
			this.originY = 236;
			break;
		default:
			this.setOriginWithDisplacements(0, -100);
			break;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.DiabeticNV.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.DiabeticNV.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Radius of NV
	var r = 60;
	var c = r / 2;
	var phi = 0;
	var theta = Math.PI / 8;
	var n = 8;

	// Do a vessel
	var cp1 = new ED.Point(0, 0);
	var cp2 = new ED.Point(0, 0);
	var tip = new ED.Point(0, 0);
	var cp3 = new ED.Point(0, 0);
	var cp4 = new ED.Point(0, 0);

	// Move to centre
	ctx.moveTo(0, 0);

	// Loop through making petals
	var i;
	for (i = 0; i < n; i++) {
		phi = i * 2 * Math.PI / n;

		cp1.setWithPolars(c, phi - theta);
		cp2.setWithPolars(r, phi - theta);
		tip.setWithPolars(r, phi);
		cp3.setWithPolars(r, phi + theta);
		cp4.setWithPolars(c, phi + theta);

		// Draw petal
		ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tip.x, tip.y);
		ctx.bezierCurveTo(cp3.x, cp3.y, cp4.x, cp4.y, 0, 0);
	}

	// Transparent fill
	ctx.fillStyle = "rgba(100, 100, 100, 0)";

	// Set attributes
	ctx.lineWidth = 3;
	ctx.strokeStyle = "red";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.DiabeticNV.prototype.groupDescription = function() {
	return "Diabetic new vessels ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.DiabeticNV.prototype.description = function() {
	return this.locationRelativeToDisc();
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.DiabeticNV.prototype.snomedCode = function() {
	return 59276001;
}

/**
 * Dialysis
 *
 * @class Dialysis
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Dialysis = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Dialysis";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Dialysis.prototype = new ED.Doodle;
ED.Dialysis.prototype.constructor = ED.Dialysis;
ED.Dialysis.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Dialysis.prototype.setHandles = function() {
	this.handleArray[1] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.Dialysis.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-450, -250);
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 6, Math.PI);
}

/**
 * Sets default parameters
 */
ED.Dialysis.prototype.setParameterDefaults = function() {
	this.apexY = -350;
	this.arc = 60 * Math.PI / 180;

	// Default to inferoremporal quadrant
	this.setRotationWithDisplacements(140, 60);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Dialysis.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RRD.superclass.draw.call(this, _point);

	// Fit outer curve just inside ora on right and left fundus diagrams
	var r = 952 / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of corners of arc
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across from top right to to mirror image point on the other side
	ctx.arc(0, 0, r, arcStart, arcEnd, true);

	// Connect across the bottom via the apex point
	var bp = +0.6;

	// Curve back to start via apex point
	ctx.bezierCurveTo(topLeftX, topLeftY, bp * topLeftX, this.apexY, this.apexX, this.apexY);
	ctx.bezierCurveTo(-bp * topLeftX, this.apexY, topRightX, topRightY, topRightX, topRightY);

	// Set line attributes
	ctx.lineWidth = 8;
	ctx.fillStyle = "red";
	ctx.strokeStyle = "blue";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[1].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}


/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Dialysis.prototype.description = function() {
	var returnString = "";

	// Size description
	if (this.arc < Math.PI / 4) returnString = "Small ";
	else returnString = "Large ";

	// U tear
	returnString += "dialysis ";

	// Location (clockhours)
	returnString += this.clockHour() + " o'clock";

	return returnString;
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.Dialysis.prototype.snomedCode = function() {
	return 232003005;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.Dialysis.prototype.diagnosticHierarchy = function() {
	return 4;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Disc Haemorrhage
 *
 * @class DiscHaemorrhage
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.DiscHaemorrhage = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "DiscHaemorrhage";

	// Saved parameters
	this.savedParameterArray = ['rotation'];
	
	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.DiscHaemorrhage.prototype = new ED.Doodle;
ED.DiscHaemorrhage.prototype.constructor = ED.DiscHaemorrhage;
ED.DiscHaemorrhage.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.DiscHaemorrhage.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
}

/**
 * Sets default parameters
 */
ED.DiscHaemorrhage.prototype.setParameterDefaults = function() {
	this.setRotationWithDisplacements(150, -120);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.DiscHaemorrhage.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.DiscHaemorrhage.superclass.draw.call(this, _point);

	// Radius of outer curve just inside ora on right and left fundus diagrams
	var ro = 350;
	var ri = 250;
	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = 5 * Math.PI / 180;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of DiscHaemorrhage
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "red";
	ctx.strokeStyle = "red";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.DiscHaemorrhage.prototype.groupDescription = function() {
	return "Disc haemorrhage at ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.DiscHaemorrhage.prototype.description = function() {
	return this.clockHour() + " o'clock";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Disc Haemorrhage
 *
 * @class DiscPallor
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.DiscPallor = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "DiscPallor";

	// Derived parameters
	this.grade = 'Sectorial';

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.DiscPallor.prototype = new ED.Doodle;
ED.DiscPallor.prototype.constructor = ED.DiscPallor;
ED.DiscPallor.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.DiscPallor.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Sets default dragging attributes
 */
ED.DiscPallor.prototype.setPropertyDefaults = function() {
	this.isArcSymmetrical = true;
	this.isMoveable = false;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['grade'] = {
		kind: 'derived',
		type: 'string',
		list: ['Sectorial', 'Diffuse'],
		animate: true
	};

	// Speed up animation for arc
	this.parameterValidationArray['arc']['delta'] = 0.2;
}

/**
 * Sets default parameters
 */
ED.DiscPallor.prototype.setParameterDefaults = function() {
	this.arc = 60 * Math.PI / 180;
	this.setRotationWithDisplacements(45, -120);
	this.setParameterFromString('grade', 'Sectorial');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.DiscPallor.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'arc':
			if (_value < 2 * Math.PI) returnArray['grade'] = 'Sectorial';
			else returnArray['grade'] = 'Diffuse';
			break;

		case 'grade':
			switch (_value) {
				case 'Sectorial':
					if (this.arc < 2 * Math.PI) returnArray['arc'] = this.arc;
					else returnArray['arc'] = Math.PI / 2;
					break;
				case 'Diffuse':
					returnArray['arc'] = 2 * Math.PI;
					break;
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.DiscPallor.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.DiscPallor.superclass.draw.call(this, _point);

	// Radius of disc
	var ro = 300;

	// Get inner radius from OpticDisk doodle
	var opticDisc = this.drawing.firstDoodleOfClass('OpticDisc');
	if (opticDisc) {
		var ri = opticDisc.minimumRadius();
	} else {
		var ri = 150;
	}
	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of DiscPallor
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 1;
	ctx.fillStyle = "rgba(255,255,255,0.5)";
	ctx.strokeStyle = "rgba(255,255,255,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.DiscPallor.prototype.groupDescription = function() {
	if (this.grade == 'Diffuse') {
		return "Diffuse disc pallor";
	} else {
		return "Disc pallor at ";
	}
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.DiscPallor.prototype.description = function() {
	if (this.grade == 'Diffuse') {
		return "";
	} else {
		return this.clockHour() + " o'clock";
	}
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Drainage retinotomy
 *
 * @class DrainageRetinotomy
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.DrainageRetinotomy = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "DrainageRetinotomy";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.DrainageRetinotomy.prototype = new ED.Doodle;
ED.DrainageRetinotomy.prototype.constructor = ED.DrainageRetinotomy;
ED.DrainageRetinotomy.superclass = ED.Doodle.prototype;

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.DrainageRetinotomy.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(140, 100);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.DrainageRetinotomy.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.DrainageRetinotomy.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Circle
	ctx.arc(0, 0, 30, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 16;
	ctx.fillStyle = "rgba(255,0,0,0.5)";
	ctx.strokeStyle = "red";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.DrainageRetinotomy.prototype.description = function() {
	return "Drainage retinotomy in " + this.quadrant();
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Drainage site
 *
 * @class DrainageSite
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.DrainageSite = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "DrainageSite";

	// Saved parameters
	this.savedParameterArray = ['rotation'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.DrainageSite.prototype = new ED.Doodle;
ED.DrainageSite.prototype.constructor = ED.DrainageSite;
ED.DrainageSite.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.DrainageSite.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
}

/**
 * Sets default parameters
 */
ED.DrainageSite.prototype.setParameterDefaults = function() {
	// Make rotation 30 degrees to last one of same class
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		this.rotation = doodle.rotation + Math.PI / 6;
	} else {
		this.rotation = -60 * Math.PI / 180
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.DrainageSite.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.DrainageSite.superclass.draw.call(this, _point);

	// Radii
	var ro = 440;
	var ri = 360;

	// Calculate parameters for arcs
	var theta = Math.PI / 30;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Boundary path
	ctx.beginPath();

	// Arc across
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Line to point
	ctx.lineTo(0, -ri);;

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "#777";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.DrainageSite.prototype.groupDescription = function() {
	return "Drainage site at ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.DrainageSite.prototype.description = function() {
	// Location (clockhours)
	return this.clockHour() + " o'clock";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Hard Drusen
 *
 * @class Drusen
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Drusen = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Drusen";

    this.drusenType = 'Hard';
    this.blur = 0;

	// Saved parameters
	this.savedParameterArray = ['apexY', 'scaleX', 'scaleY', 'drusenType', 'blur'];

    this.controlParameterArray = {
        'drusenType':'Drusen type'
    }

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Drusen.prototype = new ED.Doodle;
ED.Drusen.prototype.constructor = ED.Drusen;
ED.Drusen.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Drusen.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.Drusen.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-160, +0);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.5);

    this.parameterValidationArray.drusenType = {
        kind: 'derived',
        type: 'string',
        list: ['Hard', 'Soft', 'Confluent'],
    };
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Drusen.prototype.setParameterDefaults = function() {
	// Hard drusen is displaced for Fundus, central for others
	if (this.drawing.hasDoodleOfClass('Fundus')) {
		this.originX = this.drawing.eye == ED.eye.Right ? -100 : 100;
		this.scaleX = 0.5;
		this.scaleY = 0.5;
	}

    this.setParameterFromString('drusenType', 'Hard');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.Drusen.prototype.dependentParameterValues = function(_parameter, _value) {
    var returnArray = new Array();

    switch (_parameter) {
        case 'drusenType':
            switch (_value) {
                case 'Hard':
                    returnArray.blur = 0;
                    break;
                case 'Soft':
                    returnArray.blur = 1;
                    break;
                case 'Confluent':
                    returnArray.blur = 2;
                    break;
            }
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Drusen.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Drusen.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Invisible boundary
	var r = 200;
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Colours
		var fill = "lightgray",
			dr, gradient,
        	base_radius = this.drusenType === 'Soft' ? 25 : ( this.drusenType === 'Confluent' ? 31 : 10);

        var p = new ED.Point(0, 0);
        var n = 20 + Math.abs(Math.floor(this.apexY / 2));

        dr = base_radius / this.scaleX;

		for (var i = 0; i < n; i++) {
			p.setWithPolars(r * ED.randomArray[i], 2 * Math.PI * ED.randomArray[i + 100]);
            ctx.save();
            ctx.beginPath();
            ctx.arc(p.x, p.y, dr, 0, Math.PI * 2, true);

            gradient = ctx.createRadialGradient(p.x, p.y, (10 / this.scaleX), p.x, p.y, dr);
            gradient.addColorStop(0, fill);
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = this.drusenType === 'Hard' ? fill : gradient;
            ctx.lineWidth = 0;
            ctx.fill();
            ctx.stroke();
            ctx.closePath();
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(r * 0.7, -r * 0.7));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Drusen.prototype.description = function() {
	var returnString = "Signficant numbers of ";
	if (this.apexY > -100) returnString = "Moderate numbers of ";
	if (this.apexY > -50) returnString = "Several ";

	return returnString + this.drusenType.toLowerCase() + " drusen";
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * EncirclingBand buckle
 *
 * @class EncirclingBand
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.EncirclingBand = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "EncirclingBand";

	// Saved parameters
	this.savedParameterArray = ['rotation'];
	
	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.EncirclingBand.prototype = new ED.Doodle;
ED.EncirclingBand.prototype.constructor = ED.EncirclingBand;
ED.EncirclingBand.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.EncirclingBand.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.addAtBack = true;
	this.isUnique = true;
}

/**
 * Sets default parameters
 */
ED.EncirclingBand.prototype.setParameterDefaults = function() {
	this.rotation = -45 * Math.PI / 180;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.EncirclingBand.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.EncirclingBand.superclass.draw.call(this, _point);

	// Radii
	var r = 270;
	// If Buckle there, take account of  size
	var doodle = this.drawing.lastDoodleOfClass("CircumferentialBuckle");
	if (doodle) {
		var da = doodle.apexY;
		if (-350 > da && da > -380) r = 286;
		else if (da < -380) r = 315;
	}

	var ro = r + 15;
	var ri = r - 15;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, 0, 2 * Math.PI, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, 2 * Math.PI, 0, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(200,200,200,0.75)";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Watzke
		ctx.beginPath();

		var theta = Math.PI / 16;

		// Arc across to mirror image point on the other side
		ctx.arc(0, 0, ro + 10, theta, -theta, true);

		// Arc back to mirror image point on the other side
		ctx.arc(0, 0, ri - 10, -theta, theta, false);

		// Close path
		ctx.closePath();
		ctx.lineWidth = 6;
		ctx.stroke();
	}

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.EncirclingBand.prototype.description = function() {
	var returnString = "Encircling band, with Watzke in ";

	// Get side
	if (this.drawing.eye == ED.eye.Right) {
		var isRightSide = true;
	} else {
		var isRightSide = false;
	}

	// Use trigonometry on rotation field to determine quadrant
	var angle = this.rotation + Math.PI / 2;
	returnString = returnString + (Math.cos(angle) > 0 ? "supero" : "infero");
	returnString = returnString + (Math.sin(angle) > 0 ? (isRightSide ? "nasal" : "temporal") : (isRightSide ? "temporal" : "nasal"));
	returnString = returnString + " quadrant";

	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Entry Site Break
 *
 * @class EntrySiteBreak
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.EntrySiteBreak = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "EntrySiteBreak";

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation']

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.EntrySiteBreak.prototype = new ED.Doodle;
ED.EntrySiteBreak.prototype.constructor = ED.EntrySiteBreak;
ED.EntrySiteBreak.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.EntrySiteBreak.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Sets default properties
 */
ED.EntrySiteBreak.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isArcSymmetrical = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 16, 3 * Math.PI / 16);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.EntrySiteBreak.prototype.setParameterDefaults = function() {
	this.arc = Math.PI / 8;
	this.setRotationWithDisplacements(60, -120);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.EntrySiteBreak.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.EntrySiteBreak.superclass.draw.call(this, _point);

	// Radius of outer curve just inside ora on right and left fundus diagrams
	var ro = 460;
	var ri = 400;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of EntrySiteBreak
	var topRightX = ro * Math.sin(theta);
	var topRightY = -ro * Math.cos(theta);
	var topLeftX = -ro * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Curve gracefull to start again
	ctx.bezierCurveTo(0, -ri, 0, -ri, topRightX, topRightY);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "red";
	ctx.strokeStyle = "blue";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Epiretinal Membrane
 *
 * @class EpiretinalMembrane
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.EpiretinalMembrane = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "EpiretinalMembrane";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.EpiretinalMembrane.prototype = new ED.Doodle;
ED.EpiretinalMembrane.prototype.constructor = ED.EpiretinalMembrane;
ED.EpiretinalMembrane.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.EpiretinalMembrane.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, true);
}

/**
 * Sets default properties
 */
ED.EpiretinalMembrane.prototype.setPropertyDefaults = function() {
	this.isSqueezable = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.5);
// 	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
// 	this.parameterValidationArray['apexY']['range'].setMinAndMax(-40, +30);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.EpiretinalMembrane.prototype.setParameterDefaults = function() {

	// Set size according to template
	if (this.drawing.hasDoodleOfClass('Fundus')) {
		this.scaleX = 0.5;
		this.scaleY = this.scaleX;
		this.originX = this.drawing.eye == ED.eye.Right ? -100 : 100;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.EpiretinalMembrane.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.EpiretinalMembrane.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Invisible boundary
	var r = 120;
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Greenish semi-transparent
		ctx.strokeStyle = "rgba(0, 255, 0, 0.7)";

		// Central line
		ctx.beginPath();
		ctx.moveTo(-r, 0);
		ctx.lineTo(r, 0);

		// Curved lines above and below
		var x = r * 0.9;
		var y = -r / 2;
		var f = 0.3;
		ctx.moveTo(-x, y);
		ctx.bezierCurveTo(-x * f, y * f, x * f, y * f, x, y);
		y = r / 2;
		ctx.moveTo(-x, y);
		ctx.bezierCurveTo(-x * f, y * f, x * f, y * f, x, y);
		x = r * 0.6;
		y = -r * 0.8;
		f = 0.5;
		ctx.moveTo(-x, y);
		ctx.bezierCurveTo(-x * f, y * f, x * f, y * f, x, y);
		y = r * 0.8;
		ctx.moveTo(-x, y);
		ctx.bezierCurveTo(-x * f, y * f, x * f, y * f, x, y);

		// Round ended line
		ctx.lineWidth = 18;
		ctx.lineCap = "round";

		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(r * 0.7, -r * 0.7));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.EpiretinalMembrane.prototype.description = function() {
	var returnString = "Epiretinal membrane";

	return returnString;
}


/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.EpiretinalMembrane.prototype.snomedCode = function() {
	return 367649002;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.EpiretinalMembrane.prototype.diagnosticHierarchy = function() {
	return 2;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Episcleritis
 *
 * @class Episcleritis
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Episcleritis = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Episcleritis";

	// Other parameters
	this.severity = 'Medium';

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation', 'severity'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'severity':'Severity'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Episcleritis.prototype = new ED.Doodle;
ED.Episcleritis.prototype.constructor = ED.Episcleritis;
ED.Episcleritis.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Episcleritis.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Sets default dragging attributes
 */
ED.Episcleritis.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = true;
	this.isArcSymmetrical = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(20 * Math.PI / 180, 2 * Math.PI);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-334, -300);
	this.parameterValidationArray['radius']['range'].setMinAndMax(250, 450);

	// Add complete validation arrays for other parameters
	this.parameterValidationArray['severity'] = {
		kind: 'other',
		type: 'string',
		list: ['Severe', 'Medium', 'Mild'],
		animate: false
	};
}

/**
 * Sets default parameters
 */
ED.Episcleritis.prototype.setParameterDefaults = function() {
	// Default arc
	this.arc = 20 * Math.PI / 180;

	// Make a subsequent one 90 degress to last one of same class
	this.setRotationWithDisplacements(90, -90);

	// Match subsequent properties
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		this.arc = doodle.arc
		this.severity = doodle.severity
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Episcleritis.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Episcleritis.superclass.draw.call(this, _point);

	// Radii
	var ro = 495;
	var ri = 420;
	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of doodle
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across
	ctx.arc(0, 0, ro, -Math.PI / 2 + theta, -Math.PI / 2 - theta, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, -Math.PI / 2 - theta, -Math.PI / 2 + theta, false);

	// Close path
	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = "rgba(218,230,241,0)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line
	ctx.strokeStyle = "rgba(218,230,241,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Total number of vessels in a 360 arc
		var t = 120;

		// Number in the current arc and angular separation
		var phi = 2 * Math.PI / t;
		var n = Math.floor(this.arc / phi);

		// Start and end points of vessel
		var sp = new ED.Point(0, 0);
		var ep = new ED.Point(0, 0);

		ctx.beginPath();

		// Radial lines
		var rc = ro;

		for (var i = 0; i < n; i++) {
			var theta = Math.PI / 2 + arcEnd + i * phi;
			sp.setWithPolars(ro, theta);
			ep.setWithPolars(ri, theta);

			ctx.moveTo(sp.x, sp.y);
			ctx.lineTo(ep.x, ep.y);
		}

		ctx.strokeStyle = "red";

		// Adjust thickness of line for severity
		switch (this.severity) {
			case 'Severe':
				ctx.lineWidth = 16;
				break;
			case 'Medium':
				ctx.lineWidth = 12;
				break;
			case 'Mild':
				ctx.lineWidth = 8;
				break;
		}

		ctx.stroke();

		// Demonstration blurred line
		//this.drawSoftLine(-200, -200, 200, 200, 40, 255, 0, 0, 1);
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Episcleritis.prototype.groupDescription = function() {
	var returnString = this.severity + " episcleritis";

	// Unless nearly complete, include quadrant
	if (this.arc < 1.8 * Math.PI) {
		returnString += " centred "

		// Use trigonometry on rotation field to determine quadrant
		returnString += (Math.cos(this.rotation) > 0 ? "supero" : "infero");
		returnString += (Math.sin(this.rotation) > 0 ? (this.drawing.eye == ED.eye.Right ? "nasally" : "temporally") : (this.drawing.eye == ED.eye.Right ? "temporally" : "nasally"));
	}
	return returnString
}

ED.Episcleritis.prototype.drawSoftLine = function(x1, y1, x2, y2, lineWidth, r, g, b, a) {
	// Get context
	var ctx = this.drawing.context;

	var lx = x2 - x1;
	var ly = y2 - y1;
	var lineLength = Math.sqrt(lx*lx + ly*ly);
	var wy = lx / lineLength * lineWidth;
	var wx = ly / lineLength * lineWidth;
	// The gradient must be defined across the line, 90 turned compared to the line direction.
	var gradient = ctx.createLinearGradient(x1-wx/2, y1+wy/2, x1+wx/2, y1-wy/2);
	gradient.addColorStop(0,    "rgba("+r+","+g+","+b+",0)");
	gradient.addColorStop(0.43, "rgba("+r+","+g+","+b+","+a+")");
	gradient.addColorStop(0.57, "rgba("+r+","+g+","+b+","+a+")");
	gradient.addColorStop(1,    "rgba("+r+","+g+","+b+",0)");
	ctx.save();
	ctx.beginPath();
	ctx.lineWidth = lineWidth;
	ctx.strokeStyle = gradient;
	ctx.moveTo(x1, y1);
	ctx.lineTo(x2, y2);
	ctx.stroke();
	ctx.restore();
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Eyeball
 *
 * @class Eyeball
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Eyeball = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Eyeball";

	// Saved parameters
// 	this.savedParameterArray = [];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Eyeball.prototype = new ED.Doodle;
ED.Eyeball.prototype.constructor = ED.Eyeball;
ED.Eyeball.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Eyeball.prototype.setHandles = function() {
}

/**
 * Sets default dragging attributes
 */
ED.Eyeball.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
	this.isFilled = false;
}

/**
 * Sets default parameters
 */
ED.Eyeball.prototype.setParameterDefaults = function() {
  this.isDeletable = false;
  this.isMoveable = false;
  this.isScalable = false;
  this.isRotatable= false;
  this.isShowHighlight = false;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Eyeball.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Eyeball.superclass.draw.call(this, _point);

	// Radius
	var r = 250;

	// Boundary path
	ctx.beginPath();

	
	// Boundary path
	ctx.beginPath();

	// Main eyeball
	ctx.arc(0, 0, r, 0, 2*Math.PI, true);

	// Close path
	ctx.closePath();

	// Set drawing attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "black";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		
		// iris
		var rI = 120;
		ctx.beginPath();
		ctx.moveTo(0+rI, 0);
		ctx.arc(0,0,rI, 0, 2*Math.PI);
		ctx.fillStyle = "gray";
		ctx.fill();
		ctx.stroke();
		ctx.closePath();
		
		// pupil
		var rP = 45;
		ctx.beginPath();
		ctx.moveTo(0+rP, 0);
		ctx.arc(0,0,rP, 0, 2*Math.PI);
		ctx.fillStyle = "black";
		ctx.stroke();
		ctx.fill();
		ctx.closePath();
		
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Fibrous Proliferation
 *
 * @class FibrousProliferation
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.FibrousProliferation = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "FibrousProliferation";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY', 'rotation']

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.FibrousProliferation.prototype = new ED.Doodle;
ED.FibrousProliferation.prototype.constructor = ED.FibrousProliferation;
ED.FibrousProliferation.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.FibrousProliferation.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, true);
}

/**
 * Set default properties
 */
ED.FibrousProliferation.prototype.setPropertyDefaults = function() {
	this.isSqueezable = true;
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +2);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +2);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.FibrousProliferation.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(-200, 150);
	this.rotation = this.drawing.eye == ED.eye.Right ? -Math.PI / 4 : Math.PI / 4;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.FibrousProliferation.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.FibrousProliferation.superclass.draw.call(this, _point);

	// Dimensions
	var w = 180;
	var h = 70;
	var wc = w * 0.6;
	var hc = h * 0.2;

	// Boundary path
	ctx.beginPath();

	// Patch with scalloped edges
	ctx.moveTo(-w, -h);
	ctx.bezierCurveTo(-wc, -hc, wc, -hc, w, -h);
	ctx.bezierCurveTo(wc, -hc, wc, hc, w, h);
	ctx.bezierCurveTo(wc, hc, -wc, hc, -w, h);
	ctx.bezierCurveTo(-wc, hc, -wc, -hc, -w, -h);

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 1;
	ctx.strokeStyle = "rgba(120,120,120,0.5)";
	ctx.fillStyle = "rgba(120,120,120,0.5)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(w, -h));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.FibrousProliferation.prototype.description = function() {
	return "Fibrous proliferation";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * FibrovascularScar
 *
 * @class FibrovascularScar
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.FibrovascularScar = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "FibrovascularScar";
	
	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.FibrovascularScar.prototype = new ED.Doodle;
ED.FibrovascularScar.prototype.constructor = ED.FibrovascularScar;
ED.FibrovascularScar.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.FibrovascularScar.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Set default properties
 */
ED.FibrovascularScar.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +2);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +2);
}

/**
 * Sets default parameters
 */
ED.FibrovascularScar.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(0, -100);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.FibrovascularScar.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.FibrovascularScar.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Radius of FibrovascularScar
	var r = 80;

	// Parameters of random curve
	var n = 16;
	var phi = 2 * Math.PI / n;
	var th = 0.5 * Math.PI / n;
	var b = 4;
	var point = new ED.Point(0, 0);

	// First point
	var fp = new ED.Point(0, 0);
	fp.setWithPolars(r, 0);
	ctx.moveTo(fp.x, fp.y);
	var rl = r;

	// Subsequent points
	for (var i = 0; i < n; i++) {
		// Get radius of next point
		var rn = r * (b + ED.randomArray[i]) / b;

		// Control point 1
		var cp1 = new ED.Point(0, 0);
		cp1.setWithPolars(rl, i * phi + th);

		// Control point 2
		var cp2 = new ED.Point(0, 0);
		cp2.setWithPolars(rn, (i + 1) * phi - th);

		// Next point
		var pn = new ED.Point(0, 0);
		pn.setWithPolars(rn, (i + 1) * phi);

		// Assign next point
		rl = rn;

		// Next point
		if (i == n - 1) {
			ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, fp.x, fp.y);
		} else {
			ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, pn.x, pn.y);
		}

		// Control handle point
		if (i == 1) {
			point.x = pn.x;
			point.y = pn.y;
		}
	}

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "rgba(255,255,190,1)";
	ctx.strokeStyle = ctx.fillStyle;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Yellow centre
		ctx.beginPath();
		ctx.arc(0, 0, r * 0.8, 0, 2 * Math.PI, false);
		ctx.closePath();
		ctx.fillStyle = "rgba(255,255,230,1)";
		ctx.fill();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.FibrovascularScar.prototype.description = function() {
	return "Fibrovascular scar";
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
// ED.FibrovascularScar.prototype.snomedCode = function() {
// 	return 314517003;
// }

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
// ED.FibrovascularScar.prototype.diagnosticHierarchy = function() {
// 	return 2;
// }

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Round hole
 *
 * @class FieldCircle
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.FieldCircle = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "FieldCircle";

	// Derived parameters
	this.colour = new ED.Colour(255,0,0,1);

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'colour'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.FieldCircle.prototype = new ED.Doodle;
ED.FieldCircle.prototype.constructor = ED.FieldCircle;
ED.FieldCircle.superclass = ED.Doodle.prototype;

/**
 * Sets default properties
 */
ED.FieldCircle.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['colour'] = {
		kind: 'derived',
		type: 'colour',
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.FieldCircle.prototype.setParameterDefaults = function() {

}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.FieldCircle.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.FieldCircle.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Round hole
	ctx.arc(0, 0, 50, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 1;
	ctx.fillStyle = this.colour.rgba();
	ctx.strokeStyle = ctx.fillStyle;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * The optic disc
 *
 * @class FocalChoroiditis
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.FocalChoroiditis = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "FocalChoroiditis";

	// Other parameters
	this.pigmented = false;

	// Private parameters
	this.numberOfHandles = 4;
	this.initialRadius = 80;

	// Saved parameters
	this.savedParameterArray = ['pigmented', 'originX', 'originY', 'apexX', 'apexY', 'rotation'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'pigmented':'Pigmented'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.FocalChoroiditis.prototype = new ED.Doodle;
ED.FocalChoroiditis.prototype.constructor = ED.FocalChoroiditis;
ED.FocalChoroiditis.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.FocalChoroiditis.prototype.setHandles = function() {
	// Array of handles
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	}

	// Allow top handle to rotate doodle
	this.handleArray[0].isRotatable = true;

	// Handle for apex
	//this.handleArray[this.numberOfHandles] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.FocalChoroiditis.prototype.setPropertyDefaults = function() {
	// Create ranges to constrain handles
	this.handleVectorRangeArray = new Array();
	for (var i = 0; i < this.numberOfHandles; i++) {
		// Full circle in radians
		var cir = 2 * Math.PI;

		// Create a range object for each handle
		var n = this.numberOfHandles;
		var range = new Object;
		range.length = new ED.Range(+50, +290);
		range.angle = new ED.Range((((2 * n - 1) * cir / (2 * n)) + i * cir / n) % cir, ((1 * cir / (2 * n)) + i * cir / n) % cir);
		this.handleVectorRangeArray[i] = range;
	}

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-50, +50);

	this.addAtBack = true;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['pigmented'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
}

/**
 * Sets default parameters
 */
ED.FocalChoroiditis.prototype.setParameterDefaults = function() {
	this.apexY = 50;
	this.setOriginWithDisplacements(200, 150);

	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate with handles at equidistant points around circumference
	for (var i = 0; i < this.numberOfHandles; i++) {
		var point = new ED.Point(0, 0);
		point.setWithPolars(this.initialRadius, i * 2 * Math.PI / this.numberOfHandles);
		this.addPointToSquiggle(point);
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.FocalChoroiditis.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.FocalChoroiditis.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Bezier points
	var fp;
	var tp;
	var cp1;
	var cp2;

	// Angle of control point from radius line to point (this value makes path a circle Math.PI/12 for 8 points
	var phi = 2 * Math.PI / (3 * this.numberOfHandles);

	// Start curve
	ctx.moveTo(this.squiggleArray[0].pointsArray[0].x, this.squiggleArray[0].pointsArray[0].y);

	// Complete curve segments
	for (var i = 0; i < this.numberOfHandles; i++) {
		// From and to points
		fp = this.squiggleArray[0].pointsArray[i];
		var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
		tp = this.squiggleArray[0].pointsArray[toIndex];

		// Control points
		cp1 = fp.tangentialControlPoint(+phi);
		cp2 = tp.tangentialControlPoint(-phi);

		// Draw Bezier curve
		ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);
	}

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 8;
	if (this.pigmented) {
		ctx.fillStyle = "rgba(255, 255, 200, 0.8)";
		ctx.strokeStyle = "brown";
	}
	else {
		ctx.fillStyle = "rgba(255, 255, 0, 0.8)";
		ctx.strokeStyle = ctx.fillStyle;
	}

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
	}

	// Coordinates of handles (in canvas plane)
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[i]);
	}
	this.handleArray[this.numberOfHandles].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.FocalChoroiditis.prototype.description = function() {
	return 'FocalChoroiditis';
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
// ED.FocalChoroiditis.prototype.snomedCode = function() {
// 	return 255024002;
// }
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Focal laser
 *
 * @class FocalLaser
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.FocalLaser = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "FocalLaser";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexY'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.FocalLaser.prototype = new ED.Doodle;
ED.FocalLaser.prototype.constructor = ED.FocalLaser;
ED.FocalLaser.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.FocalLaser.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.FocalLaser.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-75, -50);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.FocalLaser.prototype.setParameterDefaults = function() {
	this.apexY = -50;
	this.setOriginWithDisplacements(150, 80);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.FocalLaser.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PRPPostPole.superclass.draw.call(this, _point);

	// Radius of outer circle
	var ro = -this.apexY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, 0, 2 * Math.PI, true);

	// Close path
	ctx.closePath();

	// Set line attributes (NB Note strokeStyle in order to get a highlight when selected
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(255, 255, 255, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Outer ring
		if (this.apexY <= -75) {
			var m = 50;
			var d = m / Math.sqrt(2);
			this.drawLaserSpot(ctx, 0, -m);
			this.drawLaserSpot(ctx, d, -d);
			this.drawLaserSpot(ctx, m, 0);
			this.drawLaserSpot(ctx, d, d);
			this.drawLaserSpot(ctx, 0, m);
			this.drawLaserSpot(ctx, -d, d);
			this.drawLaserSpot(ctx, -m, 0);
			this.drawLaserSpot(ctx, -d, -d);
		}

		// Inner ring
		var i = 25;
		this.drawLaserSpot(ctx, 0, -i);
		this.drawLaserSpot(ctx, i, 0);
		this.drawLaserSpot(ctx, 0, i);
		this.drawLaserSpot(ctx, -i, 0);

		// Central spot
		this.drawLaserSpot(ctx, 0, 0);
	}

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(ro, Math.PI / 4);
	this.handleArray[4].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.FocalLaser.prototype.groupDescription = function() {
	return "Focal laser";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Fuch's endothelial Dystrophy
 *
 * @class Fuchs
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Fuchs = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Fuchs";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
};

/**
 * Sets superclass and constructor
 */
ED.Fuchs.prototype = new ED.Doodle;
ED.Fuchs.prototype.constructor = ED.Fuchs;
ED.Fuchs.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Fuchs.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
};

/**
 * Sets default properties
 */
ED.Fuchs.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;
	this.isSqueezable = true;
	this.isUnique = true;
};

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Fuchs.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Fuchs.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Fuchs
	var r = 300;
	ctx.arc(0, 0, r, 0, Math.PI * 2, false);

	// Close path
	ctx.closePath();

	// Create fill pattern
	var ptrn = ctx.createPattern(this.drawing.imageArray['FuchsPattern'], 'repeat');
	ctx.fillStyle = ptrn;

	// Transparent stroke
	ctx.strokeStyle = "rgba(255,255,255,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
};

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Fuchs.prototype.description = function() {
	return "Guttata";
};

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.Fuchs.prototype.snomedCode = function() {
	return 0;
};

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.Fuchs.prototype.diagnosticHierarchy = function() {
	return 2;
};

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Fundus template with disc and arcades, extends to ora. Natively right eye, flipFundus for left eye
 *
 * @class Fundus
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Fundus = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Fundus";

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
};

/**
 * Sets superclass and constructor
 */
ED.Fundus.prototype = new ED.Doodle;
ED.Fundus.prototype.constructor = ED.Fundus;
ED.Fundus.superclass = ED.Doodle.prototype;

/**
 * Set default properties
 */
ED.Fundus.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
	this.isDeletable = false;
	this.isFilled = false;
	this.showsToolTip = false;
};

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Fundus.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Fundus.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Ora
	ctx.arc(0, 0, 480, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 2;
	ctx.strokeStyle = "red";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// These values different for right and left side
		if (this.drawing.eye != ED.eye.Right) {
			var startX = 200;
			var midX = 100;
			var ctrlX = -50;
			var endX = -100;
			var foveaX = 100;
		} else {
			var startX = -200;
			var midX = -100;
			var ctrlX = 50;
			var endX = 100;
			var foveaX = -100;
		}

		// Superior arcades
		ctx.moveTo(startX, -50);
		ctx.bezierCurveTo(midX, -166, 0, -62, 0, -12);
		ctx.bezierCurveTo(0, -40, ctrlX, -100, endX, -50);

		// Inferior arcades
		ctx.moveTo(startX, 50);
		ctx.bezierCurveTo(midX, 166, 0, 62, 0, 12);
		ctx.bezierCurveTo(0, 40, ctrlX, 100, endX, 50);

		// Small cross marking fovea
		var crossLength = 10;
		ctx.moveTo(foveaX, -crossLength);
		ctx.lineTo(foveaX, crossLength);
		ctx.moveTo(foveaX - crossLength, 0);
		ctx.lineTo(foveaX + crossLength, 0);

		// Optic disc and cup
		ctx.moveTo(25, 0);
		ctx.arc(0, 0, 25, 0, Math.PI * 2, true);
		ctx.moveTo(12, 0);
		ctx.arc(0, 0, 12, 0, Math.PI * 2, true);

		// Draw it
		ctx.stroke();
	}

	// Return value indicating successful hittest
	return this.isClicked;
};

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Fundus.prototype.description = function() {
	return this.drawing.doodleArray.length === 1 ? "No abnormality" : "";
};

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Geographic atrophy with variabel foveal sparing
 *
 * @class Geographic
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Geographic = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Geographic";

	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Geographic.prototype = new ED.Doodle;
ED.Geographic.prototype.constructor = ED.Geographic;
ED.Geographic.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Geographic.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.Geographic.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-100, +0);
}

/**
 * Sets default parameters
 */
ED.Geographic.prototype.setParameterDefaults = function() {
	this.apexY = -100;
	this.scaleX = 0.7;
	this.scaleY = 0.7;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Geographic.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Geographic.superclass.draw.call(this, _point);

	// Radius of limbus
	var ro = 200;
	var ri = -this.apexY;
	var phi = -this.apexY * Math.PI / 800;

	// Boundary path
	ctx.beginPath();

	var point = new ED.Point(0, 0);

	// Outer arc
	if (this.drawing.eye == ED.eye.Right) {
		ctx.arc(0, 0, ro, phi, 2 * Math.PI - phi, false);
		point.setWithPolars(ri, Math.PI / 2 - phi);
		ctx.lineTo(point.x, point.y);
		ctx.arc(0, 0, ri, 2 * Math.PI - phi, phi, true);
	} else {
		ctx.arc(0, 0, ro, Math.PI - phi, -Math.PI + phi, true);
		point.setWithPolars(ri, phi - Math.PI / 2);
		ctx.lineTo(point.x, point.y);
		ctx.arc(0, 0, ri, -Math.PI + phi, Math.PI - phi, false);
	}

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255,255,50,0.8)";
	ctx.strokeStyle = "rgba(100,100,100,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {}

	// Coordinates of handles (in canvas plane)
	point = new ED.Point(0, 0);
	point.setWithPolars(ro, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Geographic.prototype.description = function() {
	return "Geographic atrophy";
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.Geographic.prototype.snomedCode = function() {
	return 414875008;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.Geographic.prototype.diagnosticHierarchy = function() {
	return 2;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Gonioscopy
 *
 * @class Gonioscopy
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Gonioscopy = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Gonioscopy";

	// Private parameters
	this.rsl = 480;
	this.rsli = 470;
	this.rtmo = 404;
	this.rtmi = 304;
	this.rcbo = 270;
	this.rcbi = 190;
	this.riro = 190;
	this.riri = 176;
	this.rpu = 100;

    this.mode = "Basic";

	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY', 'mode'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Gonioscopy.prototype = new ED.Doodle;
ED.Gonioscopy.prototype.constructor = ED.Gonioscopy;
ED.Gonioscopy.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Gonioscopy.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.Gonioscopy.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-460, -420);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-460, -400);

    this.parameterValidationArray['mode'] = {
	kind: 'derived',
	type: 'string',
	list: ['Basic', 'Expert'],
	animate: false
    };
}

/**
 * Sets default parameters
 */
ED.Gonioscopy.prototype.setParameterDefaults = function() {
	this.apexX = -460;
	this.apexY = -460;
    this.setParameterFromString('mode', 'Basic');
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Gonioscopy.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Gonioscopy.superclass.draw.call(this, _point);

	// Calculate parameters for arcs
	var arcStart = 0;
	var arcEnd = 2 * Math.PI;

	// Boundary path
	ctx.beginPath();

	// Do a 360 arc
	ctx.arc(0, 0, this.rsl, arcStart, arcEnd, true);

	// Set line attributes
	ctx.lineWidth = 15;
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "rgba(200, 200, 200, 1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Trabecular meshwork
		ctx.beginPath();

		// Arc across, move to inner and arc back
		ctx.arc(0, 0, this.rtmo, arcStart, arcEnd, true);
		ctx.moveTo(this.rtmi, 0);
		ctx.arc(0, 0, this.rtmi, arcEnd, arcStart, false);

		// Set line attributes
		ctx.lineWidth = 1;

		// Fill style
		var ptrn;

		// Pattern
		if (this.apexX < -440) {
			if (this.apexY < -440) ptrn = ctx.createPattern(this.drawing.imageArray['MeshworkPatternLight'], 'repeat');
			else if (this.apexY < -420) ptrn = ctx.createPattern(this.drawing.imageArray['MeshworkPatternMedium'], 'repeat');
			else ptrn = ctx.createPattern(this.drawing.imageArray['MeshworkPatternHeavy'], 'repeat');
			ctx.fillStyle = ptrn;
		}
		// Uniform
		else {
			if (this.apexY < -440) ctx.fillStyle = "rgba(250, 200, 0, 1)";
			else if (this.apexY < -420) ctx.fillStyle = "rgba(200, 150, 0, 1)";
			else ctx.fillStyle = "rgba(150, 100, 0, 1)";
		}

		// Stroke style
		ctx.strokeStyle = "rgba(200, 200, 200, 1)";

		// Draw it
		ctx.fill();
		ctx.stroke();

		// Ciliary Body
		ctx.beginPath();

		// Arc across, move to inner and arc back
		ctx.arc(0, 0, this.rcbo, arcStart, arcEnd, true);
		ctx.arc(0, 0, this.rcbi, arcEnd, arcStart, false);

		// Draw it
		ctx.fillStyle = "rgba(200, 200, 200, 1)";
		ctx.fill();

		// Draw radial lines
		var firstAngle = 15;
		var innerPoint = new ED.Point(0, 0);
		var outerPoint = new ED.Point(0, 0);
		var i = 0;

		// Loop through clock face
		for (i = 0; i < 12; i++) {
			// Get angle
			var angleInRadians = (firstAngle + i * 30) * Math.PI / 180;
			innerPoint.setWithPolars(this.rcbi, angleInRadians);

			// Set new line
			ctx.beginPath();
			ctx.moveTo(innerPoint.x, innerPoint.y);

			// Some lines are longer, wider and darker
			if (i == 1 || i == 4 || i == 7 || i == 10) {
				outerPoint.setWithPolars(this.rsl + 80, angleInRadians);
				ctx.lineWidth = 6;
				ctx.strokeStyle = "rgba(20, 20, 20, 1)";
			} else {
				outerPoint.setWithPolars(this.rsl, angleInRadians);
				ctx.lineWidth = 2;
				ctx.strokeStyle = "rgba(137, 137, 137, 1)";
			}

			// Draw line
			ctx.lineTo(outerPoint.x, outerPoint.y);
			ctx.closePath();
			ctx.stroke();
		}

		// Iris
		ctx.beginPath();

		// Arc across, move to inner and arc back
		ctx.arc(0, 0, this.riro, arcStart, arcEnd, true);
		ctx.arc(0, 0, this.riri, arcEnd, arcStart, false);

		// Set attributes
		ctx.lineWidth = 2;
		ctx.strokeStyle = "rgba(180, 180, 180, 1)";
		ctx.fillStyle = "rgba(200, 200, 200, 1)";

		// Draw it
		ctx.fill();
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle (overridden by subclasses)
 *
 * @returns {String} Description of doodle
 */
ED.Gonioscopy.prototype.description = function() {
	var returnValue = "";

	if (this.apexX < -440) {
		if (this.apexY < -440) returnValue = "Light patchy pigment";
		else if (this.apexY < -420) returnValue = "Medium patchy pigment";
		else returnValue = "Heavy patchy pigment";
	}
	// Uniform
	else {
		if (this.apexY < -440) returnValue = "Light homogenous pigment";
		else if (this.apexY < -420) returnValue = "Medium homogenous pigment";
		else returnValue = "Heavy homogenous pigment";
	}

	return returnValue;
}

/**
 * Giant retinal tear
 *
 * @class GRT
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.GRT = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "GRT";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.GRT.prototype = new ED.Doodle;
ED.GRT.prototype.constructor = ED.GRT;
ED.GRT.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.GRT.prototype.setHandles = function() {
	this.handleArray[1] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.GRT.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-450, -250);
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 2, Math.PI * 2);
}

/**
 * Sets default parameters
 */
ED.GRT.prototype.setParameterDefaults = function() {
	this.arc = 90 * Math.PI / 180;
	this.apexY = -350;
	this.setRotationWithDisplacements(0, 120);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.GRT.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RRD.superclass.draw.call(this, _point);

	// Fit outer curve just inside ora (ro = outer radius, rt = tear radius, ri = operculum (inner) radius)
	var ro = 952 / 2;
	var ri = -this.apexY;
	var rt = ri + (ro - ri) / 2;

	// Calculate parameters for arcs. Theta is outer arc, phi is base of tear
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;
	var phi = this.arc / 2.3;
	var tearStart = -Math.PI / 2 + phi;
	var tearEnd = -Math.PI / 2 - phi;

	// Coordinates of corners of arc
	var topRightX = ro * Math.sin(theta);
	var topRightY = -ro * Math.cos(theta);
	var topLeftX = -ro * Math.sin(theta);
	var topLeftY = topRightY;
	var middleRightX = rt * Math.sin(phi);
	var middleRightY = -rt * Math.cos(phi);
	var middleLeftX = -middleRightX;
	var middleLeftY = middleRightY;
	var bottomRightX = ri * Math.sin(theta);
	var bottomRightY = -ri * Math.cos(theta);
	var bottomLeftX = -bottomRightX;
	var bottomLeftY = bottomRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across from top right to to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Straight line to base of tear then to start of operculum
	ctx.lineTo(middleLeftX, middleLeftY);
	ctx.lineTo(bottomLeftX, bottomLeftY);

	// Another arc going the other way
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Straight line to base of tear on this side
	ctx.lineTo(middleRightX, middleRightY);

	// Close path to join to starting point
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 8;
	ctx.fillStyle = "red";
	ctx.strokeStyle = "blue";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other stuff here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();
		ctx.arc(0, 0, rt, tearStart, tearEnd, true);
		ctx.strokeStyle = "darkred";
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[1].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.GRT.prototype.description = function() {
	var returnString = "Giant Retinal Tear ";

	// Use trigonometry on rotation field to get clock hour of start (0.2618 is PI/12)
	var start = this.rotation - this.arc / 2;
	var clockHour = Math.floor((((start + 0.2618) * 6 / Math.PI) + 12) % 12);
	if (clockHour == 0) clockHour = 12;

	// Get extent of tear in degrees
	var extent = (this.arc * 180 / Math.PI);

	// Round to nearest 10
	extent = 10 * Math.floor((extent + 5) / 10);

	returnString = returnString + extent + " degrees clockwise from " + clockHour + " o'clock";

	return returnString;
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.GRT.prototype.snomedCode = function() {
	return 232004004;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.GRT.prototype.diagnosticHierarchy = function() {
	return 7;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Hard Drusen
 *
 * @class HardDrusen
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.HardDrusen = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "HardDrusen";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.HardDrusen.prototype = new ED.Doodle;
ED.HardDrusen.prototype.constructor = ED.HardDrusen;
ED.HardDrusen.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.HardDrusen.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.HardDrusen.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-160, +0);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.5);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.HardDrusen.prototype.setParameterDefaults = function() {
	// Hard drusen is displaced for Fundus, central for others
	if (this.drawing.hasDoodleOfClass('Fundus')) {
		this.originX = this.drawing.eye == ED.eye.Right ? -100 : 100;
		this.scaleX = 0.5;
		this.scaleY = 0.5;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.HardDrusen.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.HardDrusen.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Invisible boundary
	var r = 200;
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Colours
		var fill = "yellow";

		var dr = 10 / this.scaleX;

		var p = new ED.Point(0, 0);
		var n = 20 + Math.abs(Math.floor(this.apexY / 2));
		for (var i = 0; i < n; i++) {
			p.setWithPolars(r * ED.randomArray[i], 2 * Math.PI * ED.randomArray[i + 100]);
			this.drawSpot(ctx, p.x, p.y, dr, fill);
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(r * 0.7, -r * 0.7));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.HardDrusen.prototype.description = function() {
	var returnString = "Signficant numbers of ";
	if (this.apexY > -100) returnString = "Moderate numbers of ";
	if (this.apexY > -50) returnString = "Several ";

	return returnString + "hard drusen";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Hard exudate
 *
 * @class HardExudate
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.HardExudate = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "HardExudate";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.HardExudate.prototype = new ED.Doodle;
ED.HardExudate.prototype.constructor = ED.HardExudate;
ED.HardExudate.superclass = ED.Doodle.prototype;

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.HardExudate.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(50, 30);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.HardExudate.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.HardExudate.superclass.draw.call(this, _point);

	// Exudate radius
	var r = 14;

	// Boundary path
	ctx.beginPath();

	// Exudate
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 1;
	ctx.strokeStyle = "rgba(220,220,0,1)";
	ctx.fillStyle = "rgba(220,220,0,1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.HardExudate.prototype.groupDescription = function() {
	return "Hard exudates";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * HVT
 *
 * @class HVT Horizontal Vertical Torsion indicator
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.HVT = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "HVT";

	// Derived parameters
	this.hor = 'None';
	this.ver = 'None';
	this.tor = 'None';
	this.horValue = 0;
	this.verValue = 0;
	this.torValue = 0;

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.HVT.prototype = new ED.Doodle;
ED.HVT.prototype.constructor = ED.HVT;
ED.HVT.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.HVT.prototype.setHandles = function() {
	this.handleArray[1] = new ED.Doodle.Handle(null, true, ED.Mode.Rotate, false);
}

/**
 * Sets default dragging attributes
 */
ED.HVT.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isShowHighlight = false;

	// Adjust ranges for simple parameters
	this.parameterValidationArray['originX']['range'] = new ED.Range(-350, -150);
	this.parameterValidationArray['originY']['range'] = new ED.Range(-100, +100);
	this.parameterValidationArray['rotation']['range'] = new ED.Range(0, Math.PI / 2);

	// Speed up horizontal and vertical animation
	//this.parameterValidationArray['originX']['delta'] = 30;
	//this.parameterValidationArray['originY']['delta'] = 30;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['hor'] = {
		kind: 'derived',
		type: 'string',
		list: ['XT', 'None', 'ET'],
		animate: true
	};
	this.parameterValidationArray['ver'] = {
		kind: 'derived',
		type: 'string',
		list: ['R/L', 'None', 'L/R'],
		animate: true
	};
	this.parameterValidationArray['tor'] = {
		kind: 'derived',
		type: 'string',
		list: ['Excyclotorsion', 'None', 'Incyclotorsion'],
		animate: true
	};
	this.parameterValidationArray['horValue'] = {
		kind: 'derived',
		type: 'int',
		range: new ED.Range(0, 50),
		animate: true
	};
	this.parameterValidationArray['verValue'] = {
		kind: 'derived',
		type: 'int',
		range: new ED.Range(0, 50),
		animate: true
	};
	this.parameterValidationArray['torValue'] = {
		kind: 'derived',
		type: 'int',
		range: new ED.Range(0, 20),
		animate: true
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.HVT.prototype.setParameterDefaults = function() {
	//this.originX = -250;
	//this.rotation = Math.PI/4;
	//this.setParameterFromString('hor', 'None');
	//this.setParameterFromString('tor', 'None');
	//this.setParameterFromString('horValue', '0');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.HVT.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	// Value of centre for right eye (binding done on right eye only, left eye values handled by syncing)
	var centre = -250;

	switch (_parameter) {
		case 'originX':
			// hor
			var fudge = 20;
			if (_value < centre - fudge) {
				returnArray['hor'] = 'XT';
			} else if (_value > centre + fudge) {
				returnArray['hor'] = 'ET';
			} else {
				returnArray['hor'] = 'None';
			}
			// horValue
			returnArray['horValue'] = Math.abs(Math.round((centre - _value)/2));
			break;

		case 'originY':
			var fudge = 20;
			if (_value < 0 - fudge) {
				returnArray['ver'] = 'R/L';
			} else if (_value > 0 + fudge) {
				returnArray['ver'] = 'L/R';
			} else {
				returnArray['ver'] = 'None';
			}
			// verValue
			returnArray['verValue'] = Math.abs(Math.round((- _value/2)));
			break;

		case 'rotation':
			var fudge = Math.PI / 16;
			if (_value < Math.PI / 4 - fudge) {
				returnArray['tor'] = 'Excyclotorsion';
			} else if (_value > Math.PI / 4 + fudge) {
				returnArray['tor'] = 'Incyclotorsion';
			} else {
				returnArray['tor'] = 'None';
			}
			// torValue
			returnArray['torValue'] = Math.abs(Math.round((_value - Math.PI/4) * 80/Math.PI));
			break;

		case 'hor':
			switch (_value) {
				case 'XT':
					returnArray['originX'] = centre - 100;
					break;

				case 'ET':
					returnArray['originX'] = centre + 100;
					break;

				default:
					returnArray['originX'] = centre;
					break;
			}
			break;

		case 'ver':
			switch (_value) {
				case 'R/L':
					returnArray['originY'] = 0 - 100;
					break;

				case 'L/R':
					returnArray['originY'] = 0 + 100;
					break;

				default:
					returnArray['originY'] = 0;
					break;
			}
			break;

		case 'tor':
			switch (_value) {
				case 'Excyclotorsion':
					returnArray['rotation'] = 0;
					break;

				case 'Incyclotorsion':
					returnArray['rotation'] = Math.PI / 2;
					break;

				default:
					returnArray['rotation'] = Math.PI / 4;
					break;
			}
			break;

		case 'horValue':
			switch (this.hor) {
				case 'XT':
					returnArray['originX'] = centre - _value * 2;
					break;
				case 'None':
					returnArray['originX'] = centre;
					break;
				case 'ET':
					returnArray['originX'] = centre + _value * 2;
					break;
			}
			break;

		case 'verValue':
			switch (this.ver) {
				case 'R/L':
					returnArray['originY'] = - _value * 2;
					break;
				case 'None':
					returnArray['originY'] = Math.PI / 4;
					break;
				case 'L/R':
					returnArray['originY'] = _value * 2;
					break;
			}
			break;

		case 'torValue':
			switch (this.tor) {
				case 'Excyclotorsion':
					returnArray['rotation'] = - _value * Math.PI/80 + Math.PI/4;
					break;
				case 'None':
					returnArray['rotation'] = Math.PI/4;
					break;
				case 'Incyclotorsion':
					returnArray['rotation'] = _value * Math.PI/80 + Math.PI/4;
					break;
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.HVT.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.HVT.superclass.draw.call(this, _point);

	// Radius of outer curve just inside ora on right and left fundus diagrams
	var ro = 125;
	var ri = 40;

	// Use polar coordinates to draw axis line and handle
	var phi = 1.75 * Math.PI;
	var p = new ED.Point(0, 0);

	// Boundary path
	ctx.beginPath();

	// Circle
	ctx.arc(0, 0, ro, 0, 2 * Math.PI, true);

	// Move to inner circle
	ctx.moveTo(ri, 0);

	// Arc back the other way
	ctx.arc(0, 0, ri, 2 * Math.PI, 0, false);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = ctx.fillStyle = "rgba(100, 200, 250, 0.5)";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Axis lines
		var d = 5;
		ctx.beginPath();

		// Define axis
		p.setWithPolars(ro - d, phi);
		ctx.moveTo(p.x, p.y);
		p.setWithPolars(ri + d, phi);
		ctx.lineTo(p.x, p.y);
		p.setWithPolars(-ro + d, phi);
		ctx.moveTo(p.x, p.y);
		p.setWithPolars(-ri - d, phi);
		ctx.lineTo(p.x, p.y);

		// Draw it
		ctx.lineWidth = 20;
		if (this.originX > 0) ctx.strokeStyle = "rgba(255, 0, 0, 0.8)";
		else ctx.strokeStyle = "rgba(0, 155, 0, 0.8)";
		//ctx.strokeStyle = "rgba(100, 100, 100, 0.5)";
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	p.setWithPolars(ro, phi);
	this.handleArray[1].location = this.transform.transformPoint(p);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * HVTGrid
 *
 * @class HVTGrid ***TODO***
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.HVTGrid = function(_drawing, _parameterJSON) { 
	// Set classname
	this.className = "HVTGrid";

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.HVTGrid.prototype = new ED.Doodle;
ED.HVTGrid.prototype.constructor = ED.HVTGrid;
ED.HVTGrid.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.HVTGrid.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isShowHighlight = false;
	this.isSelectable = false;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.HVTGrid.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.HVTGrid.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Radius of HVT doodle
	var ro = 125;
	var d = ro * 2;
	ctx.moveTo(-2 * d, 0);
	ctx.lineTo(+2 * d, 0);
	ctx.moveTo(-d, -d);
	ctx.lineTo(-d, +d);
	ctx.moveTo(+d, -d);
	ctx.lineTo(+d, +d);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Hyphaema
 *
 * @class Hyphaema
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Hyphaema = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Hyphaema";

	// Private parameters
	this.ro = 380;
	this.minimum = 304;
	this.csOriginY = 0;
    this.csOriginX = 50;
	this.csApexX = 0;

    // Saved parameters
	this.savedParameterArray = ['apexX', 'apexY', 'csOriginY', 'csApexX', 'csOriginX'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Hyphaema.prototype = new ED.Doodle;
ED.Hyphaema.prototype.constructor = ED.Hyphaema;
ED.Hyphaema.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Hyphaema.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.Hyphaema.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-50, +50);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-380, this.minimum);
}

/**
 * Sets default parameters
 */
ED.Hyphaema.prototype.setParameterDefaults = function() {
	this.apexY = 152;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Hyphaema.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Hyphaema.superclass.draw.call(this, _point);

	// Calculate angle of apex above or below horizontal
	var phi = Math.asin(this.apexY / this.ro);

	// Boundary path
	ctx.beginPath();

	// Arc from point on circumference level with apex point to other side
	ctx.arc(0, 0, this.ro, phi, Math.PI - phi, false);

	// Close path
	ctx.closePath();

	// Colour of fill, density depends on setting of apexX
	var density = (0.1 + (this.apexX + 50) / 111).toFixed(2);
	ctx.fillStyle = "rgba(255,0,0," + density + ")";

	// Set line attributes
	ctx.lineWidth = 1;

	// Colour of outer line
	ctx.strokeStyle = ctx.fillStyle;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Hyphaema.prototype.description = function() {
	var percent = 10 * Math.round(10 * (this.ro - this.apexY) / (2 * this.ro));
	return percent + "% hyphaema";
}

/**
 * OpenEyes
 * MSC
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * MSC TODO: (1) Calculate t instead of current estimation based on time so level with apexY
 *           (2) Calculate x coordinate of stop positon if within inf / sup zonules 
 *
 * @class HyphaemaCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.HyphaemaCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "HyphaemaCrossSection";

	// Private parameters
	this.initialRadius = 360;
	
	// Derived parameters
	this.ro = 380;

	// Saved parameters
	this.savedParameterArray = ['originY', 'apexX', 'apexY', 'originX'];
	
	// Parameters in doodle control bar
	this.controlParameterArray = {};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

    this.linkedDoodleParameters = {
        'Hyphaema': {
            source: ['apexY'],
            store: [['originY', 'csOriginY'], ['apexX', 'csApexX'], ['originX', 'csOriginX']]
        }
    };
}

/**
 * Sets superclass and constructor
 */
ED.HyphaemaCrossSection.prototype = new ED.Doodle;
ED.HyphaemaCrossSection.prototype.constructor = ED.HyphaemaCrossSection;
ED.HyphaemaCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.HyphaemaCrossSection.prototype.setHandles = function() {
}

/**
 * Sets default properties
 */
ED.HyphaemaCrossSection.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
	this.addAtBack = true;
		
	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-50, +50);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-380, 304);
	
	
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.HyphaemaCrossSection.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
			
	}

	return returnArray;
}

/**
 * Sets default parameters
 */
ED.HyphaemaCrossSection.prototype.setParameterDefaults = function() {
	this.originX = 50; // as is in Cornea cross section doodle to dulicate bezier control points
	
	this.apexY = 152;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.HyphaemaCrossSection.prototype.draw = function(_point) {
	
	// Get context
	var ctx = this.drawing.context;

	var cornea = this.drawing.lastDoodleOfClass('CorneaCrossSection');
	var cornealThickness = cornea.pachymetry/5;

	// Call draw method in superclass
	ED.HyphaemaCrossSection.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();
	
	// Calculate segment extent in terms of time along curve
	var startY = this.apexY - this.apexY/12; //buffer needed as only estimating t
	var startT = (startY + 380) / 760;
	if (startT<0) startT = 0;
	var endT = 1;
		
	if (startT < 0.5) {
		
		var superiorBezierBack = new Object;

		// define start and end time points
		var tI0 = startT * 2;
		var tI1 = (endT < 0.5) ? endT * 2 : 1;
		
		// default bezier points (as in cornea cross section)
		if (cornea && cornea.shape == "Keratoconus") {
			superiorBezierBack.SP = new ED.Point(-120 + 120, -380 - this.originY);
			superiorBezierBack.CP1 = new ED.Point(-240 + 160, -260 - this.originY);
			superiorBezierBack.CP2 = new ED.Point(cornea.apexX + cornealThickness, cornea.apexY - 120 - this.originY);
			superiorBezierBack.EP = new ED.Point(cornea.apexX + cornealThickness, cornea.apexY - this.originY);
		}
		else if (cornea && cornea.shape == "Keratoglobus") {
			superiorBezierBack.SP = new ED.Point(-120 + 120, -380 - this.originY);
			superiorBezierBack.CP1 = new ED.Point(-240 + 120, -200 - this.originY);
			superiorBezierBack.CP2 = new ED.Point(-380 + 100, -140 - this.originY);
			superiorBezierBack.EP = new ED.Point(-380 + 100, 100 - this.originY);
		}
		else {
			superiorBezierBack.SP = new ED.Point(-120 + 120, -380 - this.originY);
			superiorBezierBack.CP1 = new ED.Point(-240 + 160, -260 - this.originY);
			superiorBezierBack.CP2 = new ED.Point(-320 + 100, -160 - this.originY);
			superiorBezierBack.EP = new ED.Point(-320 + 100, 0 - this.originY);
		}
		
			
		if (tI0 > 0) {
		// Trim start of curve			
			var sq0b = new ED.Point(0,0);
			sq0b.y = (1-tI0)*(1-tI0)*(1-tI0)*superiorBezierBack.SP.y + 3*(1-tI0)*(1-tI0)*tI0*superiorBezierBack.CP1.y + 3*(1-tI0)*tI0*tI0*superiorBezierBack.CP2.y + tI0*tI0*tI0*superiorBezierBack.EP.y;
			sq0b.x = (1-tI0)*(1-tI0)*(1-tI0)*superiorBezierBack.SP.x + 3*(1-tI0)*(1-tI0)*tI0*superiorBezierBack.CP1.x + 3*(1-tI0)*tI0*tI0*superiorBezierBack.CP2.x + tI0*tI0*tI0*superiorBezierBack.EP.x;
			
			var iP23b = new ED.Point(0,0);
			iP23b.x = superiorBezierBack.CP1.x + tI0 * (superiorBezierBack.CP2.x - superiorBezierBack.CP1.x);
			iP23b.y = superiorBezierBack.CP1.y + tI0 * (superiorBezierBack.CP2.y - superiorBezierBack.CP1.y);
			
			var iP34b = new ED.Point(0,0);
			iP34b.x = superiorBezierBack.CP2.x + tI0 * (superiorBezierBack.EP.x - superiorBezierBack.CP2.x);
			iP34b.y = superiorBezierBack.CP2.y + tI0 * (superiorBezierBack.EP.y - superiorBezierBack.CP2.y);
			
			var iP2334b = new ED.Point(0,0);
			iP2334b.x = iP23b.x + tI0 * (iP34b.x - iP23b.x);
			iP2334b.y = iP23b.y + tI0 * (iP34b.y - iP23b.y);
			
			superiorBezierBack.SP = sq0b;
			superiorBezierBack.CP1 = iP2334b;
			superiorBezierBack.CP2 = iP34b;
		}
		
		if (tI1 < 1) {
		// Trim end of curve
			var iq1b = new ED.Point(0,0);
			iq1b.y = (1-tI1)*(1-tI1)*(1-tI1)*superiorBezierBack.SP.y + 3*(1-tI1)*(1-tI1)*tI1*superiorBezierBack.CP1.y + 3*(1-tI1)*tI1*tI1*superiorBezierBack.CP2.y + tI1*tI1*tI1*superiorBezierBack.EP.y;
			iq1b.x = (1-tI1)*(1-tI1)*(1-tI1)*superiorBezierBack.SP.x + 3*(1-tI1)*(1-tI1)*tI1*superiorBezierBack.CP1.x + 3*(1-tI1)*tI1*tI1*superiorBezierBack.CP2.x + tI1*tI1*tI1*superiorBezierBack.EP.x;

			var iP12b = new ED.Point(0,0);
			iP12b.x = superiorBezierBack.SP.x + tI1 * (superiorBezierBack.CP1.x - superiorBezierBack.SP.x);
			iP12b.y = superiorBezierBack.SP.y + tI1 * (superiorBezierBack.CP1.y - superiorBezierBack.SP.y);
			
			var iP23b = new ED.Point(0,0);
			iP23b.x = superiorBezierBack.CP1.x + tI1 * (superiorBezierBack.CP2.x - superiorBezierBack.CP1.x);
			iP23b.y = superiorBezierBack.CP1.y + tI1 * (superiorBezierBack.CP2.y - superiorBezierBack.CP1.y);
			
			var iP1223b = new ED.Point(0,0);
			iP1223b.x = iP12b.x + tI1 * (iP23b.x - iP12b.x);
			iP1223b.y = iP12b.y + tI1 * (iP23b.y - iP12b.y);
			
			superiorBezierBack.CP1 = iP12b;
			superiorBezierBack.CP2 = iP1223b;
			superiorBezierBack.EP = iq1b;
		}
	}
	
	
	if (endT > 0.5) {
		
		var inferiorBezierBack = new Object;
		
		// define start and end time points
		var tS0 = (startT > 0.5) ? (startT - 0.5) * 2 : 0;
		var tS1 = (endT - 0.5) * 2;
		
		// default bezier points (as in cornea cross section)
		if (cornea && cornea.shape == "Keratoconus") {
			inferiorBezierBack.SP = new ED.Point(cornea.apexX + cornealThickness, cornea.apexY - this.originY);
			inferiorBezierBack.CP1 = new ED.Point(cornea.apexX + cornealThickness, cornea.apexY + 120 - this.originY);
			inferiorBezierBack.CP2 = new ED.Point(-240 + 160, 260 - this.originY);
			inferiorBezierBack.EP = new ED.Point(-120 + 120, 380 - this.originY);
		}
		else if (cornea && cornea.shape == "Keratoglobus") {
			inferiorBezierBack.SP = new ED.Point(-380 + 100, 100 - this.originY);
			inferiorBezierBack.CP1 = new ED.Point(-380 + 120, 220 - this.originY);
			inferiorBezierBack.CP2 = new ED.Point(-240 + 160, 260 - this.originY);
			inferiorBezierBack.EP = new ED.Point(-120 + 120, 380 - this.originY);
		}
		else {
			inferiorBezierBack.SP = new ED.Point(-320 + 100, -0 - this.originY);
			inferiorBezierBack.CP1 = new ED.Point(-320 + 100, 160 - this.originY);
			inferiorBezierBack.CP2 = new ED.Point(-240 + 160, 260 - this.originY);
			inferiorBezierBack.EP = new ED.Point(-120 + 120, 380 - this.originY);
		}			
		
		
		if (tS0 > 0) {
		// Trim start of curve
			var sq0b = new ED.Point(0,0);
			sq0b.y = (1-tS0)*(1-tS0)*(1-tS0)*inferiorBezierBack.SP.y + 3*(1-tS0)*(1-tS0)*tS0*inferiorBezierBack.CP1.y + 3*(1-tS0)*tS0*tS0*inferiorBezierBack.CP2.y + tS0*tS0*tS0*inferiorBezierBack.EP.y;
			sq0b.x = (1-tS0)*(1-tS0)*(1-tS0)*inferiorBezierBack.SP.x + 3*(1-tS0)*(1-tS0)*tS0*inferiorBezierBack.CP1.x + 3*(1-tS0)*tS0*tS0*inferiorBezierBack.CP2.x + tS0*tS0*tS0*inferiorBezierBack.EP.x;
			
			var sP23b = new ED.Point(0,0);
			sP23b.x = inferiorBezierBack.CP1.x + tS0 * (inferiorBezierBack.CP2.x - inferiorBezierBack.CP1.x);
			sP23b.y = inferiorBezierBack.CP1.y + tS0 * (inferiorBezierBack.CP2.y - inferiorBezierBack.CP1.y);
			
			var sP34b = new ED.Point(0,0);
			sP34b.x = inferiorBezierBack.CP2.x + tS0 * (inferiorBezierBack.EP.x - inferiorBezierBack.CP2.x);
			sP34b.y = inferiorBezierBack.CP2.y + tS0 * (inferiorBezierBack.EP.y - inferiorBezierBack.CP2.y);
			
			var sP2334b = new ED.Point(0,0);
			sP2334b.x = sP23b.x + tS0 * (sP34b.x - sP23b.x);
			sP2334b.y = sP23b.y + tS0 * (sP34b.y - sP23b.y);
			
			inferiorBezierBack.SP = sq0b;
			inferiorBezierBack.CP1 = sP2334b;
			inferiorBezierBack.CP2 = sP34b;
		}
		
		if (tS1 < 1) {
		// Trim end of curve
			var sq1b = new ED.Point(0,0);
			sq1b.y = (1-tS1)*(1-tS1)*(1-tS1)*inferiorBezierBack.SP.y + 3*(1-tS1)*(1-tS1)*tS1*inferiorBezierBack.CP1.y + 3*(1-tS1)*tS1*tS1*inferiorBezierBack.CP2.y + tS1*tS1*tS1*inferiorBezierBack.EP.y;
			sq1b.x = (1-tS1)*(1-tS1)*(1-tS1)*inferiorBezierBack.SP.x + 3*(1-tS1)*(1-tS1)*tS1*inferiorBezierBack.CP1.x + 3*(1-tS1)*tS1*tS1*inferiorBezierBack.CP2.x + tS1*tS1*tS1*inferiorBezierBack.EP.x;

			var sP12b = new ED.Point(0,0);
			sP12b.x = inferiorBezierBack.SP.x + tS1 * (inferiorBezierBack.CP1.x - inferiorBezierBack.SP.x);
			sP12b.y = inferiorBezierBack.SP.y + tS1 * (inferiorBezierBack.CP1.y - inferiorBezierBack.SP.y);
			
			var sP23b = new ED.Point(0,0);
			sP23b.x = inferiorBezierBack.CP1.x + tS1 * (inferiorBezierBack.CP2.x - inferiorBezierBack.CP1.x);
			sP23b.y = inferiorBezierBack.CP1.y + tS1 * (inferiorBezierBack.CP2.y - inferiorBezierBack.CP1.y);
			
			var sP1223b = new ED.Point(0,0);
			sP1223b.x = sP12b.x + tS1 * (sP23b.x - sP12b.x);
			sP1223b.y = sP12b.y + tS1 * (sP23b.y - sP12b.y);

			inferiorBezierBack.CP1 = sP12b;
			inferiorBezierBack.CP2 = sP1223b;
			inferiorBezierBack.EP = sq1b;
		}
	}
	
	// Get relative lens position to draw around
	var lens = this.drawing.lastDoodleOfClass('LensCrossSection');
	var iris = this.drawing.lastDoodleOfClass('AntSegCrossSection');
	
	var marginX = (iris) ? iris.apexX: -20;

	if (lens) {
		// Displacement of lens from centre
		var ld = 100;
	
		// Angle of arc or lens
		var theta = Math.asin(240 / 300);
	
		// X coordinate of centre of lens arc
		var x = 300 * Math.cos(theta);
		
		if (iris) {
			if (lens.originX + ld + x - 300 - this.originX < iris.apexX) marginX = lens.originX + ld + x - 300 - this.originX;
		}
		else marginX = lens.originX + ld + x - 300 - this.originX;
	}

	// Draw it
	if (inferiorBezierBack) {
		ctx.moveTo(inferiorBezierBack.EP.x, inferiorBezierBack.EP.y);
		ctx.bezierCurveTo(inferiorBezierBack.CP2.x, inferiorBezierBack.CP2.y, inferiorBezierBack.CP1.x, inferiorBezierBack.CP1.y, inferiorBezierBack.SP.x, inferiorBezierBack.SP.y);
	}
	if (superiorBezierBack) {
		ctx.bezierCurveTo(superiorBezierBack.CP2.x, superiorBezierBack.CP2.y, superiorBezierBack.CP1.x, superiorBezierBack.CP1.y, superiorBezierBack.SP.x, superiorBezierBack.SP.y);
		if (!iris) ctx.lineTo(marginX, superiorBezierBack.SP.y);
		else {
			var x1 = (marginX < superiorBezierBack.SP.x) ? superiorBezierBack.SP.x : marginX;
			ctx.lineTo(x1, superiorBezierBack.SP.y);
			if (this.apexY < iris.apexY - 20) {
				ctx.lineTo(iris.apexX, iris.apexY  - 20);
				ctx.lineTo(marginX, iris.apexY  - 20);
			}
		}
	}
	
	if (!iris) {
		ctx.lineTo(marginX, inferiorBezierBack.SP.y);
		ctx.lineTo(40, 460);
	}
	else {
		var x2 = (marginX < inferiorBezierBack.SP.x) ? inferiorBezierBack.SP.x : marginX;
		ctx.lineTo(x2, inferiorBezierBack.SP.y);
		if (this.apexY < -iris.apexY + 20) {
			ctx.lineTo(marginX, -iris.apexY + 20);
			ctx.lineTo(iris.apexX, -iris.apexY + 20);
		}
		ctx.lineTo(40, 460);
	}
	
	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 5;
	// Colour of fill, density depends on setting of apexX
	var density = (0.1 + (this.apexX + 50) / 111).toFixed(2);
	ctx.fillStyle = "rgba(255,0,0," + density + ")";
	ctx.strokeStyle = ctx.fillStyle;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
		
	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		
	}
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
	
}



/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Hypopyon
 *
 * @class Hypopyon
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Hypopyon = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Hypopyon";

	// Private parameters
	this.ro = 380;
	this.minimum = 304;
	this.csOriginX = 50;
	// Saved parameters
	this.savedParameterArray = ['apexY', 'csOriginX'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

    this.linkedDoodleParameters = {
        'Hyphaema': {
            source: ['apexY'],
            store: [['originY', 'csOriginY'], ['apexX', 'csApexX'], ['originX', 'csOriginX']]
        }
    };
}

/**
 * Sets superclass and constructor
 */
ED.Hypopyon.prototype = new ED.Doodle;
ED.Hypopyon.prototype.constructor = ED.Hypopyon;
ED.Hypopyon.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Hypopyon.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.Hypopyon.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-380, this.minimum);
}

/**
 * Sets default parameters
 */
ED.Hypopyon.prototype.setParameterDefaults = function() {
	this.apexY = 260;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Hypopyon.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Hypopyon.superclass.draw.call(this, _point);

	// Calculate angle of apex above or below horizontal
	var phi = Math.asin(this.apexY / this.ro);

	// Boundary path
	ctx.beginPath();

	// Arc from point on circumference level with apex point to other side
	ctx.arc(0, 0, this.ro, phi, Math.PI - phi, false);

	// Close path
	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = "rgba(221,209,171,1)";

	// Set line attributes
	ctx.lineWidth = 1;

	// Colour of outer line
	ctx.strokeStyle = ctx.fillStyle;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Hypopyon.prototype.description = function() {
	var height = Math.round(10 * (this.ro - this.apexY) / (2 * this.ro));
	return height + "mm hypopyon";
}

/**
 * OpenEyes
 * MSC
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * MSC TODO: (1) Calculate t instead of current estimation based on time so level with apexY
 *           (2) Calculate x coordinate of stop positon if within inf / sup zonules 
 *
 * @class HypopyonCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.HypopyonCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "HypopyonCrossSection";

	// Private parameters
	this.initialRadius = 360;
	
	// Derived parameters
	this.ro = 380;
	this.minimum = 304;
	
	// Saved parameters
	this.savedParameterArray = ['apexY', 'originX'];
	
	// Parameters in doodle control bar
	this.controlParameterArray = {};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

    this.linkedDoodleParameters = {
        'Hypopyon': {
            source: ['apexY'],
            store: [['originX', 'csOriginX']]
        }
    };
}

/**
 * Sets superclass and constructor
 */
ED.HypopyonCrossSection.prototype = new ED.Doodle;
ED.HypopyonCrossSection.prototype.constructor = ED.HypopyonCrossSection;
ED.HypopyonCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.HypopyonCrossSection.prototype.setHandles = function() {
}

/**
 * Sets default properties
 */
ED.HypopyonCrossSection.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
	this.addAtBack = true;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-380, this.minimum);

}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.HypopyonCrossSection.prototype.dependentParameterValues = function(_parameter, _value) {
}

/**
 * Sets default parameters
 */
ED.HypopyonCrossSection.prototype.setParameterDefaults = function() {
	this.originX = 50; // as is in Cornea cross section doodle to dulicate bezier control points
	
	this.apexY = 260;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.HypopyonCrossSection.prototype.draw = function(_point) {
	
	// Get context
	var ctx = this.drawing.context;

	var cornea = this.drawing.lastDoodleOfClass('CorneaCrossSection');
	var cornealThickness = cornea.pachymetry/5;

	// Call draw method in superclass
	ED.HypopyonCrossSection.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();
	
	// Calculate segment extent in terms of time along curve
	var startY = this.apexY - this.apexY/12; //buffer needed as only estimating t
	var startT = (startY + 380) / 760;
	if (startT<0) startT = 0;
	var endT = 1;
		
	if (startT < 0.5) {
		
		var superiorBezierBack = new Object;

		// define start and end time points
		var tI0 = startT * 2;
		var tI1 = (endT < 0.5) ? endT * 2 : 1;
		
		// default bezier points (as in cornea cross section)
		if (cornea && cornea.shape == "Keratoconus") {
			superiorBezierBack.SP = new ED.Point(-120 + 120, -380 - this.originY);
			superiorBezierBack.CP1 = new ED.Point(-240 + 160, -260 - this.originY);
			superiorBezierBack.CP2 = new ED.Point(cornea.apexX + cornealThickness, cornea.apexY - 120 - this.originY);
			superiorBezierBack.EP = new ED.Point(cornea.apexX + cornealThickness, cornea.apexY - this.originY);
		}
		else if (cornea && cornea.shape == "Keratoglobus") {
			superiorBezierBack.SP = new ED.Point(-120 + 120, -380 - this.originY);
			superiorBezierBack.CP1 = new ED.Point(-240 + 120, -200 - this.originY);
			superiorBezierBack.CP2 = new ED.Point(-380 + 100, -140 - this.originY);
			superiorBezierBack.EP = new ED.Point(-380 + 100, 100 - this.originY);
		}
		else {
			superiorBezierBack.SP = new ED.Point(-120 + 120, -380 - this.originY);
			superiorBezierBack.CP1 = new ED.Point(-240 + 160, -260 - this.originY);
			superiorBezierBack.CP2 = new ED.Point(-320 + 100, -160 - this.originY);
			superiorBezierBack.EP = new ED.Point(-320 + 100, 0 - this.originY);
		}
		
			
		if (tI0 > 0) {
		// Trim start of curve			
			var sq0b = new ED.Point(0,0);
			sq0b.y = (1-tI0)*(1-tI0)*(1-tI0)*superiorBezierBack.SP.y + 3*(1-tI0)*(1-tI0)*tI0*superiorBezierBack.CP1.y + 3*(1-tI0)*tI0*tI0*superiorBezierBack.CP2.y + tI0*tI0*tI0*superiorBezierBack.EP.y;
			sq0b.x = (1-tI0)*(1-tI0)*(1-tI0)*superiorBezierBack.SP.x + 3*(1-tI0)*(1-tI0)*tI0*superiorBezierBack.CP1.x + 3*(1-tI0)*tI0*tI0*superiorBezierBack.CP2.x + tI0*tI0*tI0*superiorBezierBack.EP.x;
			
			var iP23b = new ED.Point(0,0);
			iP23b.x = superiorBezierBack.CP1.x + tI0 * (superiorBezierBack.CP2.x - superiorBezierBack.CP1.x);
			iP23b.y = superiorBezierBack.CP1.y + tI0 * (superiorBezierBack.CP2.y - superiorBezierBack.CP1.y);
			
			var iP34b = new ED.Point(0,0);
			iP34b.x = superiorBezierBack.CP2.x + tI0 * (superiorBezierBack.EP.x - superiorBezierBack.CP2.x);
			iP34b.y = superiorBezierBack.CP2.y + tI0 * (superiorBezierBack.EP.y - superiorBezierBack.CP2.y);
			
			var iP2334b = new ED.Point(0,0);
			iP2334b.x = iP23b.x + tI0 * (iP34b.x - iP23b.x);
			iP2334b.y = iP23b.y + tI0 * (iP34b.y - iP23b.y);
			
			superiorBezierBack.SP = sq0b;
			superiorBezierBack.CP1 = iP2334b;
			superiorBezierBack.CP2 = iP34b;
		}
		
		if (tI1 < 1) {
		// Trim end of curve
			var iq1b = new ED.Point(0,0);
			iq1b.y = (1-tI1)*(1-tI1)*(1-tI1)*superiorBezierBack.SP.y + 3*(1-tI1)*(1-tI1)*tI1*superiorBezierBack.CP1.y + 3*(1-tI1)*tI1*tI1*superiorBezierBack.CP2.y + tI1*tI1*tI1*superiorBezierBack.EP.y;
			iq1b.x = (1-tI1)*(1-tI1)*(1-tI1)*superiorBezierBack.SP.x + 3*(1-tI1)*(1-tI1)*tI1*superiorBezierBack.CP1.x + 3*(1-tI1)*tI1*tI1*superiorBezierBack.CP2.x + tI1*tI1*tI1*superiorBezierBack.EP.x;

			var iP12b = new ED.Point(0,0);
			iP12b.x = superiorBezierBack.SP.x + tI1 * (superiorBezierBack.CP1.x - superiorBezierBack.SP.x);
			iP12b.y = superiorBezierBack.SP.y + tI1 * (superiorBezierBack.CP1.y - superiorBezierBack.SP.y);
			
			var iP23b = new ED.Point(0,0);
			iP23b.x = superiorBezierBack.CP1.x + tI1 * (superiorBezierBack.CP2.x - superiorBezierBack.CP1.x);
			iP23b.y = superiorBezierBack.CP1.y + tI1 * (superiorBezierBack.CP2.y - superiorBezierBack.CP1.y);
			
			var iP1223b = new ED.Point(0,0);
			iP1223b.x = iP12b.x + tI1 * (iP23b.x - iP12b.x);
			iP1223b.y = iP12b.y + tI1 * (iP23b.y - iP12b.y);
			
			superiorBezierBack.CP1 = iP12b;
			superiorBezierBack.CP2 = iP1223b;
			superiorBezierBack.EP = iq1b;
		}
	}
	
	
	if (endT > 0.5) {
		
		var inferiorBezierBack = new Object;
		
		// define start and end time points
		var tS0 = (startT > 0.5) ? (startT - 0.5) * 2 : 0;
		var tS1 = (endT - 0.5) * 2;
		
		// default bezier points (as in cornea cross section)
		if (cornea && cornea.shape == "Keratoconus") {
			inferiorBezierBack.SP = new ED.Point(cornea.apexX + cornealThickness, cornea.apexY - this.originY);
			inferiorBezierBack.CP1 = new ED.Point(cornea.apexX + cornealThickness, cornea.apexY + 120 - this.originY);
			inferiorBezierBack.CP2 = new ED.Point(-240 + 160, 260 - this.originY);
			inferiorBezierBack.EP = new ED.Point(-120 + 120, 380 - this.originY);
		}
		else if (cornea && cornea.shape == "Keratoglobus") {
			inferiorBezierBack.SP = new ED.Point(-380 + 100, 100 - this.originY);
			inferiorBezierBack.CP1 = new ED.Point(-380 + 120, 220 - this.originY);
			inferiorBezierBack.CP2 = new ED.Point(-240 + 160, 260 - this.originY);
			inferiorBezierBack.EP = new ED.Point(-120 + 120, 380 - this.originY);
		}
		else {
			inferiorBezierBack.SP = new ED.Point(-320 + 100, -0 - this.originY);
			inferiorBezierBack.CP1 = new ED.Point(-320 + 100, 160 - this.originY);
			inferiorBezierBack.CP2 = new ED.Point(-240 + 160, 260 - this.originY);
			inferiorBezierBack.EP = new ED.Point(-120 + 120, 380 - this.originY);
		}			
		
		
		if (tS0 > 0) {
		// Trim start of curve
			var sq0b = new ED.Point(0,0);
			sq0b.y = (1-tS0)*(1-tS0)*(1-tS0)*inferiorBezierBack.SP.y + 3*(1-tS0)*(1-tS0)*tS0*inferiorBezierBack.CP1.y + 3*(1-tS0)*tS0*tS0*inferiorBezierBack.CP2.y + tS0*tS0*tS0*inferiorBezierBack.EP.y;
			sq0b.x = (1-tS0)*(1-tS0)*(1-tS0)*inferiorBezierBack.SP.x + 3*(1-tS0)*(1-tS0)*tS0*inferiorBezierBack.CP1.x + 3*(1-tS0)*tS0*tS0*inferiorBezierBack.CP2.x + tS0*tS0*tS0*inferiorBezierBack.EP.x;
			
			var sP23b = new ED.Point(0,0);
			sP23b.x = inferiorBezierBack.CP1.x + tS0 * (inferiorBezierBack.CP2.x - inferiorBezierBack.CP1.x);
			sP23b.y = inferiorBezierBack.CP1.y + tS0 * (inferiorBezierBack.CP2.y - inferiorBezierBack.CP1.y);
			
			var sP34b = new ED.Point(0,0);
			sP34b.x = inferiorBezierBack.CP2.x + tS0 * (inferiorBezierBack.EP.x - inferiorBezierBack.CP2.x);
			sP34b.y = inferiorBezierBack.CP2.y + tS0 * (inferiorBezierBack.EP.y - inferiorBezierBack.CP2.y);
			
			var sP2334b = new ED.Point(0,0);
			sP2334b.x = sP23b.x + tS0 * (sP34b.x - sP23b.x);
			sP2334b.y = sP23b.y + tS0 * (sP34b.y - sP23b.y);
			
			inferiorBezierBack.SP = sq0b;
			inferiorBezierBack.CP1 = sP2334b;
			inferiorBezierBack.CP2 = sP34b;
		}
		
		if (tS1 < 1) {
		// Trim end of curve
			var sq1b = new ED.Point(0,0);
			sq1b.y = (1-tS1)*(1-tS1)*(1-tS1)*inferiorBezierBack.SP.y + 3*(1-tS1)*(1-tS1)*tS1*inferiorBezierBack.CP1.y + 3*(1-tS1)*tS1*tS1*inferiorBezierBack.CP2.y + tS1*tS1*tS1*inferiorBezierBack.EP.y;
			sq1b.x = (1-tS1)*(1-tS1)*(1-tS1)*inferiorBezierBack.SP.x + 3*(1-tS1)*(1-tS1)*tS1*inferiorBezierBack.CP1.x + 3*(1-tS1)*tS1*tS1*inferiorBezierBack.CP2.x + tS1*tS1*tS1*inferiorBezierBack.EP.x;

			var sP12b = new ED.Point(0,0);
			sP12b.x = inferiorBezierBack.SP.x + tS1 * (inferiorBezierBack.CP1.x - inferiorBezierBack.SP.x);
			sP12b.y = inferiorBezierBack.SP.y + tS1 * (inferiorBezierBack.CP1.y - inferiorBezierBack.SP.y);
			
			var sP23b = new ED.Point(0,0);
			sP23b.x = inferiorBezierBack.CP1.x + tS1 * (inferiorBezierBack.CP2.x - inferiorBezierBack.CP1.x);
			sP23b.y = inferiorBezierBack.CP1.y + tS1 * (inferiorBezierBack.CP2.y - inferiorBezierBack.CP1.y);
			
			var sP1223b = new ED.Point(0,0);
			sP1223b.x = sP12b.x + tS1 * (sP23b.x - sP12b.x);
			sP1223b.y = sP12b.y + tS1 * (sP23b.y - sP12b.y);

			inferiorBezierBack.CP1 = sP12b;
			inferiorBezierBack.CP2 = sP1223b;
			inferiorBezierBack.EP = sq1b;
		}
	}
	
	// Get relative lens position to draw around
	var lens = this.drawing.lastDoodleOfClass('LensCrossSection');
	var iris = this.drawing.lastDoodleOfClass('AntSegCrossSection');
	var cornea = this.drawing.lastDoodleOfClass('CorneaCrossSection');

	var marginX = (iris) ? iris.apexX: -20;

  if (cornea) {
  	this.setSimpleParameter('originX', cornea.originX);
  }

	if (lens) {
		// Displacement of lens from centre
		var ld = 100;
	
		// Angle of arc or lens
		var theta = Math.asin(240 / 300);
	
		// X coordinate of centre of lens arc
		var x = 300 * Math.cos(theta);
		
		if (lens.originX + ld + x - 300 - this.originX < iris.apexX) marginX = lens.originX + ld + x - 300 - this.originX;
	}

/*
	var lens = this.drawing.lastDoodleOfClass('LensCrossSection');
	if (lens) {
		// angle from lens arc centre to edge
		var theta = Math.asin(207 / 300);
		
		// angle from lens arc centre to y=apexY on lens arc
		var phi = (-this.apexY + lens.originY) / 300; 
		if (phi < 0) phi = 0;
				
		// if apex above top of lens capsule
		if (phi>theta) {
			phi = theta;
			
			var sp = new ED.Point(74, -349);
			var ep = new ED.Point(14 + lens.originX, -207 + lens.originY);
			var supZonule = sp;
			
			// but within zonules
			if (this.apexY > sp.y) {
				var angle = Math.atan(Math.abs((sp.y - ep.y)/(sp.x - ep.x)));
				var o = Math.abs(ep.y - this.apexY);
				var a = o / Math.tan(angle);
				
// 				supZonule.x += a;
				supZonule.y = (this.apexY < sp.y) ? sp.y : this.apexY;
			}
		}
		
		// if apex within lens capsule
		var pho = (this.apexY > lens.originY) ? (-this.apexY + lens.originY) / 300 + Math.PI : Math.PI;
		
		// if apex below lens capsule
		var infZonule = new ED.Point(14 + lens.originX, 207 + lens.originY);
		if (pho < Math.PI - theta) {
			infZonule.y = this.apexY;
		}

	}
*/

	// Draw it
	if (inferiorBezierBack) {
		ctx.moveTo(inferiorBezierBack.EP.x, inferiorBezierBack.EP.y);
		ctx.bezierCurveTo(inferiorBezierBack.CP2.x, inferiorBezierBack.CP2.y, inferiorBezierBack.CP1.x, inferiorBezierBack.CP1.y, inferiorBezierBack.SP.x, inferiorBezierBack.SP.y);
	}
	if (superiorBezierBack) {
		ctx.bezierCurveTo(superiorBezierBack.CP2.x, superiorBezierBack.CP2.y, superiorBezierBack.CP1.x, superiorBezierBack.CP1.y, superiorBezierBack.SP.x, superiorBezierBack.SP.y);
		if (!iris) ctx.lineTo(marginX, superiorBezierBack.SP.y);
		else {
			var x1 = (marginX < superiorBezierBack.SP.x) ? superiorBezierBack.SP.x : marginX;
// 			if (x1 < iris.apexX - 40) x1 = iris.apexX - 40;
			ctx.lineTo(x1, superiorBezierBack.SP.y);
			if (this.apexY < iris.apexY) {
				if (x1 > iris.apexX) x1 = iris.apexX;
				ctx.lineTo(x1, iris.apexY);
				ctx.lineTo(iris.apexX, iris.apexY);

			}

// 			if (this.apexY < iris.apexY) ctx.lineTo(iris.apexX, iris.apexY);
// 			else ctx.lineTo()
		}
	}
	
	if (!iris) {
		ctx.lineTo(marginX, inferiorBezierBack.SP.y);
		ctx.lineTo(40, 460);
	}
	else {
		var x2 = (marginX < inferiorBezierBack.SP.x) ? inferiorBezierBack.SP.x : marginX;
		if (x2 > iris.apexX) x2 = iris.apexX;
		ctx.lineTo(x2, inferiorBezierBack.SP.y);
		if (this.apexY < -iris.apexY) {
			if (x2 < iris.apexX) x2 = iris.apexX;
			ctx.lineTo(x2, -iris.apexY);
			ctx.lineTo(iris.apexX, -iris.apexY);
		}
		ctx.lineTo(40, 460);
	}
	
/*
	if (!lens) {
		ctx.lineTo(120, inferiorBezierBack.SP.y);
		ctx.lineTo(120, 450);
	}
	
	else { // draw around lens capsule
		
		// top zonules
		if (phi == theta) {
			ctx.lineTo(supZonule.x, this.apexY);
			ctx.lineTo(14 + lens.originX, -207 + lens.originY);
		}
		// top half of lens capsule
		if (this.apexY < lens.originY) ctx.arc(lens.originX + 225, lens.originY, 300, Math.PI + phi, Math.PI, true);
		
		// bottom half of lens capsule
		if (pho > Math.PI - theta) ctx.arc(lens.originX + 225, lens.originY, 300, pho, Math.PI - theta, true);
		
		// bottom zonules
		ctx.lineTo(infZonule.x, infZonule.y);
		ctx.lineTo(74, 349);
		ctx.lineTo(120, 450);
	}
*/
	
	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 5;
	ctx.fillStyle = "rgba(221,209,171,1)";
	ctx.strokeStyle = ctx.fillStyle;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
		
	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		
	}
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
	
}



/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Iatrogenic break
 *
 * @class IatrogenicBreak
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.IatrogenicBreak = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "IatrogenicBreak";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.IatrogenicBreak.prototype = new ED.Doodle;
ED.IatrogenicBreak.prototype.constructor = ED.IatrogenicBreak;
ED.IatrogenicBreak.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.IatrogenicBreak.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, true);
}

/**
 * Sets default properties
 */
ED.IatrogenicBreak.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(0.8, 2);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(0.8, 2);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.IatrogenicBreak.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(240, -50);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.IatrogenicBreak.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.IatrogenicBreak.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Oval break
	var d = 40;
	var p = 0.8;
	var sp = new ED.Point(-d, d);
	var ep = new ED.Point(d, -d);

	// Oval shape
	ctx.moveTo(sp.x, sp.y);
	ctx.bezierCurveTo(sp.x, sp.y - p * d, ep.x - p * d, ep.y, ep.x, ep.y);
	ctx.bezierCurveTo(ep.x, ep.y + p * d, sp.x + p * d, sp.y, sp.x, sp.y);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "red";
	ctx.strokeStyle = "blue";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(ep);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.IatrogenicBreak.prototype.description = function() {
	return "Iatrogenic break in " + this.quadrant();
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Posterior chamber ICL
 *
 * @class ICL
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ICL = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ICL";
	
	// Derived parameters
	this.axis = "";
	
	// Other parameters
	this.model = "";
	this.lengthICL = "";
	this.sphere;
	this.cylinder;
	this.opticalAxis;
	
	// Saved parameters
	this.savedParameterArray = [
		'originX',
		'originY', 
		'scaleX', 
		'scaleY', 
		'rotation',
		'axis',
		'model',
		'lengthICL',
		'sphere',
		'cylinder',
		'opticalAxis'
		];
	
	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {
		'model':'Model',
		'lengthICL':'Length (mm)',
		'sphere':'Sphere (D)',
		'cylinder':'Cylinder (D)',
		'opticalAxis':'Axis (deg)'
	};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.ICL.prototype = new ED.Doodle;
ED.ICL.prototype.constructor = ED.ICL;
ED.ICL.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.ICL.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, true);
}

/**
 * Sets default properties
 */
ED.ICL.prototype.setPropertyDefaults = function() {
	this.addAtBack = true;
	this.isUnique = true;
	this.isMoveable = false;

	// Adjust ranges for simple parameters
	this.parameterValidationArray['rotation']['range'] = new ED.Range(340 * Math.PI / 180, 20 * Math.PI/180);
	//this.parameterValidationArray['rotation']['range'] = new ED.Range(0.888 * Math.PI/180, 1.11 * Math.PI);
	
	// Derived parameters (NB cannot use numerical approach to this axis since 'double' range not currently handled in core)
	this.parameterValidationArray['axis'] = {
		kind: 'derived',
		type: 'string',
		list: [
			'160', '161', '162', '163', '164', '165', '166', '167', '168', '169',
			'170', '171', '172', '173', '174', '175', '176', '177', '178', '179', 
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
			'10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20'],
		animate: false
	};
	
	// Other parameters
	this.parameterValidationArray['model'] = {
		kind: 'other',
		type: 'string',
		list: ['V4b', 'V4c'],
		animate: false
	};
	this.parameterValidationArray['lengthICL'] = {
		kind: 'other',
		type: 'string',
		list: ['11.7','12.2','12.7','13.2','13.7'],
		animate: false
	};
	this.parameterValidationArray['sphere'] = {
		kind: 'other',
		type: 'string',
		list: ['-18.0','-17.5','-17.0','-16.5','-16.0','-15.5','-15.0','-14.5','-14.0','-13.5','-13.0','-12.5','-12.0','-11.5','-11.0','-10.5','-10.0','-9.5','-9.0','-8.5','-8.0','-7.5','-7.0','-6.5','-6.0','-5.5','-5.0','-4.5','-4.0','-3.5','-3.0','-2.5','-2.0','-1.5','-1.0','-0.5',' 0.0','+0.5','+1.0','+1.5','+2.0','+2.5','+3.0','+3.5','+4.0','+4.5','+5.0','+5.5','+6.0','+6.5','+7.0','+7.5','+8.0'],
		animate: false
	};
	this.parameterValidationArray['cylinder'] = {
		kind: 'other',
		type: 'string',
		list: [' 0.0','+0.5','+1.0','+1.5','+2.0','+2.5','+3.0','+3.5','+4.0','+4.5','+5.0','+5.5','+6.0'],
		animate: false
	};
	this.parameterValidationArray['opticalAxis'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(+0, +180),
		animate: false
	};
}

/**
 * Sets default parameters
 */
ED.ICL.prototype.setParameterDefaults = function() {
	this.setParameterFromString('axis', '180');
	this.setParameterFromString('model', 'V4c');
	this.setParameterFromString('lengthICL', '13.2');
	this.setParameterFromString('sphere', '0.0');
	this.setParameterFromString('cylinder', '0.0');
	this.setParameterFromString('opticalAxis', '0');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.ICL.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'rotation':
			var axis = ((360 - 180 * _value / Math.PI) % 180).toFixed(0);
			if (axis == '180') axis = '0';
			returnArray['axis'] = axis;
			break;

// 		case 'axis':
// 			returnArray['rotation'] = (180 - parseFloat(_value)) * Math.PI / 180;
// 			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ICL.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ICL.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Radius (used here to set handle location)
	//var r = 280;
	var r = 170;
	
	// Optic
	ctx.moveTo(0, -218);
	ctx.bezierCurveTo(46, -217, 64, -203, 105, -201);
	ctx.bezierCurveTo(146, -199, 190, -190, 221, -190);
	ctx.bezierCurveTo(230, -190, 222, -198, 237, -197);
	ctx.bezierCurveTo(264, -196, 305, -207, 321, -176);
	ctx.bezierCurveTo(334, -149, 314, -143, 306, -118);
	ctx.bezierCurveTo(300, -60, 300, 60, 306, 118);
	ctx.bezierCurveTo(314, 143, 334, 149, 321, 176);
	ctx.bezierCurveTo(305, 207, 264, 196, 237, 197);
	ctx.bezierCurveTo(222, 198, 230, 190, 221, 190);
	ctx.bezierCurveTo(190, 190, 146, 199, 105, 201);
	ctx.bezierCurveTo(64, 203, 46, 217, 0, 218);
	ctx.bezierCurveTo(-46, 217, -64, 203, -105, 201)
	ctx.bezierCurveTo(-146, 199, -190, 190, -221, 190);
	ctx.bezierCurveTo(-230, 190, -222, 198, -237, 197);
	ctx.bezierCurveTo(-264, 196, -305, 207, -321, 176);
	ctx.bezierCurveTo(-334, 149, -314, 143, -306, 118);
	ctx.bezierCurveTo(-300, -60, -300, -60, -306, -118);
	ctx.bezierCurveTo(-314, -143, -334, -149, -321, -176);
	ctx.bezierCurveTo(-305, -207, -264, -196, -237, -197);
	ctx.bezierCurveTo(-222, -198, -230, -190, -221, -190);
	ctx.bezierCurveTo(-190, -190, -146, -199, -105, -201);
	ctx.bezierCurveTo(-64, -203, -46, -217, 0, -218);

	// Colour of fill is white but with transparency
	ctx.fillStyle = "rgba(255,255,255,0.75)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "darkgray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Curves near haptics
		ctx.beginPath();
		ctx.moveTo(-218, -192);
		ctx.bezierCurveTo(-228, -177, -279, -113, -279, 0);
		ctx.bezierCurveTo(-279, 113, -228, 177, -218, 192);
		ctx.moveTo(218, -192);
		ctx.bezierCurveTo(228, -177, 279, -113, 279, 0);
		ctx.bezierCurveTo(279, 113, 228, 177, 218, 192);
		ctx.stroke();
		
		// Central lenticule
		this.drawCircle(ctx, 0, 0, 170, "rgba(0,0,0,0)", 4, ctx.strokeStyle);
		
		// Spots
		this.drawCircle(ctx, -200, 0, 8, ctx.fillStyle, 4, ctx.strokeStyle);
		this.drawCircle(ctx, 200, 0, 8, ctx.fillStyle, 4, ctx.strokeStyle);
		this.drawCircle(ctx, -280, -160, 8, ctx.fillStyle, 4, ctx.strokeStyle);
		this.drawCircle(ctx, 280, 160, 8, ctx.fillStyle, 4, ctx.strokeStyle);
		if (this.model == 'V4c') {
			this.drawCircle(ctx, 0, 0, 8, ctx.fillStyle, 4, ctx.strokeStyle);
		}
		
		// Optical axis
		var ra = 40;
		var rb = 140;
		var phi = Math.PI/2 - this.opticalAxis * Math.PI/180;
		var theta = phi + Math.PI;
		var p = new ED.Point(0,0);
		
		ctx.beginPath();
		p.setWithPolars(ra, phi);
		ctx.moveTo(p.x, p.y);
		p.setWithPolars(rb, phi);
		ctx.lineTo(p.x, p.y);
		
		p.setWithPolars(ra, theta);
		ctx.moveTo(p.x, p.y);
		p.setWithPolars(rb, theta);
		ctx.lineTo(p.x, p.y);
		
		ctx.stroke();
	}

	/*
	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0)
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);
	*/
	
	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ICL.prototype.description = function() {
	var returnValue = "Implantable Collamer Lens";

	return returnValue;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * ILM peel
 *
 * @class ILMPeel ***TODO***
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ILMPeel = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ILMPeel";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexX', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.ILMPeel.prototype = new ED.Doodle;
ED.ILMPeel.prototype.constructor = ED.ILMPeel;
ED.ILMPeel.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.ILMPeel.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.ILMPeel.prototype.setPropertyDefaults = function() {
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-80, -40);
}

/**
 * Sets default parameters
 */
ED.ILMPeel.prototype.setParameterDefaults = function() {
	this.apexY = -60;
	this.rotation = Math.PI / 4;

	this.originX = this.drawing.eye == ED.eye.Right ? -100 : 100;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ILMPeel.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ILMPeel.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Circular scar
	var r = Math.sqrt(this.apexX * this.apexX + this.apexY * this.apexY);

	// Circular scar
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set line attributes
	ctx.lineWidth = 2;
	ctx.fillStyle = "rgba(220, 220, 220, 0.5)";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ILMPeel.prototype.groupDescription = function() {
	return "ILM peel";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Chandelier (single)
 *
 * @class InjectionSite
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.InjectionSite = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "InjectionSite";

	// Private parameters
	this.parsPlana = -560;

	// Derived parameters
	this.distance = '3.5';

	// Saved parameters
	this.savedParameterArray = ['apexY', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.InjectionSite.prototype = new ED.Doodle;
ED.InjectionSite.prototype.constructor = ED.InjectionSite;
ED.InjectionSite.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.InjectionSite.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.InjectionSite.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-550, -470);

	this.parameterValidationArray['distance'] = {
		kind: 'derived',
		type: 'string',
		list: ['4.5', '4.0', '3.5', '3.0', '2.5'],
		animate: false
	};
}

/**
 * Sets default parameters
 */
ED.InjectionSite.prototype.setParameterDefaults = function() {
	this.apexY = -510;
	this.distance = '3.5';
	this.setRotationWithDisplacements(45, 30);
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.InjectionSite.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			if (_value < -540) returnArray['distance'] = '4.5';
			else if (_value < -520) returnArray['distance'] = '4.0';
			else if (_value < -500) returnArray['distance'] = '3.5';
			else if (_value < -480) returnArray['distance'] = '3.0';
			else returnArray['distance'] = '2.5';
			break;

		case 'distance':
			if (_value == '4.5') returnArray['apexY'] = -550;
			else if (_value == '4.0') returnArray['apexY'] = -530;
			else if (_value == '3.5') returnArray['apexY'] = -510;
			else if (_value == '3.0') returnArray['apexY'] = -490;
			else returnArray['apexY'] = -470;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.InjectionSite.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.InjectionSite.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Hub
	var y = this.parsPlana - 300;
	ctx.moveTo(-80, y);
	ctx.lineTo(80, y);
	ctx.lineTo(70, y + 30);
	ctx.lineTo(50, y + 240);
	ctx.lineTo(20, y + 260);
	ctx.lineTo(-20, y + 260);
	ctx.lineTo(-50, y + 240);
	ctx.lineTo(-70, y + 30);
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgba(0, 0, 0, 1)";

	ctx.fillStyle = "rgba(255, 255, 0, 1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {

		// Hub top
		ctx.beginPath();
		ctx.moveTo(-70, y + 30);
		ctx.lineTo(70, y + 30);
		ctx.lineWidth = 1;
		ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
		ctx.stroke();

		// Ridge
		ctx.beginPath();
		ctx.moveTo(-60, y + 130);
		ctx.lineTo(60, y + 130);
		ctx.lineWidth = 1;
		ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
		ctx.stroke();

		// Flange
		ctx.beginPath();
		ctx.moveTo(0, y + 130);
		ctx.lineTo(0, y + 230);
		ctx.lineWidth = 32;
		ctx.strokeStyle = "rgba(120, 120, 120, 0.2)";
		ctx.stroke();

		// White bit
		ctx.beginPath();
		ctx.moveTo(50, y + 240);
		ctx.lineTo(20, y + 260);
		ctx.lineTo(-20, y + 260);
		ctx.lineTo(-50, y + 240);
		ctx.closePath();
		ctx.lineWidth = 1;
		ctx.fillStyle = "rgba(255, 255, 255, 1)";
		ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
		ctx.fill();
		ctx.stroke();

		// Visible needle
		ctx.beginPath();
		ctx.moveTo(-10, y + 260);
		ctx.lineTo(+10, y + 260);
		ctx.lineTo(+10, this.apexY);
		ctx.lineTo(-10, this.apexY);
		ctx.closePath();
		ctx.fillStyle = "rgba(120, 120, 120, 1)";
		ctx.fill();

		// Hidden needle
		ctx.beginPath();
		ctx.moveTo(-10, this.apexY);
		ctx.lineTo(+10, this.apexY);
		ctx.lineTo(+10, -130);
		ctx.lineTo(-10, -100);
		ctx.closePath();
		ctx.lineWidth = 1;
		ctx.strokeStyle = "rgba(60, 60, 60, 1)";
		ctx.stroke();

		// Get apex point in canvas coordinates
		var ap = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

		// Save context and reset
		ctx.save();
      	ctx.setTransform(1, 0, 0, 1, 0, 0);

		// Draw label to right and up from apex point
		ctx.lineWidth = 1;
		ctx.fillStyle = "gray";
		ctx.font = "18px sans-serif";
		ctx.fillText(this.distance + ' mm', ap.x + 10, ap.y - 5);

		// Restore context
		ctx.restore();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.InjectionSite.prototype.groupDescription = function() {
	return "Injection at ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.InjectionSite.prototype.description = function() {
	return this.clockHour() + " o'clock " + this.distance + " from limbus";
}

/**
 * OpenEyes
 *
 * (C) OpenEyes Foundation, 2016
 *
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Inner leaf break
 *
 * @class InnerLeafBreak
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.InnerLeafBreak = function(_drawing, _parameterJSON)
{
    // Set classname
    this.className = "InnerLeafBreak";

    this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];
    
    // Call superclass constructor
    ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.InnerLeafBreak.prototype = new ED.Doodle;
ED.InnerLeafBreak.prototype.constructor = ED.InnerLeafBreak;
ED.InnerLeafBreak.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.InnerLeafBreak.prototype.setHandles = function()
{
    this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default dragging attributes
 */
ED.InnerLeafBreak.prototype.setPropertyDefaults = function()
{
    this.isSelectable = true;
    this.isOrientated = false;
    this.isScaleable = true;
    this.isSqueezable = false;
    this.isMoveable = true;
    this.isRotatable = false;
    this.rangeOfScale = new ED.Range(+0.5, +4);
    this.rangeOfArc = new ED.Range(Math.PI/6, Math.PI*2);
    this.rangeOfApexX = new ED.Range(-0, +0);
    this.rangeOfApexY = new ED.Range(-40, +30);
}

/**
 * Sets default parameters
 */
ED.InnerLeafBreak.prototype.setParameterDefaults = function()
{
    this.originX = -326;
    this.originY = 206;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.InnerLeafBreak.prototype.draw = function(_point)
{
    // Get context
    var ctx = this.drawing.context;

    // Call draw method in superclass
    ED.InnerLeafBreak.superclass.draw.call(this, _point);

    // Boundary path
    ctx.beginPath();

    // Round hole
    ctx.arc(0,0,20,0,Math.PI*2,true);

    // Close path
    ctx.closePath();

    // Set line attributes
    ctx.lineWidth = 4;
    ctx.fillStyle = "rgba(255, 80, 80, 0.75)";
    ctx.strokeStyle = "rgba(0, 255, 255, 0.75)";

    // Draw boundary path (also hit testing)
    this.drawBoundary(_point);

    // Other stuff here
    if (this.drawFunctionMode == ED.drawFunctionMode.Draw)
    {
    }

    // Coordinates of handles (in canvas plane)
    this.handleArray[2].location = this.transform.transformPoint(new ED.Point(14, -14));

    // Draw handles if selected
    if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

    // Calculate arc (Arc property not used naturally in this doodle ***TODO** more elegant method of doing this possible!)
    var centre = this.transform.transformPoint(new ED.Point(0,0));
    var oneWidthToRight = this.transform.transformPoint(new ED.Point(60,0));
    var xco = centre.x - this.drawing.canvas.width/2;
    var yco = centre.y - this.drawing.canvas.height/2;
    var radius = this.scaleX * Math.sqrt(xco * xco + yco * yco);
    var width = this.scaleX * (oneWidthToRight.x - centre.x);
    this.arc = Math.atan(width/radius);

    // Return value indicating successful hittest
    return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.InnerLeafBreak.prototype.description = function()
{
    var returnString = "";

    // Size description
    if (this.scaleX < 1) returnString = "Small ";
    if (this.scaleX > 1.5) returnString = "Large ";

    // Round hole
    returnString += "inner leaf break ";

    // Location (clockhours)
    returnString += this.clockHour() + " o'clock";

    return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Posterior chamber IOL
 *
 * @class IOL
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.IOL = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "IOL";

	// Other parameters
	this.type = "PC";
	
	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'rotation', 'type'];
	 
	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'type':'Type'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.IOL.prototype = new ED.Doodle;
ED.IOL.prototype.constructor = ED.IOL;
ED.IOL.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.IOL.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, true);
}

/**
 * Sets default properties
 */
ED.IOL.prototype.setPropertyDefaults = function() {
	this.addAtBack = this.type == 'PC'?true:false;
	this.isUnique = true;
	
	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-125, +125);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-125, +125);
	
	// Validation arrays for derived and other parameters
	this.parameterValidationArray['type'] = {
		kind: 'other',
		type: 'string',
		list: ['PC', 'AC', 'Iris Clip'],
		animate: false
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.IOL.prototype.setParameterDefaults = function() {
	this.setParameterFromString('type', 'PC');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.IOL.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.IOL.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.IOL.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	switch (this.type) {
		case 'PC':
			// Radius of IOL optic
			var r = 180;

			// Draw optic
			ctx.arc(0, 0, r, 0, Math.PI * 2, false);

			// Upper haptic
			ctx.moveTo(112.5, -142.5);
			ctx.bezierCurveTo(120, -150, 142.5, -262.5, 120, -285);
			ctx.bezierCurveTo(67.5, -330, -112.5, -307.5, -165, -277.5);
			ctx.bezierCurveTo(-187.5, -262.5, -195, -300, -150, -322.5);
			ctx.bezierCurveTo(-82.5, -360, 97.5, -352.5, 150, -322.5);
			ctx.bezierCurveTo(202.5, -292.5, 165, -105, 165, -75);
	
			// Lower haptic
			ctx.moveTo(-112.5, 142.5);
			ctx.bezierCurveTo(-120, 150, -142.5, 262.5, -120, 285);
			ctx.bezierCurveTo(-67.5, 330, 112.5, 307.5, 165, 277.5);
			ctx.bezierCurveTo(187.5, 262.5, 195, 300, 150, 322.5);
			ctx.bezierCurveTo(82.5, 360, -97.5, 352.5, -150, 322.5);
			ctx.bezierCurveTo(-202.5, 292.5, -165, 105, -165, 75);
			break;
			
		case 'AC':
			// Radius of IOL optic
			var r = 192;

			// Draw optic
			ctx.arc(0, 0, r, 0, Math.PI * 2, false);

			// Upper haptic
			ctx.moveTo(120, -152);
			ctx.bezierCurveTo(128, -160, 136, -168, 128, -184);
			ctx.bezierCurveTo(120, -200, 80, -224, 40, -232);
			ctx.bezierCurveTo(0, -240, -176, -264, -184, -272);
			ctx.bezierCurveTo(-200, -288, -176, -336, -160, -344);
			ctx.bezierCurveTo(-144, -352, -144, -352, -120, -360);
			ctx.bezierCurveTo(-96, -368, -104, -344, -96, -336);
			ctx.bezierCurveTo(-88, -328, 88, -328, 96, -336);
			ctx.bezierCurveTo(104, -344, 96, -368, 120, -360);
			ctx.bezierCurveTo(144, -352, 144, -352, 160, -344);
			ctx.bezierCurveTo(176, -336, 144, -320, 120, -312);
			ctx.bezierCurveTo(96, -304, -96, -304, -120, -312);
			ctx.bezierCurveTo(-144, -320, -152, -296, -136, -288);
			ctx.bezierCurveTo(-120, -280, 16, -264, 56, -256);
			ctx.bezierCurveTo(96, -248, 152, -224, 168, -200);
			ctx.bezierCurveTo(184, -176, 176, -112, 176, -80);

			// Lower haptic
			ctx.moveTo(-120, 152);
			ctx.bezierCurveTo(-128, 160, -136, 168, -128, 184);
			ctx.bezierCurveTo(-120, 200, -80, 224, -40, 232);
			ctx.bezierCurveTo(0, 240, 176, 264, 184, 272);
			ctx.bezierCurveTo(200, 288, 176, 336, 160, 344);
			ctx.bezierCurveTo(144, 352, 144, 352, 120, 360);
			ctx.bezierCurveTo(96, 368, 104, 344, 96, 336);
			ctx.bezierCurveTo(88, 328, -88, 328, -96, 336);
			ctx.bezierCurveTo(-104, 344, -96, 368, -120, 360);
			ctx.bezierCurveTo(-144, 352, -144, 352, -160, 344);
			ctx.bezierCurveTo(-176, 336, -144, 320, -120, 312);
			ctx.bezierCurveTo(-96, 304, 96, 304, 120, 312);
			ctx.bezierCurveTo(144, 320, 152, 296, 136, 288);
			ctx.bezierCurveTo(120, 280, -16, 264, -56, 256);
			ctx.bezierCurveTo(-96, 248, -152, 224, -168, 200);
			ctx.bezierCurveTo(-184, 176, -176, 112, -176, 80);
			break;
			
		case 'Iris Clip':
			// Radius (used here to set handle location)
			var r = 240;
			
			// Optic
			ctx.moveTo(-260, 0);
			ctx.bezierCurveTo(-260, -100, -220, -220, 0, -220);
			ctx.bezierCurveTo(220, -220, 260, -100, 260, 0);
			ctx.bezierCurveTo(260, 100, 220, 220, 0, 220);
			ctx.bezierCurveTo(-220, 220, -260, 100, -260, 0);

			// Left hand clamp
			ctx.moveTo(-330, -10);
			ctx.bezierCurveTo(-335, -10, -335, -15, -335, -25);
			ctx.bezierCurveTo(-335, -43, -332, -86, -312, -106);
			ctx.bezierCurveTo(-292, -125, -265, -125, -252, -125);
			ctx.bezierCurveTo(-239, -125, -196, -125, -191, -116);
			ctx.bezierCurveTo(-187, -110, -189, -104, -194, -93);
			ctx.bezierCurveTo(-198, -82, -218, -50, -218, 0);
			ctx.bezierCurveTo(-218, 50, -198, 82, -194, 93);
			ctx.bezierCurveTo(-189, 104, -187, 110, -191, 116);
			ctx.bezierCurveTo(-196, 125, -239, 125, -252, 125);
			ctx.bezierCurveTo(-265, 125, -292, 125, -312, 106);
			ctx.bezierCurveTo(-332, 86, -335, 43, -335, 25);
			ctx.bezierCurveTo(-335, 15, -335, 10, -330, 10);
			ctx.bezierCurveTo(-325, 10, -320, 20, -320, 25);
			ctx.bezierCurveTo(-321, 22, -320, 33, -319, 47);
			ctx.bezierCurveTo(-319, 54, -314, 61, -308, 66);
			ctx.bezierCurveTo(-302, 71, -288, 77, -273, 77);
			ctx.bezierCurveTo(-258, 77, -250, 74, -243, 66);
			ctx.bezierCurveTo(-237, 58, -239, 0, -239, 0);
			ctx.bezierCurveTo(-239, 0, -237, -58, -243, -66);
			ctx.bezierCurveTo(-250, -74, -258, -77, -273, -77);
			ctx.bezierCurveTo(-288, -77, -302, -71, -308, -66);
			ctx.bezierCurveTo(-314, -61, -319, -54, -319, -47);
			ctx.bezierCurveTo(-320, -33, -321, -22, -320, -25);
			ctx.bezierCurveTo(-320, -20, -325, -10, -330, -10);

			// Right hand clamp (NB NOT mirror image, since winding affects transparency)
			ctx.moveTo(330, 10);
			ctx.bezierCurveTo(335, 10, 335, 15, 335, 25);
			ctx.bezierCurveTo(335, 43, 332, 86, 312, 106);
			ctx.bezierCurveTo(292, 125, 265, 125, 252, 125);
			ctx.bezierCurveTo(239, 125, 196, 125, 191, 116);
			ctx.bezierCurveTo(187, 110, 189, 104, 194, 93);
			ctx.bezierCurveTo(198, 82, 218, 50, 218, 0);
			ctx.bezierCurveTo(218, -50, 198, -82, 194, -93);
			ctx.bezierCurveTo(189, -104, 187, -110, 191, -116);
			ctx.bezierCurveTo(196, -125, 239, -125, 252, -125);
			ctx.bezierCurveTo(265, -125, 292, -125, 312, -106);
			ctx.bezierCurveTo(332, -86, 335, -43, 335, -25);
			ctx.bezierCurveTo(335, -15, 335, -10, 330, -10);
			ctx.bezierCurveTo(325, -10, 320, -20, 320, -25);
			ctx.bezierCurveTo(321, -22, 314, -61, 319, -47);
			ctx.bezierCurveTo(319, -54, 314, -61, 308, -66);
			ctx.bezierCurveTo(302, -71, 288, -77, 273, -77);
			ctx.bezierCurveTo(258, -77, 250, -74, 243, -66);
			ctx.bezierCurveTo(237, -58, 239, 0, 239, 0);
			ctx.bezierCurveTo(239, 0, 237, 58, 243, 66);
			ctx.bezierCurveTo(250, 74, 258, 77, 273, 77);
			ctx.bezierCurveTo(288, 77, 302, 71, 308, 66);
			ctx.bezierCurveTo(314, 61, 319, 54, 319, 47);
			ctx.bezierCurveTo(320, 33, 321, 22, 320, 25);
			ctx.bezierCurveTo(320, 20, 325, 10, 330, 10);
			break;
	}

	// Colour of fill is white but with transparency
	ctx.fillStyle = "rgba(255,255,255,0.75)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "darkgray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0)
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.IOL.prototype.description = function() {
	var returnValue = "";
	
	switch (this.type) {
		case 'PC':
			returnValue = "Posterior Chamber IOL";
			break;
			
		case 'AC':
			returnValue = "Anterior Chamber IOL";
			break;
			
		case 'Iris Clip':
			returnValue = "Iris clip IOL";
			break;
	}

	// Displacement limit
	var limit = 40;

	var displacementValue = "";

	if (this.originY < -limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += " superiorly";
	}
	if (this.originY > limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += " inferiorly";
	}
	if (this.originX < -limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += (this.drawing.eye == ED.eye.Right) ? " temporally" : " nasally";
	}
	if (this.originX > limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += (this.drawing.eye == ED.eye.Right) ? " nasally" : " temporally";
	}

	// Add displacement description
	if (displacementValue.length > 0) returnValue += " displaced" + displacementValue;

	return returnValue;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * IOL Cross Section ***TODO***
 *
 * @class IOLCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.IOLCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "IOLCrossSection";

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.IOLCrossSection.prototype = new ED.Doodle;
ED.IOLCrossSection.prototype.constructor = ED.IOLCrossSection;
ED.IOLCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.IOLCrossSection.prototype.setPropertyDefaults = function() {
	this.isUnique = true;
	this.addAtBack = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-150, +200);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-140, +140);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.IOLCrossSection.prototype.setParameterDefaults = function() {
	this.originX = 44;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.IOLCrossSection.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.IOLCrossSection.superclass.draw.call(this, _point);

	// Height of cross section (half value of ro in AntSeg doodle)
	var h = 240;

	// Arbitrary radius of curvature
	var r = 420;

	// Displacement of lens from centre
	var ld = 100;

	// Angle of arc
	var theta = Math.asin(h / r);

	// X coordinate of centre of circle
	var x = r * Math.cos(theta);

	// Measurements of nucleus
	var rn = r - 60;

	// Calculate nucleus angles
	var phi = Math.acos(x / rn);

	// Lens
	ctx.beginPath();

	// Draw invisible boundary around lens bag with two sections of circumference of circle
	ctx.arc(ld - x, 0, r, theta, -theta, true);
	ctx.arc(ld + x, 0, r, Math.PI + theta, Math.PI - theta, true);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "rgba(255, 255, 255, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Lens bag
		ctx.beginPath();
		ctx.arc(ld - x, 0, r, theta, -theta, true);
		ctx.arc(ld + x, 0, r, Math.PI + theta, Math.PI + 0.6*theta, true);
		ctx.moveTo(ld, 240);
		ctx.arc(ld + x, 0, r, Math.PI - theta, Math.PI - 0.6*theta, false);
		ctx.strokeStyle = "gray";
		ctx.stroke();

		// Lens
		ctx.beginPath();
		ctx.ellipse(100, 0, 160, 20, 0.5 * Math.PI, 0, 2 * Math.PI);
		ctx.strokeStyle = "rgba(0, 0, 0, 0.7)";
		ctx.lineWidth = 5;
		ctx.stroke();
		
		// Loops
		ctx.beginPath();
// 		ctx.moveTo(80,0);
		ctx.ellipse(100, 0, 227, 20, 0.5 * Math.PI, 0.5 * Math.PI, 1.2 * Math.PI);
		ctx.moveTo(120,0);
		ctx.ellipse(100, 0, 227, 20, 0.5 * Math.PI, 1.5 * Math.PI, 0.2 * Math.PI);
		ctx.strokeStyle = "rgba(0, 0, 0, 0.6)";
		ctx.stroke();
		
		
		// Zonules
		ctx.beginPath();

		// Top zonules
		ctx.moveTo(44 - this.originX + 80, -this.originY - 349);
		ctx.lineTo(80, -207);
		ctx.moveTo(44 - this.originX + 80, -this.originY - 349);
		ctx.lineTo(120, -207);
		ctx.moveTo(44 - this.originX + 120, -this.originY - 349);
		ctx.lineTo(80, -207);
		ctx.moveTo(44 - this.originX + 120, -this.originY - 349);
		ctx.lineTo(120, -207);

		// Bottom zonules
		ctx.moveTo(44 - this.originX + 80, -this.originY + 349);
		ctx.lineTo(80, 207);
		ctx.moveTo(44 - this.originX + 80, -this.originY + 349);
		ctx.lineTo(120, 207);
		ctx.moveTo(44 - this.originX + 120, -this.originY + 349);
		ctx.lineTo(80, 207);
		ctx.moveTo(44 - this.originX + 120, -this.originY + 349);
		ctx.lineTo(120, 207);

		ctx.lineWidth = 2;
		ctx.strokeStyle = "gray";
		ctx.stroke();
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * IrisHook
 *
 * @class IrisHook
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.IrisHook = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "IrisHook";

	// Saved parameters
	this.savedParameterArray = ['rotation']
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.IrisHook.prototype = new ED.Doodle;
ED.IrisHook.prototype.constructor = ED.IrisHook;
ED.IrisHook.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.IrisHook.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isScaleable = false;
}

/**
 * Sets default parameters
 */
ED.IrisHook.prototype.setParameterDefaults = function() {
	this.setRotationWithDisplacements(45, 90);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.IrisHook.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.IrisHook.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Length to inner iris
	var length = 260;

	// If iris there, take account of pupil size
	var doodle = this.drawing.lastDoodleOfClass("AntSeg");
	if (doodle) length = -doodle.apexY;

	ctx.rect(-25, -440, 50, 180 + length);

	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = "rgba(255,255,255,0)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line
	ctx.strokeStyle = "rgba(120,120,120,0.0)";;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Drawing path
		ctx.beginPath();

		// Stem
		ctx.moveTo(10, -430);
		ctx.lineTo(10, -length + 10);
		ctx.lineTo(-10, -length);
		ctx.lineWidth = 12;
		ctx.strokeStyle = "rgba(120,120,120,0.75)";
		ctx.stroke();

		// Stopper
		ctx.beginPath();
		ctx.moveTo(-20, -400);
		ctx.lineTo(+40, -400);
		ctx.lineWidth = 24;
		ctx.strokeStyle = "rgba(255,120,0,0.75)";
		ctx.stroke();
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.IrisHook.prototype.groupDescription = function() {
	return "Iris hooks used at ";
	
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.IrisHook.prototype.description = function() {
	var returnString = "";

	returnString += this.clockHour();

	return returnString;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.IrisHook.prototype.groupDescriptionEnd = function() {
	return " o'clock";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Iris Naevus
 *
 * @class IrisNaevus
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.IrisNaevus = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "IrisNaevus";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.IrisNaevus.prototype = new ED.Doodle;
ED.IrisNaevus.prototype.constructor = ED.IrisNaevus;
ED.IrisNaevus.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.IrisNaevus.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default dragging attributes
 */
ED.IrisNaevus.prototype.setPropertyDefaults = function() {
	this.isSqueezable = true;
	this.isOrientated = true;
}

/**
 * Sets default parameters
 */
ED.IrisNaevus.prototype.setParameterDefaults = function() {
	this.originY = -320;
	this.scaleX = 1.8;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.IrisNaevus.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.IrisNaevus.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// IrisNaevus
	var r = 50;
	ctx.arc(0, 0, r, 0, Math.PI * 2, false);

	// Close path
	ctx.closePath();

	// Create fill
	ctx.fillStyle = "brown";

	// Transparent stroke
	ctx.strokeStyle = "rgba(100,100,100,0.9)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.IrisNaevus.prototype.description = function() {
	return "Iris naevus";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * IRMA
 *
 * @class IRMA
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.IRMA = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "IRMA";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.IRMA.prototype = new ED.Doodle;
ED.IRMA.prototype.constructor = ED.IRMA;
ED.IRMA.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.IRMA.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, true);
}

/**
 * Set default properties
 */
ED.IRMA.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+1, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+1, +1.5);
}

/**
 * Sets default parameters
 */
ED.IRMA.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(100, 100);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.IRMA.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.IRMA.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Move to centre
	ctx.moveTo(0, 30);

	// Create curves for the IRMA
	ctx.bezierCurveTo(-30, 30, -70, 0, -50, -20);
	ctx.bezierCurveTo(-30, -40, -20, -10, 0, -10);
	ctx.bezierCurveTo(20, -10, 30, -40, 50, -20);
	ctx.bezierCurveTo(70, 0, 30, 30, 0, 30);

	// Transparent fill
	ctx.fillStyle = "rgba(100, 100, 100, 0)";

	// Set attributes
	ctx.lineWidth = 3;
	ctx.strokeStyle = "red";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(50, -40));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.IRMA.prototype.groupDescription = function() {
	return "Intraretinal microvascular abnormalities ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.IRMA.prototype.description = function() {
	return this.locationRelativeToFovea();
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Keratic precipitates
 *
 * @class KeraticPrecipitates
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.KeraticPrecipitates = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "KeraticPrecipitates";

	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.KeraticPrecipitates.prototype = new ED.Doodle;
ED.KeraticPrecipitates.prototype.constructor = ED.KeraticPrecipitates;
ED.KeraticPrecipitates.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.KeraticPrecipitates.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.KeraticPrecipitates.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +40);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-160, +0);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.5);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.KeraticPrecipitates.prototype.setParameterDefaults = function() {
	// Hard drusen is displaced for Fundus, central for others
	if (this.drawing.hasDoodleOfClass('Fundus')) {
		this.originX = this.drawing.eye == ED.eye.Right ? -100 : 100;
		this.scaleX = 0.5;
		this.scaleY = 0.5;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.KeraticPrecipitates.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.KeraticPrecipitates.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Invisible boundary
	var r = 200;
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Colours
		var fill = "rgba(110, 110, 110, 0.5)";
		//var fill = "rgba(210, 210, 210, 0.5)";

		var dr = 10 * ((this.apexX + 20) / 20) / this.scaleX;

		var p = new ED.Point(0, 0);
		var n = 40 + Math.abs(Math.floor(this.apexY / 2));
		for (var i = 0; i < n; i++) {
			p.setWithPolars(r * ED.randomArray[i], 2 * Math.PI * ED.randomArray[i + 100]);
			this.drawSpot(ctx, p.x, p.y, dr, fill);
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(r * 0.7, -r * 0.7));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.KeraticPrecipitates.prototype.description = function() {
	return this.apexX > 20 ? "Mutton fat keratic precipitates" : "Keratic precipitates";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Peripheral iridectomy
 *
 * @class PI
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.KoeppeNodule = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "KoeppeNodule";

	// Saved parameters
	this.savedParameterArray = ['rotation'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.KoeppeNodule.prototype = new ED.Doodle;
ED.KoeppeNodule.prototype.constructor = ED.KoeppeNodule;
ED.KoeppeNodule.superclass = ED.Doodle.prototype;

/**
 * Sets default properties
 */
ED.KoeppeNodule.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
}

/**
 * Sets default parameters
 */
ED.KoeppeNodule.prototype.setParameterDefaults = function() {
	this.setRotationWithDisplacements(30, 30);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.KoeppeNodule.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.KoeppeNodule.superclass.draw.call(this, _point);

	// Radius of iris margin
	var r = 260;
	
	// If iris there, take account of pupil size
	var doodle = this.drawing.lastDoodleOfClass("AntSeg");
	if (doodle) r = -doodle.apexY;
	
	// Boundary path
	ctx.beginPath();

	// Draw nodule
	ctx.arc(0, -r, 20, 0, 2 * Math.PI, false);

	// Colour of fill
	ctx.fillStyle = "rgba(150,100,50,1)";

	// Set line attributes
	ctx.lineWidth = 1;

	// Colour of outer line is dark gray
	ctx.strokeStyle = ctx.fillStyle;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.KoeppeNodule.prototype.groupDescription = function() {
	return "Koeppe nodules";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Krukenberg's spindle
 *
 * @class KrukenbergSpindle
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.KrukenbergSpindle = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "KrukenbergSpindle";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexX', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.KrukenbergSpindle.prototype = new ED.Doodle;
ED.KrukenbergSpindle.prototype.constructor = ED.KrukenbergSpindle;
ED.KrukenbergSpindle.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.KrukenbergSpindle.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.KrukenbergSpindle.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-380, -80);
}

/**
 * Sets default parameters
 */
ED.KrukenbergSpindle.prototype.setParameterDefaults = function() {
	this.apexY = -150;
	this.originY = 200;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.KrukenbergSpindle.prototype.draw = function(_point) {;
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.KrukenbergSpindle.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Ellipse
	this.addEllipseToPath(ctx, 0, 0, -this.apexY/2, -this.apexY * 2);

	// Create fill
	ctx.fillStyle = ctx.createPattern(this.drawing.imageArray['BrownSpotPattern'], 'repeat');

	// Stroke
	ctx.strokeStyle = "rgba(255,128,0,0.5)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.KrukenbergSpindle.prototype.description = function() {
	return "Krukenberg spindle";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Laser circle
 *
 * @class LaserCircle
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.LaserCircle = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "LaserCircle";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexX', 'apexY', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.LaserCircle.prototype = new ED.Doodle;
ED.LaserCircle.prototype.constructor = ED.LaserCircle;
ED.LaserCircle.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.LaserCircle.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, true);
}

/**
 * Set default properties
 */
ED.LaserCircle.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(50, +400);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-400, -50);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.LaserCircle.prototype.setParameterDefaults = function() {
	this.apexX = 84;
	this.apexY = -84;

	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		var p = new ED.Point(doodle.originX, doodle.originY);

		var np = new ED.Point(0, 0);
		np.setWithPolars(p.length(), p.direction() + Math.PI / 6);

		this.move(np.x, np.y);
	} else {
		this.move((this.drawing.eye == ED.eye.Right ? -1 : 1) * 200, -300);
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.LaserCircle.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.LaserCircle.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();
	ctx.moveTo(this.apexX, this.apexY);
	ctx.lineTo(this.apexX, -this.apexY);
	ctx.lineTo(-this.apexX, -this.apexY);
	ctx.lineTo(-this.apexX, this.apexY);
	ctx.lineTo(this.apexX, this.apexY);
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Spot separation
		var ss = 25;

		// Point for spot
		var p = new ED.Point(0, 0);

		// Difference indicating aspect ratio
		var d = this.apexX + this.apexY;

		// Radius and displacement of semicircle
		if (d < 0) {
			var r = this.apexX;
		} else {
			var r = -this.apexY;
		}

		// Number of spots in a semicircle
		var n = (Math.round(Math.PI / (ss / r)));

		// Draw upper (or left) half
		for (var i = 0; i < n + 1; i++) {
			if (d < 0) {
				var a = -Math.PI / 2 + i * Math.PI / n;
				p.setWithPolars(r, a);
				this.drawLaserSpot(ctx, p.x, p.y + d);
			} else {
				var a = -Math.PI + i * Math.PI / n;
				p.setWithPolars(r, a);
				this.drawLaserSpot(ctx, p.x - d, p.y);
			}
		}

		// Draw lower (or right) half
		for (var i = 1; i < n; i++) {
			if (d < 0) {
				var a = Math.PI / 2 + i * Math.PI / n;
				p.setWithPolars(r, a);
				this.drawLaserSpot(ctx, p.x, p.y - d);
			} else {
				var a = 0 + i * Math.PI / n;
				p.setWithPolars(r, a);
				this.drawLaserSpot(ctx, p.x + d, p.y);
			}
		}

		// Draw connecting straight lines of laser
		n = Math.abs(Math.round(d / ss));
		for (var i = 0; i < 2 * n + 1; i++) {
			if (d < 0) {
				var y = this.apexY + r + i * Math.abs(d / n);
				this.drawLaserSpot(ctx, -r, y);
				this.drawLaserSpot(ctx, r, y);
			} else {
				var x = -this.apexX + r + i * Math.abs(d / n);
				this.drawLaserSpot(ctx, x, -r);
				this.drawLaserSpot(ctx, x, r);
			}
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.LaserCircle.prototype.groupDescription = function() {
	return "laser retinopexy";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Laser Demarcation
 *
 * @class LaserDemarcation
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.LaserDemarcation = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "LaserDemarcation";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.LaserDemarcation.prototype = new ED.Doodle;
ED.LaserDemarcation.prototype.constructor = ED.LaserDemarcation;
ED.LaserDemarcation.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.LaserDemarcation.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.LaserDemarcation.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 8, 2 * Math.PI);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-400, -300);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.LaserDemarcation.prototype.setParameterDefaults = function() {
	this.arc = 120 * Math.PI / 180;
	this.apexY = -350;

	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		this.rotation = doodle.rotation + Math.PI / 4;
	} else {
		if (this.drawing.eye == ED.eye.Right) {
			this.rotation = -0.8 * Math.PI;
		} else {
			this.rotation = 0.8 * Math.PI;
		}
	}

	// If there is a retinectomy present, adjust to it
	doodle = this.drawing.lastDoodleOfClass('PeripheralRetinectomy');
	if (doodle) {
		this.rotation = doodle.rotation;
		this.arc = doodle.arc + Math.PI / 16;
		this.apexY = doodle.apexY + 50;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.LaserDemarcation.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.LaserDemarcation.superclass.draw.call(this, _point);

	// Radius of outer curve just inside ora on right and left fundus diagrams
	var ro = 952 / 2;
	var ri = -this.apexY;
	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of LaserDemarcation
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, r, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255,255,0,0)";
	ctx.strokeStyle = "rgba(255,255,255,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Spot separation
		var ss = 25;

		// Location of laser spot
		var p = new ED.Point(0, 0);

		// Unless 360, go out to the ora with an elegant semicircle
		if (this.arc < 1.9 * Math.PI) {
			// Radius of quarter circle
			var rc = ro - ri;

			// Angle of quarter circle (not quite a quarter)
			var quad = Math.PI / 2;

			// Number of spots in a quarter circle
			var n = (Math.round(quad / (ss / rc)));

			// Centre of first quarter circle
			var c1 = new ED.Point(-ro * Math.sin(theta - rc / ro), -ro * Math.cos(theta - rc / ro));

			// Draw first quarter circle, including adjustment for improved junction
			for (var i = 0; i < n; i++) {
				p.setWithPolars(rc, arcEnd + 0.5 * (rc / ro) - i * quad / n);
				this.drawLaserSpot(ctx, c1.x + p.x, c1.y + p.y);
			}

			// Angle of main arc, with adjustment to make junction with semicircles look better
			var mainArc = this.arc - 2 * rc / ro;

			// Number of spots in the main arc
			var m = (Math.round(mainArc / (ss / ri)));

			// Draw main arc
			var mainStart = c1.direction();
			for (var i = 0; i < m + 1; i++) {
				p.setWithPolars(ri, mainStart + i * mainArc / m);
				this.drawLaserSpot(ctx, p.x, p.y);
			}

			// Centre of second quarter circle
			var c2 = new ED.Point(-ro * Math.sin(-theta + rc / ro), -ro * Math.cos(-theta + rc / ro));

			// Draw second quarter circle, including adjustment for improved junction
			for (var i = 0; i < n; i++) {
				p.setWithPolars(rc, arcStart + Math.PI - 0.5 * (rc / ro) + i * quad / n);
				this.drawLaserSpot(ctx, c2.x + p.x, c2.y + p.y);
			}
		} else {
			// Number of spots in the main arc
			var n = (Math.round(2 * Math.PI / (ss / ri)));

			// Draw main arc
			for (var i = 0; i < n; i++) {
				p.setWithPolars(ri, i * 2 * Math.PI / n);
				this.drawLaserSpot(ctx, p.x, p.y);
			}
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.LaserDemarcation.prototype.description = function() {
	var returnString = "";

	if (this.arc > 1.9 * Math.PI) {
		returnString += "360 degree ";
	}

	returnString += "laser demarcation";

	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Laser Spot
 *
 * @class LaserSpot
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.LaserSpot = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "LaserSpot";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.LaserSpot.prototype = new ED.Doodle;
ED.LaserSpot.prototype.constructor = ED.LaserSpot;
ED.LaserSpot.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.LaserSpot.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default properties
 */
ED.LaserSpot.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +3);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +3);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.LaserSpot.prototype.setParameterDefaults = function() {
	this.scaleX = 0.75;
	this.scaleY = 0.75;
	this.setOriginWithDisplacements(100, 80);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.LaserSpot.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.LaserSpot.superclass.draw.call(this, _point);

	// Radius of laser spot
	var r = 30;

	// Boundary path
	ctx.beginPath();

	// Circle
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = r * 2 / 3;
	ctx.fillStyle = "yellow";
	ctx.strokeStyle = "rgba(255, 128, 0, 1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.LaserSpot.prototype.groupDescription = function() {
	return "Laser spots";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Lasik Flap
 *
 * @class LasikFlap
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.LasikFlap = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "LasikFlap";

	// Derived parameters
	this.hinge = "";
	this.diameter = 6;
	
	// Other parameters
	this.femtoLaser = "";
	this.depth = 80;
	this.angle = 30;
	this.spotSeparation = "";
	this.lineSeparation = "";
	this.energyLevel = "";
	this.OBLGrade = "";

	// Saved parameters
	this.savedParameterArray = [
		'scaleX', 
		'scaleY', 
		'rotation', 
		'femtoLaser', 
		'diameter', 
		'depth', 
		'angle', 
		'spotSeparation', 
		'lineSeparation',
		'energyLevel',
		'OBLGrade'
	];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {
		'hinge':'Hinge',
		'femtoLaser':'Femto laser', 
		'diameter':'Diameter', 
		'depth':'Depth', 
		'angle':'Sidecut angle', 
		'spotSeparation':'Spot separation',
		'lineSeparation':'Line separation',
		'energyLevel':'Energy level',
		'OBLGrade':'OBL grade'
	};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.LasikFlap.prototype = new ED.Doodle;
ED.LasikFlap.prototype.constructor = ED.LasikFlap;
ED.LasikFlap.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.LasikFlap.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default dragging attributes
 */
ED.LasikFlap.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.snapToAngles = true;
	this.isUnique = true;
	
	// Array of angles to snap to
	var phi = Math.PI / 4;
	this.anglesArray = [0, (this.drawing.eye == ED.eye.Right)?(Math.PI/2):(3 * Math.PI/2)];

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.60, +1.00);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.60, +1.00);

	// Derived parameters	
	this.parameterValidationArray['hinge'] = {
		kind: 'other',
		type: 'string',
		list: ['Superior', 'Nasal'],
		animate: true
	};
	this.parameterValidationArray['diameter'] = {
		kind: 'derived',
		type: 'float',
		range: new ED.Range(6, 10),
		precision: 1,
		animate: true
	};
	
	// Other parameters
	this.parameterValidationArray['femtoLaser'] = {
		kind: 'other',
		type: 'string',
		list: ['DDL AMO iFS', 'Zeiss Visumax', 'Zeimer Z7'],
		animate: true
	};
	this.parameterValidationArray['depth'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(80, 200),
		animate: false
	};
	this.parameterValidationArray['angle'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(30, 150),
		animate: false
	};
	this.parameterValidationArray['spotSeparation'] = {
		kind: 'other',
		type: 'string',
		list: ['0.5um', '0.6um', '0.7um', '0.8um', '0.9um', '1.0um'],
		animate: false
	};
	this.parameterValidationArray['lineSeparation'] = {
		kind: 'other',
		type: 'string',
		list: ['0.5um', '0.6um', '0.7um', '0.8um', '0.9um', '1.0um'],
		animate: false
	};
	this.parameterValidationArray['energyLevel'] = {
		kind: 'other',
		type: 'string',
		list: ['0.50uJ', '0.55uJ', '0.60uJ', '0.65uJ', '0.70uJ', '0.75uJ', '0.80uJ', '0.85uJ', '0.90uJ', '0.95uJ', '1.00uJ'],
		animate: false
	};
	this.parameterValidationArray['OBLGrade'] = {
		kind: 'other',
		type: 'string',
		list: ['None', 'Trace outside pupillary axis', 'In pupillary axis'],
		animate: false
	};
}

/**
 * Sets default parameters
 */
ED.LasikFlap.prototype.setParameterDefaults = function() {
	this.setParameterFromString('hinge', 'Superior');
	this.setParameterFromString('femtoLaser', 'DDL AMO iFS');
	this.setParameterFromString('diameter', '8.5');
	this.setParameterFromString('depth', '110');
	this.setParameterFromString('angle', '90');
	this.setParameterFromString('spotSeparation', '0.6um');
	this.setParameterFromString('lineSeparation', '0.6um');
	this.setParameterFromString('energyLevel', '0.75uJ');
	this.setParameterFromString('OBLGrade', 'None');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.LasikFlap.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'scaleX':
			returnArray['diameter'] = _value * 10;
			break;
			
		case 'rotation':
			if (_value == 0) returnArray['hinge'] = 'Superior';
			else returnArray['hinge'] = 'Nasal';
			break;

		case 'diameter':
			returnArray['scaleX'] = parseFloat(_value)/10;
			returnArray['scaleY'] = parseFloat(_value)/10;
			break;
			
		case 'hinge':
			if (_value == 'Superior') returnArray['rotation'] = 0;
			else returnArray['rotation'] = (this.drawing.eye == ED.eye.Right)?(Math.PI/2):(3 * Math.PI/2);
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.LasikFlap.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.LasikFlap.superclass.draw.call(this, _point);

	// LasikFlap
	var r = 320;

	// Calculate parameters for arc
	var angle = Math.PI / 6;
	var arcStart = -Math.PI / 2 - angle;
	var arcEnd = -Math.PI / 2 + angle;

	// Boundary path
	ctx.beginPath();

	// Do an arc
	ctx.arc(0, 0, r, arcStart, arcEnd, true);

	// Close path to produce straight line
	ctx.closePath();

	// Create transparent fill pattern
	ctx.fillStyle = "rgba(155,255,255,0)";

	// Transparent stroke
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgba(100,100,100,0.9)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();
		ctx.arc(0, 0, r/2, 0, 2* Math.PI, true);
		switch (this.gradeDLK) {
			case 'None':
				ctx.fillStyle = "rgba(155,255,255,0)";
				break;
			case 'Grade 1':
				ctx.fillStyle = "rgba(155,255,255,0.4)";
				break;
			case 'Grade 2':
				ctx.fillStyle = "rgba(155,255,255,0.6)";
				break;
			case 'Grade 3':
				ctx.fillStyle = "rgba(155,255,255,0.8)";
				break;
		}
		ctx.fill();
	}

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0)
	point.setWithPolars(r, angle);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.LasikFlap.prototype.description = function() {
	var returnString = "";

	// Get side
	if (this.drawing.eye == ED.eye.Right) {
		var isRightSide = true;
	} else {
		var isRightSide = false;
	}

	// Use trigonometry on rotation field to determine quadrant ***TODO*** push function up to superclass
	var c = Math.cos(this.rotation);
	var s = Math.sin(this.rotation);
	var ac = Math.abs(c);
	var as = Math.abs(s);

	var quadrant = "";
	if (s > c && as > ac) quadrant = isRightSide ? "nasal" : "temporal";
	if (s > c && as < ac) quadrant = "inferior";
	if (s < c && as > ac) quadrant = isRightSide ? "temporal" : "nasal";
	if (s < c && as < ac) quadrant = "superior";

	returnString = "LASIK flap with " + quadrant + " hinge";

	return returnString;
}

/**
 * OpenEyes
 *
 * (C) OpenEyes Foundation, 2016
 *
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Lattice degeneration
 *
 * @class Lattice
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param _parameterJSON
 */
ED.Lattice = function(_drawing, _parameterJSON)
{
    // Set classname
    this.className = "Lattice";
  
    // Saved parameters
    this.savedParameterArray = ['arc', 'radius', 'originX', 'originY', 'rotation'];

    // Call superclass constructor
    ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Lattice.prototype = new ED.Doodle;
ED.Lattice.prototype.constructor = ED.Lattice;
ED.Lattice.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Lattice.prototype.setHandles = function()
{
    this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
    this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Sets default dragging attributes
 */
ED.Lattice.prototype.setPropertyDefaults = function()
{
    this.isSelectable = true;
    this.isOrientated = false;
    this.isScaleable = false;
    this.isSqueezable = false;
    this.isMoveable = false;
    this.isRotatable = true;
    this.rangeOfScale = new ED.Range(+0.125, +1.5);
    this.rangeOfArc = new ED.Range(Math.PI/12, Math.PI*2);
    this.rangeOfApexX = new ED.Range(-0, +0);
    this.rangeOfApexY = new ED.Range(50, +250);
}

/**
 * Sets default parameters
 */
ED.Lattice.prototype.setParameterDefaults = function()
{
    this.arc = 60 * Math.PI/180;

    // The radius property is changed by movement in rotatable doodles
    this.radius = 350;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Lattice.prototype.draw = function(_point)
{
    // Get context
    var ctx = this.drawing.context;

    // Call draw method in superclass
    ED.Lattice.superclass.draw.call(this, _point);

    // Lattice is at equator
    var ro = this.radius + 50;
    var ri = this.radius;
    var r = ri + (ro - ri)/2;

    // Calculate parameters for arcs
    var theta = this.arc/2;
    var arcStart = - Math.PI/2 + theta;
    var arcEnd = - Math.PI/2 - theta;

    // Coordinates of 'corners' of lattice
    var topRightX = r * Math.sin(theta);
    var topRightY = - r * Math.cos(theta);
    var topLeftX = - r * Math.sin(theta);
    var topLeftY = topRightY;

    // Boundary path
    ctx.beginPath();

    // Arc across to mirror image point on the other side
    ctx.arc(0, 0, ro, arcStart, arcEnd, true);

    // Arc back to mirror image point on the other side
    ctx.arc(0, 0, ri, arcEnd, arcStart, false);

    // Close path
    ctx.closePath();

    // Set line attributes
    ctx.lineWidth = 4;

    // create pattern
    var ptrn = ctx.createPattern(this.drawing.imageArray['LatticePattern'],'repeat');
    ctx.fillStyle = ptrn;

    ctx.strokeStyle = "lightgray";

    // Draw boundary path (also hit testing)
    this.drawBoundary(_point);

    // Other stuff here
    if (this.drawFunctionMode == ED.drawFunctionMode.Draw)
    {
    }

    // Coordinates of handles (in canvas plane)
    this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
    this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));

    // Draw handles if selected
    if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

    // Return value indicating successful hittest
    return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Lattice.prototype.description = function()
{
    var returnString = "Lattice at ";

    // Location (clockhours)
    returnString += this.clockHour() + " o'clock";

    return returnString;
}


/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.Lattice.prototype.snomedCode = function()
{
    return 3577000;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.Lattice.prototype.diagnosticHierarchy = function()
{
    return 2;
}

/**
 * OpenEyes
 * MSC mod
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Lens
 *
 * @class Lens
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Lens = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Lens";

	// Derived parameters
	this.nuclearGrade = 'None';
	this.corticalGrade = 'None';
	this.posteriorSubcapsularGrade = 'None';
	this.anteriorPolar = false;
	this.posteriorPolar = false;
	this.coronary = false;
	this.blueDot = false;
	this.phakodonesis = false;
	this.csOriginX = 0;

	// Saved parameters
	this.savedParameterArray = ['rotation', 'originX', 'originY', 'nuclearGrade', 'corticalGrade', 'posteriorSubcapsularGrade', 'anteriorPolar', 'posteriorPolar', 'coronary', 'phakodonesis','blueDot', 'csOriginX'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {
		'nuclearGrade':'Nuclear',
		'corticalGrade':'Cortical',
		'posteriorSubcapsularGrade':'Posterior subcapsular',
		'anteriorPolar':'Anterior polar',
		'posteriorPolar':'Posterior polar',
		'coronary':'Coronary',
		'phakodonesis':'Phacodonesis',
        'blueDot':'Blue Dot',
		};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Lens.prototype = new ED.Doodle;
ED.Lens.prototype.constructor = ED.Lens;
ED.Lens.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.Lens.prototype.setPropertyDefaults = function() {
	this.isUnique = true;
	this.addAtBack = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-125, +125);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-125, +125);

	this.parameterValidationArray['nuclearGrade'] = {
		kind: 'derived',
		type: 'string',
		list: ['None', 'Mild', 'Moderate', 'Brunescent'],
		animate: false
	};
	this.parameterValidationArray['corticalGrade'] = {
		kind: 'derived',
		type: 'string',
		list: ['None', 'Mild', 'Moderate', 'White'],
		animate: false
	};
	this.parameterValidationArray['posteriorSubcapsularGrade'] = {
		kind: 'derived',
		type: 'string',
		list: ['None', 'Small', 'Medium', 'Large'],
		animate: false
	};
	this.parameterValidationArray['anteriorPolar'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
	this.parameterValidationArray['posteriorPolar'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
	this.parameterValidationArray['coronary'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
	this.parameterValidationArray['blueDot'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};

	this.parameterValidationArray['phakodonesis'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Lens.prototype.setParameterDefaults = function() {}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Lens.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Lens.superclass.draw.call(this, _point);

	// Height of cross section (half value of ro in AntSeg doodle)
	var ro = 240;

	// Boundary path
	ctx.beginPath();

	// Do a 360 arc
	ctx.arc(0, 0, ro, 0, 2 * Math.PI, true);

	// Move to inner circle
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {

		// Posterior subcapsular
		if (this.posteriorSubcapsularGrade != 'None') {
			var rp;
			switch (this.posteriorSubcapsularGrade) {
				case 'Small':
					rp = 30;
					break;
				case 'Medium':
					rp = 60;
					break;
				case 'Large':
					rp = 90;
					break;
			}
			ctx.beginPath();
			ctx.arc(0, 0, rp, 0, Math.PI * 2, false);
			var ptrn = ctx.createPattern(this.drawing.imageArray['PSCPattern'], 'repeat');
			ctx.fillStyle = ptrn;
			ctx.strokeStyle = "lightgray";
			ctx.fill();
			ctx.stroke();
		}

		// Posterior Polar
		if (this.posteriorPolar) {
			var rap = 50;
			ctx.beginPath();
			ctx.arc(0, 0, rap, 0, Math.PI * 2, false);
			ctx.fillStyle = "rgba(140,140,140,0.75)";
			ctx.strokeStyle = "gray";
			ctx.fill();
			ctx.stroke();
		}

		// Nuclear cataract
		var ri = ro - 60;
		ctx.beginPath();
		ctx.arc(0, 0, ri, 0, 2 * Math.PI, true);
		ctx.strokeStyle = "rgba(220, 220, 220, 0.75)";
		ctx.stroke();
		if (this.nuclearGrade != 'None') {
			var col;
			switch (this.nuclearGrade) {
				case 'Mild':
					col = -120;
					break;
				case 'Moderate':
					col = -80;
					break;
				case 'Brunescent':
					col = +0;
					break;
			}
			yellowColour = "rgba(255, 255, 0, 0.75)";
			var brownColour = "rgba(" + Math.round(120 - col) + ", " + Math.round(60 - col) + ", 0, 0.75)";
			var gradient = ctx.createRadialGradient(0, 0, 210, 0, 0, 50);
			gradient.addColorStop(0, yellowColour);
			gradient.addColorStop(1, brownColour);
			ctx.fillStyle = gradient;
			ctx.fill();
		}

		// Cortical cataract
		if (this.corticalGrade != 'None') {
			// Parameters
			var n = 16; // Number of cortical spokes
			var ro = 240; // Outer radius of cataract
			var rs = 230; // Outer radius of spoke
			var theta = 2 * Math.PI / n; // Angle of outer arc of cortical shard
			var phi = theta / 2; // Half theta
			var ri;
			switch (this.corticalGrade) {
				case 'Mild':
					ri = 180;
					break;
				case 'Moderate':
					ri = 100;
					break;
				case 'White':
					ri = 20;
					break;
			}

			// Spokes
			ctx.beginPath();
			var sp = new ED.Point(0, 0);
			sp.setWithPolars(rs, -phi);
			ctx.moveTo(sp.x, sp.y);

			for (var i = 0; i < n; i++) {
				var startAngle = i * theta - phi;
				var endAngle = startAngle + theta;

				var op = new ED.Point(0, 0);
				op.setWithPolars(rs, startAngle);
				ctx.lineTo(op.x, op.y);

				//ctx.arc(0, 0, ro, startAngle, endAngle, false);
				var ip = new ED.Point(0, 0);
				ip.setWithPolars(ri, i * theta);
				ctx.lineTo(ip.x, ip.y);
			}
			ctx.lineTo(sp.x, sp.y);

			// Ring
			ctx.moveTo(ro, 0);
			ctx.arc(0, 0, ro, 0, 2 * Math.PI, true);

			// Set boundary path attributes
			ctx.lineWidth = 4;
			ctx.lineJoin = 'bevel';
			ctx.fillStyle = "rgba(200,200,200,0.75)";
			ctx.fill();
		}

		// Coronary cataracts
        // Spot data
        var rc = 130;
        var sr = 10;
        var inc = Math.PI / 8;
		if (this.coronary) {

			// Iterate through radius and angle to draw spots
			for (var a = 0; a < 2 * Math.PI; a += inc) {
				var p = new ED.Point(0, 0);
				p.setWithPolars(rc, a);
				this.drawCircle(ctx, p.x, p.y, sr, "rgba(200,200,255,1)", 4, "rgba(200,200,255,1)");
			}
		}

        //Blue dots
		if(this.blueDot){
            for (var a = 0; a < 2 * Math.PI; a += Math.PI / 6) {
                var p = new ED.Point(0, 0);
                p.setWithPolars(rc+72, a);
                this.drawCircle(ctx, p.x, p.y, sr+5, "rgba(168,194,218,1)", 4, "rgba(168,194,218,1)");
            }
		}

		// Anterior Polar
		if (this.anteriorPolar) {
			var rap = 30;
			ctx.beginPath();
			ctx.arc(0, 0, rap, 0, Math.PI * 2, false);
			ctx.fillStyle = "rgba(120,120,120,0.5)";
			ctx.strokeStyle = "gray";
			ctx.fill();
			ctx.stroke();
		}

		// Phacodonesis
		if (this.phakodonesis) {
			// Sine wave between arrow heads:
			//Set amplitude and width of the wave as well as sample rate
			var amplitude = 20;
			var width = 100;
			var srate = 1;

			//Draw sine wave
			ctx.beginPath();
			ctx.moveTo(-150,0);
			for (x=0; x<=300; x+= srate){
				ctx.lineTo(-150+x, amplitude*Math.sin(2*Math.PI*x/width));
			}

			// Set line attributes
			ctx.lineWidth = 4;
			ctx.strokeStyle = "blue";
			ctx.stroke();

			// Left arrow:
			ctx.beginPath();
			ctx.moveTo(-150,-20);
			ctx.lineTo(-225,0);
			ctx.lineTo(-150,20);

			// Set line attributes
			ctx.lineWidth = 4;
			ctx.fillStyle = "blue";
			ctx.fill();

			// Right arrow:
			ctx.beginPath();
			ctx.moveTo(150,-20);
			ctx.lineTo(225,0);
			ctx.lineTo(150,20);

			// Set line attributes
			ctx.lineWidth = 4;
			ctx.fillStyle = "blue";
			ctx.fill();
		}

	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Lens.prototype.description = function() {
	returnValue = "";

	if (this.originY < -30) {
		returnValue += 'Lens subluxation: superior';
	}
	else if (this.originY > 30) {
		returnValue += 'Lens subluxation: inferior';
	}
	if (this.nuclearGrade != 'None') {
		returnValue += returnValue.length > 0?", ":"";
		returnValue += this.nuclearGrade + ' nuclear cataract';
	}
	if (this.corticalGrade != 'None') {
		returnValue += returnValue.length > 0?", ":"";
		returnValue += this.corticalGrade + ' cortical cataract';
	}
	if (this.posteriorSubcapsularGrade != 'None') {
		returnValue += returnValue.length > 0?", ":"";
		returnValue += this.posteriorSubcapsularGrade + ' posterior subcapsular cataract';
	}
	if (this.coronary) {
		returnValue += returnValue.length > 0?", ":"";
		returnValue += 'Coronary cataract';
	}
	if (this.blueDot) {
		returnValue += returnValue.length > 0?", ":"";
		returnValue += 'Blue dot cataract';
	}

	if (this.anteriorPolar) {
		returnValue += returnValue.length > 0?", ":"";
		returnValue += 'Anterior polar cataract';
	}
	if (this.posteriorPolar) {
		returnValue += returnValue.length > 0?", ":"";
		returnValue += 'Posterior polar cataract';
	}
	if (this.phakodonesis) {
		returnValue += returnValue.length > 0?", ":"";
		returnValue += 'Phacodonesis';
	}
	return returnValue;
};

ED.Lens.prototype.snomedCodes = function()
{
	snomedCodes = new Array();
    if (this.nuclearGrade != 'None') {
        snomedCodes.push([53889007, 3]);
    }
    if (this.corticalGrade != 'None') {
        snomedCodes.push([193576003, 3]);
    }
    if (this.posteriorSubcapsularGrade != 'None') {
        snomedCodes.push([315353005, 3]);
    }
    if (this.coronary) {
    	snomedCodes.push([12195004, 3]);
    }
    if (this.anteriorPolar) {
    	snomedCodes.push([253224008, 3]);
    }
    if (this.posteriorPolar) {
        snomedCodes.push([253225009, 3]);
    }
    if (this.phakodonesis) {
    	snomedCodes.push([116669003, 3]);
    }

    return snomedCodes;
};

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Lens Cross Section ***TODO***
 *
 * @class LensCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.LensCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "LensCrossSection";
	this.nuclearGrade = 'None';
	this.corticalGrade = 'None';
	this.posteriorSubcapsularGrade = 'None';
	this.phakodonesis = false;
	this.anteriorPolar = false;
	this.posteriorPolar = false;
	this.acd = 3.0;

	this.savedParameterArray = ['originX', 'originY', 'nuclearGrade', 'corticalGrade', 'posteriorSubcapsularGrade','phakodonesis','anteriorPolar', 'posteriorPolar','acd'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

  this.linkedDoodleParameters = {
    'Lens': {
      source: ['originY', 'nuclearGrade', 'corticalGrade', 'posteriorSubcapsularGrade', 'phakodonesis', 'anteriorPolar', 'posteriorPolar'],
      store: [['originX', 'csOriginX']]
    }
  };

}

/**
 * Sets superclass and constructor
 */
ED.LensCrossSection.prototype = new ED.Doodle;
ED.LensCrossSection.prototype.constructor = ED.LensCrossSection;
ED.LensCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.LensCrossSection.prototype.setPropertyDefaults = function() {
	this.isUnique = true;
	this.addAtBack = true;

	this.parameterValidationArray['nuclearGrade'] = {
		kind: 'derived',
		type: 'string',
		list: ['None', 'Mild', 'Moderate', 'Brunescent'],
		animate: false
	};

	this.parameterValidationArray['corticalGrade'] = {
		kind: 'derived',
		type: 'string',
		list: ['None', 'Mild', 'Moderate', 'White'],
		animate: true
	};

	this.parameterValidationArray['posteriorSubcapsularGrade'] = {
		kind: 'derived',
		type: 'string',
		list: ['None', 'Small', 'Medium', 'Large'],
		animate: false
	};

    this.parameterValidationArray['phakodonesis'] = {
		kind: 'other',
		type: 'bool',
		display: false
	};
	
	this.parameterValidationArray['anteriorPolar'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
	
	this.parameterValidationArray['posteriorPolar'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
	
	this.parameterValidationArray['acd'] = {
		kind: 'derived',
		type: 'float',
		range: new ED.Range(0, 5),
		precision: 1,
		animate: false
	};
	
	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-150, +200);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-140, +140);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.LensCrossSection.prototype.setParameterDefaults = function() {
	this.originX = 44;
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.LensCrossSection.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'originX':
			// constrain iris X coordinate
			var iris = this.drawing.lastDoodleOfClass('AntSegCrossSection');
			if (iris) {
				var minApexX = iris.parameterValidationArray['apexX']['range'].min;
				
				var currentMaxApexX = iris.parameterValidationArray['apexX']['range'].max;
				
				var maxApexX = 32 - (72 / 220) * (iris.apexY + 280) + this.originX - 44;
				if (maxApexX < minApexX) maxApexX = minApexX;
				iris.parameterValidationArray['apexX']['range'].setMinAndMax(-40 - (140 / 220) * (iris.apexY + 280), maxApexX);
				
				// If being synced, make sensible decision about x
				if (!this.drawing.isActive) {
					var newOriginX = iris.parameterValidationArray['apexX']['range'].max;
				} else {
					var nwX = maxApexX - (currentMaxApexX - iris.apexX);
					var newOriginX = iris.parameterValidationArray['apexX']['range'].constrain(nwX);
				}
				iris.setSimpleParameter('apexX', newOriginX);
			}
			
			// calculate anterior chamber depth
			this.calculateACD();

			break;
		}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.LensCrossSection.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.LensCrossSection.superclass.draw.call(this, _point);

	// Height of cross section (half value of ro in AntSeg doodle)
	var h = 240;

	// Arbitrary radius of curvature
	var r = 300;

	// Displacement of lens from centre
	var ld = 100;

	// Angle of arc
	var theta = Math.asin(h / r);

	// X coordinate of centre of circle
	var x = r * Math.cos(theta);

	// Measurements of nucleus
	var rn = r - 60;

	// Calculate nucleus angles
	var phi = Math.acos(x / rn);

	// Lens
	ctx.beginPath();

	// Draw lens with two sections of circumference of circle
	ctx.arc(ld - x, 0, r, theta, -theta, true);
	ctx.arc(ld + x, 0, r, Math.PI + theta, Math.PI - theta, true);

	// Draw it
	ctx.stroke();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Nucleus
		ctx.beginPath();
		ctx.moveTo(ld, rn * Math.sin(phi));
		ctx.arc(ld - x, 0, rn, phi, -phi, true);
		ctx.arc(ld + x, 0, rn, Math.PI + phi, Math.PI - phi, true);
		ctx.strokeStyle = "rgba(220, 220, 220, 0.75)";
		ctx.stroke();

		if (this.nuclearGrade != 'None') {
			var col;
			switch (this.nuclearGrade) {
				case 'Mild':
					col = -120;
					break;
				case 'Moderate':
					col = -80;
					break;
				case 'Brunescent':
					col = +0;
					break;
			}
			yellowColour = "rgba(255, 255, 0, 0.75)";
			var brownColour = "rgba(" + Math.round(120 - col) + ", " + Math.round(60 - col) + ", 0, 0.75)";
			var gradient = ctx.createRadialGradient(0, 0, 210, 0, 0, 50);
			gradient.addColorStop(0, yellowColour);
			gradient.addColorStop(1, brownColour);
			ctx.fillStyle = gradient;
			ctx.fill();
		}

		// Cortical Cataract
		if (this.corticalGrade != "None") {
			var apexY;

			switch (this.corticalGrade) {
				case 'Mild':
					apexY = -180;
					break;
				case 'Moderate':
					apexY = -100;
					break;
				case 'White':
					apexY = -20;
					break;
			}

			// Angle of arc
			var theta = Math.asin(h / r);

			// X coordinate of centre of circle
			var x = r * Math.cos(theta);

			// Radius of cortical cataract (half way between capsule and nucleus)
			var rco = r - 30;

			// Calculate nucleus angles
			theta = Math.acos(x / rco);

			// Calculate cataract angles
			var phi = Math.asin(-apexY / rco);

			// Boundary path
			ctx.beginPath();

			// Draw cataract with two sections of circumference of circle
			ctx.arc(ld - x, 0, rco, phi, theta, false);
			ctx.arc(ld + x, 0, rco, Math.PI - theta, Math.PI - phi, false);

			// Move to upper half and draw it
			var l = rco * Math.cos(phi);
			ctx.moveTo(ld - x + l, apexY);
			ctx.arc(ld - x, 0, rco, -phi, -theta, true);
			ctx.arc(ld + x, 0, rco, Math.PI + theta, Math.PI + phi, true);

			// Set line attributes
			ctx.lineWidth = 30;
			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';
			ctx.fillStyle = "rgba(0, 0, 0, 0)";
			ctx.strokeStyle = "rgba(200,200,200,0.75)";
			// Draw boundary path (also hit testing)
			this.drawBoundary(_point);
		}

		// Post SubCap Cataract
		if (this.posteriorSubcapsularGrade != "None") {
			var apexY;
			switch (this.posteriorSubcapsularGrade) {
				case 'Small':
					apexY = 30;
					break;
				case 'Medium':
					apexY = 60;
					break;
				case 'Large':
					apexY = 90;
					break;
			}

			// Angle of arc
			var theta = Math.asin(h / r);

			// X coordinate of centre of circle
			var x = r * Math.cos(theta);

			// Radius of cataract (Just inside capsule)
			var rco = r - 10;

			// Calculate cataract angles
			var phi = Math.asin(apexY / rco);

			// Boundary path
			ctx.beginPath();

			// Draw cataract with two sections of circumference of circle
			ctx.arc(ld - x, 0, rco, -phi, phi, false);

			// Set line attributes
			ctx.lineWidth = 10;
			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';
			ctx.fillStyle = "rgba(0, 0, 0, 0)";
			ctx.strokeStyle = "rgba(150,150,150,0.75)";

			// Draw boundary path (also hit testing)
			this.drawBoundary(_point);
		}


		// Zonules
		ctx.beginPath();

		// Top zonules
		ctx.moveTo(44 - this.originX + 80, -this.originY - 349);
		ctx.lineTo(64, -207);
		ctx.moveTo(44 - this.originX + 80, -this.originY - 349);
		ctx.lineTo(138, -207);
		ctx.moveTo(44 - this.originX + 120, -this.originY - 349);
		ctx.lineTo(64, -207);
		ctx.moveTo(44 - this.originX + 120, -this.originY - 349);
		ctx.lineTo(138, -207);

		// Bottom zonules
		ctx.moveTo(44 - this.originX + 80, -this.originY + 349);
		ctx.lineTo(64, 207);
		ctx.moveTo(44 - this.originX + 80, -this.originY + 349);
		ctx.lineTo(138, 207);
		ctx.moveTo(44 - this.originX + 120, -this.originY + 349);
		ctx.lineTo(64, 207);
		ctx.moveTo(44 - this.originX + 120, -this.originY + 349);
		ctx.lineTo(138, 207);

		ctx.lineWidth = 2;
		ctx.strokeStyle = "gray";
		ctx.stroke();
		
		// Pacodonesis
		if (this.phakodonesis) {
			// Sine wave between arrow heads:
			//Set amplitude and width of the wave as well as sample rate
			var amplitude = 20;
			var width = 100;
			var srate = 1;
	
			//Draw sine wave
			ctx.beginPath();
			ctx.moveTo(100,-125);
			for (y=0; y<=250; y+= srate){
				ctx.lineTo(100+amplitude*Math.sin(2*Math.PI*y/width), -125+y);
			}
	
			// Set line attributes
			ctx.lineWidth = 4;
			ctx.strokeStyle = "blue";
			ctx.stroke();
	
			// Top arrow:
			ctx.beginPath();
			ctx.moveTo(80,-125);
			ctx.lineTo(100,-225);
			ctx.lineTo(120,-125);
	
			// Set line attributes
			ctx.lineWidth = 4;
			ctx.fillStyle = "blue";
			ctx.fill();
	
			// Bottom arrow:
			ctx.beginPath();
			ctx.moveTo(80,125);
			ctx.lineTo(100,225);
			ctx.lineTo(120,125);
	
			// Set line attributes
			ctx.lineWidth = 4;
			ctx.fillStyle = "blue";
			ctx.fill();
		}
		
		// anterior polar cataract
		if (this.anteriorPolar) {			
			var c = new ED.Point(ld + x, 0);
			var angle = Math.PI+10/180*Math.PI;
			var o = Math.sin(angle) * r;
			var a = Math.cos(angle) * r;
			var start = new ED.Point(c.x+a,c.y+o);

			ctx.beginPath();
			ctx.arc(c.x, c.y, r, Math.PI+10/180*Math.PI, Math.PI-10/180*Math.PI, true);
			ctx.bezierCurveTo(start.x-40,10,start.x-40,-10,start.x,start.y);
			
			ctx.strokeStyle = "gray";
			ctx.fillStyle = "rgba(120,120,120,0.5)";
			ctx.fill();
			ctx.stroke();
		}
		
		// posterior polar cataract
		if (this.posteriorPolar) {
			var c = new ED.Point(ld - x, 0);
			var angle = 10/180*Math.PI;
			var o = Math.sin(angle) * r;
			var a = Math.cos(angle) * r;
			var start = new ED.Point(c.x+a,c.y+o);
			
			ctx.beginPath();
			ctx.arc(c.x, c.y, r, 10/180*Math.PI, -10/180*Math.PI, true);
			ctx.bezierCurveTo(start.x+40,-10,start.x+40,10,start.x,start.y);

			ctx.strokeStyle = "gray";
			ctx.fillStyle = "rgba(120,120,120,0.5)";
			ctx.fill();
			ctx.stroke();
		}
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

ED.LensCrossSection.prototype.calculateACD = function() {
	var cornea = this.drawing.lastDoodleOfClass('CorneaCrossSection');
	if (cornea) {
		var anteriorX;
		switch (cornea.shape) {
			case 'Normal':
				// max originX : -150 == 3mm in this doodle plane
				// max originX : -220 in cornea doodle plane
				/// difference: +70
				anteriorX = -150;
				break;
				
			case 'Keratoconus':
				var thickness = cornea.pachymetry/5;
				anteriorX = cornea.apexX + thickness + 70;
				break;
				
			case 'Keratoglobus':
				// -280 in cornea doodle plane
				anteriorX = -210;
				break;
		}
		
		var depth = this.originX - 44 - anteriorX;
		
		// scale 150 : 3mm
		this.acd = (depth * 3 / 150).toFixed(1);
		if (this.acd<0) this.acd = 0;
	}

}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.LensCrossSection.prototype.description = function() {
	var returnString = "";
	returnString += "AC depth: " + this.acd + "mm";

	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Lids
 *
 * @class Lids
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Lids = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Lids";

	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY', 'dir'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Lids.prototype = new ED.Doodle;
ED.Lids.prototype.constructor = ED.Lids;
ED.Lids.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Lids.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, true);
	this.handleArray[1] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, true);
}

/**
 * Sets default dragging attributes
 */
ED.Lids.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isMoveable = false;
	this.isScalable = false;
	this.isRotatable= false;
	this.isShowHighlight = false;
	
	// Create ranges to constrain handles
	this.handleCoordinateRangeArray = new Array();
	this.handleCoordinateRangeArray[0] = {
		// lower lid
		x: new ED.Range(-260, +260),
		y: new ED.Range(+30, +300)
	};
	this.handleCoordinateRangeArray[1] = {
		// upper lid
		x: new ED.Range(-0, +0),
		y: new ED.Range(-120, +110)
	};
}

/**
 * Sets default parameters
 */
ED.Lids.prototype.setParameterDefaults = function() {
	if (this.drawing.eye != ED.eye.Right) {
		this.dir = -1;
	}
	else if (this.drawing.eye != ED.eye.Left){
		this.dir = +1;
	}
	
	// handle start position
	this.apexX = 0;
	this.apexY = 110;
	
	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate with handles on each lid
	var point1 = new ED.Point(0, 115);
	this.squiggleArray[0].pointsArray.push(point1);
	
	var point2 = new ED.Point(0, -90);
	this.squiggleArray[0].pointsArray.push(point2);	
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Lids.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Lids.superclass.draw.call(this, _point);

	// Arc radius
	var d = 250;
	
	// control point height
	var h = 160;
	
	// control point width
	var w = 90;
	
	// Pupil radius
	var rP = 100;
	
	// punctum radius
	var p = 45;

	
	// Calculate control point positions for bezier curves
	var bMP = this.squiggleArray[0].pointsArray[0];
	var bStart = new ED.Point(d * this.dir, p + (bMP.y-115)/5);
	var bEnd = new ED.Point(-d * this.dir, 0);

	if (bMP.x*this.dir > 20) bStart.x += (bMP.x-20)/5;
		
	var bCP1 = new ED.Point(bMP.x + 60*this.dir, bMP.y * 1.45);
	var bCP2 = new ED.Point(bMP.x - 180*this.dir, bMP.y * 1.16);
	
	var tMP = this.squiggleArray[0].pointsArray[1];
	var tEnd = new ED.Point(d * this.dir, 0 + (tMP.y/5+19));

	var tCP1 = new ED.Point(-85 * this.dir, tMP.y * 1.3);
	var tCP2 = new ED.Point(85 * this.dir, tMP.y * 1.35);
	
	// Boundary path
	ctx.beginPath();

	// Draw invisible boundary around canvas and lids
	ctx.moveTo(-510 * this.dir,-510);
	ctx.lineTo(-510 * this.dir,510);
	ctx.lineTo(510 * this.dir,510);
	ctx.lineTo(510 * this.dir,-510);
	ctx.lineTo(-510 * this.dir,-510);
	
	// Draw lids boundary
	ctx.moveTo(bEnd.x, bEnd.y);
	
	// Top lid
// 	ctx.bezierCurveTo(-rP * 0.85 * this.dir, -h, rP * 1.05 * this.dir, -h, tEnd.x, tEnd.y);
	ctx.bezierCurveTo(tCP1.x, tCP1.y, tCP2.x, tCP2.y, tEnd.x, tEnd.y);
	
	// Punctum
		ctx.bezierCurveTo(d * 1.25 * this.dir, p*0.9, d * 1.2 * this.dir, p, bStart.x, bStart.y);
	  
	// Bottom lid
	ctx.bezierCurveTo(bCP1.x, bCP1.y, bCP2.x, bCP2.y, bEnd.x, bEnd.y);
	
	// Close path
	ctx.closePath();

	// Set drawing attributes
	ctx.lineWidth = 5;
	ctx.fillStyle = "white"
	ctx.strokeStyle = "rgba(0,0,0,0)";
	ctx.shadowBlur = 15;
	ctx.shadowColor = "rgba(0,0,0,0.8)";


	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
	
		// lids outline
		ctx.beginPath();
		ctx.moveTo(-d * this.dir,0);
		ctx.bezierCurveTo(tCP1.x, tCP1.y, tCP2.x, tCP2.y, tEnd.x, tEnd.y);
		ctx.bezierCurveTo(d * 1.25 * this.dir, p*0.9, d * 1.2 * this.dir, p, bStart.x, bStart.y);
		ctx.bezierCurveTo(bCP1.x, bCP1.y, bCP2.x, bCP2.y, bEnd.x, bEnd.y);
		ctx.moveTo(-d * this.dir,0);
		ctx.strokeStyle = "black";
		ctx.stroke();
		ctx.closePath();
		
		// top lashes (ish)
		ctx.beginPath();
		ctx.moveTo(bEnd.x, bEnd.y);
		ctx.lineTo(bEnd.x - p * 0.5 * this.dir,bEnd.y + p*0.5 - tMP.y/5-19);
		ctx.stroke();
		ctx.closePath();
		
		
		// bottom lid ridge
		var bRidgeCP1 = new ED.Point(bMP.x - 170*this.dir, bMP.y * 1.38);
		var bRidgeCP2 = new ED.Point(bMP.x + 70*this.dir, bMP.y * 1.45);
		ctx.beginPath();
		ctx.moveTo(-d * this.dir,0);
		ctx.bezierCurveTo(bRidgeCP1.x, bRidgeCP1.y, bRidgeCP2.x, bRidgeCP2.y, bStart.x, bStart.y);
	// 	ctx.strokeStyle = "gray";
		ctx.lineWidth = 3;
		ctx.stroke();
		ctx.closePath();
		
		// top eye crease
		ctx.beginPath();
		ctx.moveTo(-d * this.dir - p * 0.9 * this.dir, p * 0.1);
		ctx.bezierCurveTo(-rP*1.3 * this.dir,-h*1.2,rP * this.dir,-h*1.2, d*this.dir + p*this.dir, 0);
		// 	ctx.strokeStyle = "gray";
		ctx.lineWidth = 3;
		ctx.shadowBlur = 7;
		ctx.shadowColor = "black";
		ctx.stroke();
		ctx.closePath();
		
		// bottom crease
			
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[0]); // bottom lid - ectropion
	this.handleArray[1].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[1]); // top lid - ptosis
		
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Lids.prototype.description = function() {
	var bMP = this.squiggleArray[0].pointsArray[0];
	var tMP = this.squiggleArray[0].pointsArray[1];
	
	var returnString = "";
	
	var ptosis = "";
	if (tMP.y>=-57 && tMP.y<-38) ptosis = "Mild ptosis";
	else if (tMP.y>=-38 && tMP.y<-19) ptosis = "Moderate ptosis";
	else if (tMP.y>=-19) ptosis = "Severe ptosis";
	
	// TODO: change to an arc tangent to define ectropion?
	var ectropion = "";
	if (bMP.y>132 && bMP.x*this.dir > 90) ectropion = "Medial ectropion";
	else if (bMP.y>132 && bMP.x*this.dir < -90) ectropion = "Lateral ectropion";
	else if (bMP.y>132) ectropion = "Ectropion";
	
	if (ptosis.length > 0) returnString += ptosis;
	if (ptosis.length > 0 && ectropion.length > 0) returnString += ", ";
	if (ectropion.length > 0) returnString += ectropion;
	
	return returnString;
	
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * LimbalRelaxingIncision
 *
 * @class LimbalRelaxingIncision
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.LimbalRelaxingIncision = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "LimbalRelaxingIncision";

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.LimbalRelaxingIncision.prototype = new ED.Doodle;
ED.LimbalRelaxingIncision.prototype.constructor = ED.LimbalRelaxingIncision;
ED.LimbalRelaxingIncision.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.LimbalRelaxingIncision.prototype.setHandles = function() {
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Sets default dragging attributes
 */
ED.LimbalRelaxingIncision.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = true;
	this.isArcSymmetrical = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(20 * Math.PI / 180, Math.PI / 2);
}

/**
 * Sets default parameters
 */
ED.LimbalRelaxingIncision.prototype.setParameterDefaults = function() {
	// Default arc
	this.arc = 30 * Math.PI / 180;

	// Make it 180 degrees to last one of same class
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		this.rotation = doodle.rotation + Math.PI;
		this.arc = doodle.arc;
	} else {
		// LRIs are usually temporal
		if (this.drawing.eye == ED.eye.Right) {
			this.rotation = -Math.PI / 2;
		} else {
			this.rotation = Math.PI / 2;
		}
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.LimbalRelaxingIncision.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.LimbalRelaxingIncision.superclass.draw.call(this, _point);

	// Radius
	var r = 360
	var d = 12;
	var ro = r + d;
	var ri = r - d;

	// Boundary path
	ctx.beginPath();

	// Half angle of arc
	var theta = this.arc / 2;

	// Arc across
	ctx.arc(0, 0, ro, -Math.PI / 2 + theta, -Math.PI / 2 - theta, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, -Math.PI / 2 - theta, -Math.PI / 2 + theta, false);

	// Close path
	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = "rgba(100,100,200,0.75)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "rgba(120,120,120,0.75)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, theta);
	this.handleArray[3].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.LimbalRelaxingIncision.prototype.description = function() {
	var returnString = "Limbal relaxing incision " + (this.arc * 180 / Math.PI).toFixed(0) + " degrees at ";
	returnString += this.clockHour() + " o'clock";

	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Blot Haemorrhage
 *
 * @class Macroaneurysm
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Macroaneurysm = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Macroaneurysm";
	
	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Macroaneurysm.prototype = new ED.Doodle;
ED.Macroaneurysm.prototype.constructor = ED.Macroaneurysm;
ED.Macroaneurysm.superclass = ED.Doodle.prototype;

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Macroaneurysm.prototype.setParameterDefaults = function() {
	this.setOriginWithRotations(300, 60, 60);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Macroaneurysm.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Macroaneurysm.superclass.draw.call(this, _point);

	// Aneurysm radius
	var r = 50;

	// Boundary path
	ctx.beginPath();

	// Haemorrhage
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 1;
	ctx.strokeStyle = "red";
	ctx.fillStyle = "red";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// yellow centre spot
		if (this.apexY > -70) {
			ctx.beginPath();
			ctx.arc(0, 0, 25, 0, 2 * Math.PI, true);
			ctx.fillStyle = "rgba(197,186,80,1)";
			ctx.fill();
		}
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.Macroaneurysm.prototype.description = function() {
	return "Macroaneurysm";
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.Macroaneurysm.prototype.snomedCode = function() {
	return 247124009;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * MaculaPostPole template with disc and arcades
 *
 * @class MaculaPostPole
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.MaculaPostPole = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "MaculaPostPole";

    // Other parameters
    this.watzke = 'Not assessed';

	// Saved parameters
	this.savedParameterArray = ['watzke'];

    this.controlParameterArray = {
        'watzke': 'Watzke Result'
    };

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.MaculaPostPole.prototype = new ED.Doodle;
ED.MaculaPostPole.prototype.constructor = ED.MaculaPostPole;
ED.MaculaPostPole.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.MaculaPostPole.prototype.setHandles = function() {}

/**
 * Set default properties
 */
ED.MaculaPostPole.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;
    this.willReport = true;
    this.inFrontOfClassArray = ['PostPole'];

    this.parameterValidationArray.watzke = {
		kind: 'derived',
		type: 'string',
		list: ['Not assessed', 'Normal', 'Abnormal'],
		animate: true
    };
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.MaculaPostPole.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;
    var foveaX = 0;

	// Call draw method in superclass
	ED.MaculaPostPole.superclass.draw.call(this, _point);

	// Disc location
	var x = this.drawing.eye == ED.eye.Right ? 300 : -300;

	// Boundary path
	ctx.beginPath();

	// Set attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "rgba(249,187,76,0)";
	ctx.fillStyle = "rgba(249,187,76,0)";

	ctx.arc(0,0,20,0,2*Math.PI,true);

    // Draw boundary path (also hit testing)
    this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.MaculaPostPole.prototype.description = function() {
    var returnValue = "";

	if(this.watzke !== 'Not assessed'){
		returnValue += 'Watzke: ' + this.watzke.toLowerCase() + " ";
	}

    if (returnValue.length === 0 && this.drawing.doodleArray.length === 1) {
        returnValue = "No abnormality";
	}

	return returnValue;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Blot Haemorrhage
 *
 * @class MacularDystrophy
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.MacularDystrophy = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "MacularDystrophy";

	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.MacularDystrophy.prototype = new ED.Doodle;
ED.MacularDystrophy.prototype.constructor = ED.MacularDystrophy;
ED.MacularDystrophy.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.MacularDystrophy.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.MacularDystrophy.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-100, +100);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.MacularDystrophy.prototype.setParameterDefaults = function() {
	this.apexY = -100;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.MacularDystrophy.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.MacularDystrophy.superclass.draw.call(this, _point);

	// Radius
	var r = 150;

	// Boundary path
	ctx.beginPath();

	// Dystrophy
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 1;
	ctx.strokeStyle = "rgba(255,0,0,0)";
	ctx.fillStyle = "rgba(255,0,0,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {

		if (this.apexY < -50) {
			// Bull's eye maculopathy
			ctx.beginPath();
			ctx.moveTo(-200, 0);
			ctx.bezierCurveTo(-200, -70, -100, -140, 0, -140);
			ctx.bezierCurveTo(100, -140, 200, -70, 200, 0);
			ctx.bezierCurveTo(200, 70, 100, 140, 0, 140);
			ctx.bezierCurveTo(-100, 140, -200, 70, -200, 0);
			ctx.fillStyle = "rgba(223,80,20,1)";
			ctx.fill();

			ctx.beginPath();
			ctx.moveTo(-100, 0);
			ctx.bezierCurveTo(-100, -35, -50, -70, 0, -70);
			ctx.bezierCurveTo(50, -70, 100, -35, 100, 0);
			ctx.bezierCurveTo(100, 35, 50, 70, 0, 70);
			ctx.bezierCurveTo(-50, 70, -100, 35, -100, 0);
			ctx.fillStyle = "rgba(125,65,54,1)";
			ctx.fill();
		}
		else if (this.apexY < 0) {
			// Vitteliform
			ctx.beginPath();
			ctx.arc(0, 0, 100, 0, 2 * Math.PI, true);
			ctx.fillStyle = "yellow";
			ctx.strokeStyle = "brown";
			ctx.lineWidth = 20;
			ctx.fill();
			ctx.stroke();
		}
		else {
			// Atrophic
			ctx.beginPath();
			ctx.arc(0, 0, 120, 0, 2 * Math.PI, true);
			ctx.fillStyle = "rgba(255, 120, 120, 0.5)";
			ctx.strokeStyle = ctx.fillStyle;
			ctx.lineWidth = 1;
			ctx.fill();
		}
	}

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.MacularDystrophy.prototype.groupDescription = function() {
	if (this.apexY < -50) {
		return "Bull's eye maculopathy";
	}
	else if (this.apexY < 0) {
		return "Vitelliform macular dystrophy";
	}
	else {
		return "Atrophic macular dystrophy";
	}
}


/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.MacularDystrophy.prototype.snomedCode = function() {
	return 276436007;
}


/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Macular Grid
 *
 * @class MacularGrid
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.MacularGrid = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "MacularGrid";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'scaleX', 'scaleY'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.MacularGrid.prototype = new ED.Doodle;
ED.MacularGrid.prototype.constructor = ED.MacularGrid;
ED.MacularGrid.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.MacularGrid.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.MacularGrid.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;
	this.addAtBack = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-150, -50);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.MacularGrid.prototype.setParameterDefaults = function() {
	this.apexY = -100;
	this.scaleX = 0.7;
	this.scaleY = 0.7;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.MacularGrid.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PRPPostPole.superclass.draw.call(this, _point);

	// Radius of outer and inner circle
	var ro = 250;
	var ri = -this.apexY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, 0, 2 * Math.PI, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, 2 * Math.PI, 0, false);

	// Close path
	ctx.closePath();

	// Set line attributes (NB Note strokeStyle in order to get a highlight when selected
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(255, 255, 255, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Grid spot separation
		var ss = 60;
		n = Math.floor(2 * ro / ss);
		var start = -n / 2 * ss;

		// Draw spots
		for (var i = 0; i < n + 1; i++) {
			for (var j = 0; j < n + 1; j++) {
				var x = start + i * ss + Math.round((-0.5 + ED.randomArray[i + j]) * 15);
				var y = start + j * ss + Math.round((-0.5 + ED.randomArray[i + j + 100]) * 15);

				// calculate radius of spot position
				var rSq = x * x + y * y;

				// Only draw spots that within area
				if (rSq >= ri * ri && rSq <= ro * ro) {
					this.drawLaserSpot(ctx, x, y);
				}
			}
		}
	}

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(ro, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.MacularGrid.prototype.description = function() {
	return "Macular grid laser";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Macular hole
 *
 * @class MacularHole
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.MacularHole = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "MacularHole";

	// Saved parameters
	this.savedParameterArray = ['originX', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.MacularHole.prototype = new ED.Doodle;
ED.MacularHole.prototype.constructor = ED.MacularHole;
ED.MacularHole.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.MacularHole.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default properties
 */
ED.MacularHole.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.5);
}

/**
 * Sets default parameters
 */
ED.MacularHole.prototype.setParameterDefaults = function() {
	// Macular hole is displaced for Fundus, central for others
	if (this.drawing.hasDoodleOfClass('Fundus')) {
		this.originX = this.drawing.eye == ED.eye.Right ? -100 : 100;
		this.scaleX = 0.5;
		this.scaleY = 0.5;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.MacularHole.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.MacularHole.superclass.draw.call(this, _point);

	// Radius
	var r = 40;

	// Boundary path
	ctx.beginPath();

	// Large yellow circle - hole and subretinal fluid
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "yellow";
	ctx.strokeStyle = "red";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();
		ctx.arc(0, 0, 2 * r / 3, 0, Math.PI * 2, true);
		ctx.closePath();
		ctx.fillStyle = "red";
		ctx.fill();
	}

	// Coordinates of handles (in canvas plane)
	point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.MacularHole.prototype.description = function() {
	return "Macular hole";
}


/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.MacularHole.prototype.snomedCode = function() {
	return 232006002;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.MacularHole.prototype.diagnosticHierarchy = function() {
	return 2;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Macular Thickening
 *
 * @class MacularThickening
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.MacularThickening = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "MacularThickening";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexX', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

	// Invariate parameters
	this.rotation = -Math.PI / 4;
}

/**
 * Sets superclass and constructor
 */
ED.MacularThickening.prototype = new ED.Doodle;
ED.MacularThickening.prototype.constructor = ED.MacularThickening;
ED.MacularThickening.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.MacularThickening.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.MacularThickening.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(+100, +400);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-0, +0);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.MacularThickening.prototype.setParameterDefaults = function() {

	this.apexX = 100;
	this.apexY = 0;

	this.setOriginWithDisplacements(0, 150);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.MacularThickening.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.MacularThickening.superclass.draw.call(this, _point);

	// Exudate radius
	var r = Math.sqrt(this.apexX * this.apexX + this.apexY * this.apexY);

	// Boundary path
	ctx.beginPath();

	// Exudate
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 3;
	ctx.strokeStyle = "rgba(255, 255, 255, 0)";
	ctx.fillStyle = "rgba(255, 255, 255, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Start path
		ctx.beginPath();

		// Spacing of lines
		var d = 30;

		// Draw central line
		ctx.moveTo(-r, 0);
		ctx.lineTo(r, 0);

		// Draw other lines
		for (var s = -1; s < 2; s += 2) {
			for (var y = d; y < r; y += d) {
				var x = this.xForY(r, y);
				ctx.moveTo(-x, s * y);
				ctx.lineTo(x, s * y);
			}
		}

		// Set attributes
		ctx.lineWidth = 15;
		ctx.lineCap = "round";
		ctx.strokeStyle = "rgba(200, 200, 200, 0.75)";

		// Draw lines
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.MacularThickening.prototype.groupDescription = function() {
	return "Macular thickening ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.MacularThickening.prototype.description = function() {
	return this.locationRelativeToFovea();
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Macular hole
 *
 * @class Malyugin
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Malyugin = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Malyugin";

	// Saved parameters
	this.savedParameterArray = ['scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Malyugin.prototype = new ED.Doodle;
ED.Malyugin.prototype.constructor = ED.Malyugin;
ED.Malyugin.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Malyugin.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Rotate, false);
}

/**
 * Sets default properties
 */
ED.Malyugin.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = true;
	this.isUnique = true;
}

/**
 * Sets default parameters
 */
ED.Malyugin.prototype.setParameterDefaults = function() {
	this.setRotationWithDisplacements(25, 90);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Malyugin.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Malyugin.superclass.draw.call(this, _point);

	// If iris there, take account of pupil size
	var doodle = this.drawing.lastDoodleOfClass("AntSeg");
	if (doodle) length = -doodle.apexY;

	// Half side length and radius of ring
	var l = 300;
	var r = 40;


	// Fudge factors to make ring look close to pupil margin
	var j1 = Math.PI/6;
	var j2 = Math.PI/12;

	// If iris there, take account of pupil size
	var doodle = this.drawing.lastDoodleOfClass("AntSeg");
	if (doodle) {
		var pr = -doodle.apexY;
		//l = pr - r/2;
		l = pr;
	}

	// Boundary path
	ctx.beginPath();

	// Ring (for icon)
	/*
	ctx.moveTo(-l + r,-l);
	ctx.lineTo(l - r, -l);
	ctx.arc(l - r, -l + r, r, -Math.PI/2, Math.PI * 1.5, false);
	ctx.moveTo(l, -l + r);
	ctx.lineTo(l, l - r);
	ctx.arc(l - r, l - r, r, 0, Math.PI * 2, false);
	ctx.moveTo(l - r, l);
	ctx.lineTo(-l + r, l);
	ctx.arc(-l + r, l - r, r, Math.PI/2, Math.PI * 2.5, false);
	ctx.moveTo(-l, l - r);
	ctx.lineTo(-l, -l + r);
	ctx.arc(-l + r, -l + r, r, Math.PI, Math.PI * 3, false);
	*/

	var p = new ED.Point(l, 0);
	var a = Math.PI/4;
	var b = Math.PI/4;

	ctx.moveTo(p.x, p.y);
	p.setWithPolars(l, a);
 	ctx.arc(p.x, p.y, r, 0 - b + j1, 0 - 3 * b - j2, true);

 	p.setCoordinates(0, -l);
 	ctx.moveTo(p.x, p.y);
 	a = a - Math.PI/2;
 	p.setWithPolars(l, a);
	ctx.arc(p.x, p.y, r, 0 - 3 * b + j1, 0 - 5 * b - j2, true);

	p.setCoordinates(-l, 0);
 	ctx.moveTo(p.x, p.y);
 	a = a - Math.PI/2;
 	p.setWithPolars(l, a);
	ctx.arc(p.x, p.y, r, 0 - 5 * b + j1, 0 - 7 * b - j2, true);

	p.setCoordinates(0, l);
 	ctx.moveTo(p.x, p.y);
 	a = a - Math.PI/2;
 	p.setWithPolars(l, a);
	ctx.arc(p.x, p.y, r, 0 - 7 * b + j1, 0 - 9 * b - j2, true);

	// Set line attributes
	ctx.lineWidth = 8;
	ctx.fillStyle = "rgba(255,255,255,0)";
	ctx.strokeStyle = "blue";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	point = new ED.Point(l, 0);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Malyugin.prototype.description = function() {
	return "Malyugin ring";
}


/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.Malyugin.prototype.snomedCode = function() {
	//return 232006002;
}


/**
 * OpenEyes
 *
 * (C) OpenEyes Foundation, 2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Marginal Keratitis
 *
 * @class MarginalKeratitis
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.MarginalKeratitis = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "MarginalKeratitis";
	this.epithelialDefectPercent = 90;

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation','epithelialDefectPercent'];
	
	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {
		'epithelialDefectPercent':"% Epithelial defect of corneal infiltrate"
	};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.MarginalKeratitis.prototype = new ED.Doodle;
ED.MarginalKeratitis.prototype.constructor = ED.MarginalKeratitis;
ED.MarginalKeratitis.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.MarginalKeratitis.prototype.setHandles = function() {
	this.handleArray[1] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);	
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
}

/**
 * Sets default dragging attributes
 */
ED.MarginalKeratitis.prototype.setPropertyDefaults = function() {
	// Create ranges to constrain handles
	this.handleVectorRangeArray = new Array();
	var range = new Object;
	range.length = new ED.Range(380, +495);
	range.angle = new ED.Range(0, 2*Math.PI);
	this.handleVectorRangeArray[0] = range;

	
	this.isMoveable = false;
	this.isUnique = false;
	this.isFilled = false;
	
	// Add complete validation arrays for derived parameters
	this.parameterValidationArray.epithelialDefectPercent = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(0, 100),
		animate: false
	};

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-375, -226);
// 	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 6, Math.PI);
}

/**
 * Sets default parameters
 */
ED.MarginalKeratitis.prototype.setParameterDefaults = function() {
	this.apexY = -340;
	this.arc = 45 * Math.PI / 180;
	
	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// defining outer handle
	var point = new ED.Point(0, -420);
	this.squiggleArray[0].addPoint(point);
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @param {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.MarginalKeratitis.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = {},
		returnValue;

	switch (_parameter) {
		
		// constrain handles to only move in the X plane
		case 'handles':
			this.squiggleArray[0].pointsArray[this.draggingHandleIndex].x = 0;
			break;
	}

	return returnArray;
};


/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.MarginalKeratitis.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RRD.superclass.draw.call(this, _point);


	// Calculate parameters for arcs
    // position of outer handle
	var rOuter = Math.abs(this.squiggleArray[0].pointsArray[0].y);
	var r = 380;
	var rInner = Math.abs(this.apexY);
	
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of corners of arcs
	var topRightX = rOuter * Math.sin(theta);
	var topRightY = -rOuter * Math.cos(theta);
	var topLeftX = -rOuter * Math.sin(theta);
	var topLeftY = topRightY;
	
	var midRightX = r * Math.sin(theta);
	var midRightY = -r * Math.cos(theta);
	var midLeftX = -r * Math.sin(theta);
	var midLeftY = midRightY;
	
	var bottomRightX = rInner * Math.sin(theta);
	var bottomRightY = -rInner * Math.cos(theta);
	var bottomLeftX = -rInner * Math.sin(theta);
	var bottomLeftY = bottomRightY;

	// Boundary path
	ctx.beginPath();

	// Outer arc - inflammation
	ctx.arc(0, 0, rOuter, arcStart, arcEnd, true);
	
	// Inner arc - opacity
	ctx.arc(0, 0, rInner, arcEnd, arcStart, false);
	
	// Set line attributes - invisible boundary
	ctx.strokeStyle = "rgba(255,255,255,0)";


	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
		// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// inflammation
		ctx.beginPath();
		ctx.arc(0, 0, rOuter, arcStart, arcEnd, true);
		ctx.arc(0, 0, r, arcEnd, arcStart, false);
		var ptrn = ctx.createPattern(this.drawing.imageArray['NewVesselPattern'], 'repeat');
		ctx.fillStyle = ptrn;
		ctx.fill();
		var gradient = ctx.createRadialGradient(0, 0, r, 0, 0, rOuter);
		gradient.addColorStop(0, 'red');           
		gradient.addColorStop(1, 'rgba(255,255,255,0)');
		ctx.fillStyle = gradient;
		ctx.fill();
		ctx.closePath();
		
		// corneal infiltrate
		ctx.beginPath();
		ctx.arc(0, 0, r, arcStart, arcEnd, true);
		ctx.arc(0, 0, rInner, arcEnd, arcStart, false);
		ctx.fillStyle = "gray";
		ctx.strokeStyle = "gray";
		ctx.fill();
		ctx.stroke();
		ctx.closePath();
		
		// epithelial defect
		var phi = this.epithelialDefectPercent / 100 * this.arc / 2;
		var arcStartE = -Math.PI / 2 + phi;
		var arcEndE = -Math.PI / 2 - phi;
		
		var infiltrateDepth = r - rInner;
		var epithelialDepth = infiltrateDepth * this.epithelialDefectPercent / 100;
		var rEpi = r - epithelialDepth;
		var epiRightX = rEpi * Math.sin(phi);
		var epiRightY = -rEpi * Math.cos(phi);
		var epiLeftX = -rEpi * Math.sin(phi);
		var epiLeftY = epiRightY;
		ctx.beginPath();
		ctx.arc(0, 0, r, arcStartE, arcEndE, true);
		ctx.arc(0, 0, rEpi, arcEndE, arcStartE, false);
		ctx.fillStyle = "green";
		ctx.fill();
		ctx.closePath();		
	}


	// Coordinates of handles (in canvas plane)
	this.handleArray[1].location = this.transform.transformPoint(new ED.Point(midLeftX, midLeftY));
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(midRightX, midRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));	
	this.handleArray[0].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[0]);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}


/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.MarginalKeratitis.prototype.description = function() {
	return "Marginal keratitis";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * MattressSuture
 *
 * @class MattressSuture
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.MattressSuture = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "MattressSuture";

	// Saved parameters
	this.savedParameterArray = ['radius', 'rotation'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.MattressSuture.prototype = new ED.Doodle;
ED.MattressSuture.prototype.constructor = ED.MattressSuture;
ED.MattressSuture.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.MattressSuture.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
}

/**
 * Sets default parameters
 */
ED.MattressSuture.prototype.setParameterDefaults = function() {
	this.radius = 374;
	this.setRotationWithDisplacements(10, 20);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.MattressSuture.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.MattressSuture.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	var r = this.radius;
	ctx.rect(-40, -(r + 40), 80, 80);

	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = "rgba(255,255,255,0.0)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "rgba(120,120,120,0.0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();
		ctx.moveTo(-40, -(r + 40));
		ctx.lineTo(40, -(r + 40));
		ctx.lineTo(-40, -(r - 40));
		ctx.lineTo(40, -(r - 40));
		ctx.lineTo(-40, -(r + 40));

		ctx.lineWidth = 2;
		ctx.strokeStyle = "rgba(0,0,120,0.7)";
		ctx.closePath();

		ctx.stroke();
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.MattressSuture.prototype.description = function() {
	var returnString = "Mattress suture at ";

	returnString += this.clockHour() + " o'clock";

	return returnString;
}

/**
 * OpenEyes
 *
 * (C) OpenEyes Foundation, 2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Metallic Foreign Body
 *
 * @class MetallicForeignBody
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.MetallicForeignBody = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "MetallicForeignBody";

	// Private parameters used in bound sideview doodle
	this.mfb = true;
	this.coats = false;
	this.rustRing = false;
	this.h = 30;
	this.fb=1;
	
	// Saved parameters
	this.savedParameterArray = ['originX','originY','scaleX', 'scaleY','mfb','coats','rustRing','h'];

	this.controlParameterArray = {
		'mfb':'Metallic foreign body',
		'rustRing':'Rust ring',
		'coats':'Coats ring'
	};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.MetallicForeignBody.prototype = new ED.Doodle;
ED.MetallicForeignBody.prototype.constructor = ED.MetallicForeignBody;
ED.MetallicForeignBody.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.MetallicForeignBody.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default dragging attributes
 */
ED.MetallicForeignBody.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;
	this.isUnique = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+1, +2.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+1, +2.5);
	
	
	this.parameterValidationArray['mfb'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
	
	this.parameterValidationArray['coats'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
	
	this.parameterValidationArray['rustRing'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
	
	this.parameterValidationArray['h'] = {
		kind: 'derived',
		type: 'int',
		animate: false
	};
	this.parameterValidationArray['fb'] = {
		kind: 'other',
		type: 'int',
		range: [0,1],
		animate: false
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.MetallicForeignBody.prototype.setParameterDefaults = function() {
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @param {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.MetallicForeignBody.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = {},
		returnValue;

	switch (_parameter) {
		case 'coats':
			if (_value==true) {
				returnArray.rustRing = false;
				returnArray.mfb = false;
			}
			break;
			
		case 'scaleX':
			returnArray.h = Math.round(_value * 30);
			break;
			
		case 'mfb':
			if (_value == true) returnArray['fb'] = 1;
			else if (_value == false) returnArray['fb'] = 0;
			break;
						
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.MetallicForeignBody.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.MetallicForeignBody.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Invisible boundary
	var r = 30;
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		if (this.mfb) {
			ctx.beginPath()
			ctx.arc(0,0,r*0.8,0,2*Math.PI,true);
			ctx.fillStyle = "brown";
			ctx.fill();
		}
		
		if (this.rustRing) {
			ctx.beginPath()
			ctx.arc(0,0,r*1.05,0,2*Math.PI,true);
			ctx.lineWidth = 8;
			ctx.strokeStyle = "brown";
			ctx.stroke();
		}
		
		if (this.coats) {
			ctx.beginPath()
			ctx.arc(0,0,r,0,2*Math.PI,true);
			ctx.lineWidth = 12;
			ctx.strokeStyle = "rgba(180,180,180,1)";
			ctx.stroke();
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(r, -r));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * (C) OpenEyes Foundation, 2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Metallic Foreign Body Cross Section
 *
 * @class MetallicForeignBodyCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.MetallicForeignBodyCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "MetallicForeignBodyCrossSection";
	
	// Derived parameters
	this.fb = 1;
	this.h = 30;

	this.point = new ED.Point(0,0);	
	
	// Saved parameters
	this.savedParameterArray = ['originX','originY','h','fb'];
	
	// Parameters in doodle control bar
	this.controlParameterArray = {};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.MetallicForeignBodyCrossSection.prototype = new ED.Doodle;
ED.MetallicForeignBodyCrossSection.prototype.constructor = ED.MetallicForeignBodyCrossSection;
ED.MetallicForeignBodyCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.MetallicForeignBodyCrossSection.prototype.setHandles = function() {
}

/**
 * Sets default properties
 */
ED.MetallicForeignBodyCrossSection.prototype.setPropertyDefaults = function() {
	this.isUnique = false;
	this.isRotatable = false;
		
	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(0, +108);
	
	this.parameterValidationArray['h'] = {
		kind: 'other',
		type: 'int',
		range: [0,1080],
		animate: true
	};
	
	this.parameterValidationArray['fb'] = {
		kind: 'other',
		type: 'int',
		range: [0,1],
		animate: false
	};

}

/**
 * Sets default parameters
 */
ED.MetallicForeignBodyCrossSection.prototype.setParameterDefaults = function() {
	this.originX = 0;
	this.originY = 0;
	
	this.defineBezier();
	
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @param {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.MetallicForeignBodyCrossSection.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = {},
		returnValue;

	switch (_parameter) {
		case 'originY':
			// recalculate point for drawing
			this.defineBezier();
			break;
			
		case 'originX':
			// recalculate point for drawing
			this.defineBezier();
			break;
						
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.MetallicForeignBodyCrossSection.prototype.draw = function(_point) {
	
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.MetallicForeignBodyCrossSection.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// calculate direction to point
	var o = new ED.Point(251,-this.originY);
	angle = o.direction() + 0.5*Math.PI;
				
	// draw ellipse
	var r = 30;
	ctx.ellipse(this.point.x, this.point.y, 0.5*this.h, this.h, angle, 0, 2*Math.PI, true);		
		
	
	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "brown";

	// Draw boundary path (also hit testing)
	if (this.fb==1) this.drawBoundary(_point);
		
	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {

	}
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
	
}


ED.MetallicForeignBodyCrossSection.prototype.defineBezier = function(_point) {	
	
	var xDisplacement = this.originX;
	
	var cornea = this.drawing.lastDoodleOfClass('CorneaCrossSection');
	var cornealThickness = cornea.pachymetry/5;
	
	var tP = (this.originY + 380) / 760;
	
	var bezier = new Object;
	
	if (this.originY<0) {
		// superior bezier
		if (cornea && cornea.shape == "Keratoconus") {			
			bezier.SP = new ED.Point(-120 - this.originX, -380 - this.originY);
			bezier.CP1 = new ED.Point(-240 - this.originX, -260 - this.originY);
			bezier.CP2 = new ED.Point(cornea.apexX - this.originX, cornea.apexY - 100 - this.originY);
			bezier.EP = new ED.Point(cornea.apexX - this.originX, cornea.apexY - this.originY);
		}
		else if (cornea && cornea.shape == "Keratoglobus") {
			bezier.SP = new ED.Point(-120 - this.originX, -380 - this.originY);
			bezier.CP1 = new ED.Point(-240 - this.originX, -260 - this.originY);
			bezier.CP2 = new ED.Point(-380 - this.originX, -100 - this.originY);
			bezier.EP = new ED.Point(-380 - this.originX, 100 - this.originY);
		}
		else {			
			bezier.SP = new ED.Point(-120 - this.originX + 50, -380 - this.originY);
			bezier.CP1 = new ED.Point(-240 - this.originX + 50, -260 - this.originY);
			bezier.CP2 = new ED.Point(-320 - this.originX + 50, -160 - this.originY);
			bezier.EP = new ED.Point(-320 - this.originX + 50, 0 - this.originY);
		}
		
		tP = tP*2;
	}
	else {
		// inferior bezier
		if (cornea && cornea.shape == "Keratoconus") {			
			bezier.SP = new ED.Point(cornea.apexX - this.originX, cornea.apexY - this.originY);
			bezier.CP1 = new ED.Point(cornea.apexX - this.originX, cornea.apexY + 100 - this.originY);
			bezier.CP2 = new ED.Point(-240 - this.originX, 260 - this.originY);
			bezier.EP = new ED.Point(-120 - this.originX, 380 - this.originY);
		}
		else if (cornea && cornea.shape == "Keratoglobus") {
			bezier.SP = new ED.Point(-380 - this.originX - 50, 100 - this.originY);
			bezier.CP1 = new ED.Point(-380 - this.originX - 50, 200 - this.originY);
			bezier.CP2 = new ED.Point(-240 - this.originX - 50, 360 - this.originY);
			bezier.EP = new ED.Point(-120 - this.originX - 50, 380 - this.originY);
		}
		else {			
			bezier.SP = new ED.Point(-320- this.originX + 50, -0 - this.originY);
			bezier.CP1 = new ED.Point(-320- this.originX + 50, 160 - this.originY);
			bezier.CP2 = new ED.Point(-240 - this.originX + 50, 260 - this.originY);
			bezier.EP = new ED.Point(-120 - this.originX + 50, 380 - this.originY);
		}
		
		tP = (tP-0.5) * 2
	}
	
	// get point on bezier
	this.point.x = xDisplacement + (1-tP)*(1-tP)*(1-tP)*bezier.SP.x + 3*(1-tP)*(1-tP)*tP*bezier.CP1.x + 3*(1-tP)*tP*tP*bezier.CP2.x + tP*tP*tP*bezier.EP.x;
	this.point.y = (1-tP)*(1-tP)*(1-tP)*bezier.SP.y + 3*(1-tP)*(1-tP)*tP*bezier.CP1.y + 3*(1-tP)*tP*tP*bezier.CP2.y + tP*tP*tP*bezier.EP.y;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Microaneurysm
 *
 * @class Microaneurysm
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Microaneurysm = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Microaneurysm";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Microaneurysm.prototype = new ED.Doodle;
ED.Microaneurysm.prototype.constructor = ED.Microaneurysm;
ED.Microaneurysm.superclass = ED.Doodle.prototype;

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Microaneurysm.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(50, 30);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Microaneurysm.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Microaneurysm.superclass.draw.call(this, _point);

	// Microaneurysm radius
	var r = 14;

	// Boundary path
	ctx.beginPath();

	// Microaneurysm
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 1;
	ctx.strokeStyle = "red";
	ctx.fillStyle = "red";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.Microaneurysm.prototype.groupDescription = function() {
	return "Microaneurysms";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Multifocal Choroiditis
 *
 * @class MultifocalChoroiditis
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.MultifocalChoroiditis = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "MultifocalChoroiditis";

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.MultifocalChoroiditis.prototype = new ED.Doodle;
ED.MultifocalChoroiditis.prototype.constructor = ED.MultifocalChoroiditis;
ED.MultifocalChoroiditis.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.MultifocalChoroiditis.prototype.setPropertyDefaults = function() {
	this.addAtBack = true;
	this.isUnique = true;
	this.isMoveable = false;
	this.isRotatable = false;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.MultifocalChoroiditis.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.MultifocalChoroiditis.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	var rb = 480;

	// Invisible boundary - matches fundus
	ctx.arc(0, 0, rb, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes (NB Note strokeStyle in order to get a highlight when selected
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(255, 255, 0, 1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// PRP spot data
		var sr = 15;
		var si = 30;
		var ss = 48;
		var rs = rb * 0.9;
		var nr = 12;
		var nd = 3
// 		var sd = (2 * sr + si);
// 		var st = 10;

		// Draw spots
		for (var i = 0; i < nr; i++) {
			var theta = i * 2 * Math.PI/nr;

			for (var j = 0; j < nd; j++) {
				var r = (0.5 + j) * rs/nd;
				var p = new ED.Point(0,0);
				p.setWithPolars(r, theta);

				var dis = 80;
				var xd = (ED.randomArray[i + j] - 0.5) * dis;
				var yd = (ED.randomArray[nr * nd + i + j] - 0.5) * dis;
				this.drawCircle(ctx, p.x + xd, p.y + yd, sr, "Yellow", 3, "rgba(255, 128, 0, 1)");
			}
		}
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.MultifocalChoroiditis.prototype.description = function() {
	return "Panretinal photocoagulation";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Chandelier (single)
 *
 * @class Needle
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Needle = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Needle";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Needle.prototype = new ED.Doodle;
ED.Needle.prototype.constructor = ED.Needle;
ED.Needle.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Needle.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Rotate, false);
}

/**
 * Sets default dragging attributes
 */
ED.Needle.prototype.setPropertyDefaults = function() {
}

/**
 * Sets default parameters
 */
ED.Needle.prototype.setParameterDefaults = function() {
	this.scaleX = 0.5
	this.scaleY = 0.5
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Needle.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Needle.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Hub
	var y = -250;
	ctx.moveTo(-80, y);
	ctx.lineTo(80, y);
	ctx.lineTo(70, y + 30);
	ctx.lineTo(50, y + 240);
	ctx.lineTo(20, y + 260);
	ctx.lineTo(-20, y + 260);
	ctx.lineTo(-50, y + 240);
	ctx.lineTo(-70, y + 30);
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgba(0, 0, 0, 1)";

	ctx.fillStyle = "rgba(255, 127, 0, 1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {

		var a = 250;

		// Hub top
		ctx.beginPath();
		ctx.moveTo(-70, y + 30);
		ctx.lineTo(70, y + 30);
		ctx.lineWidth = 1;
		ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
		ctx.stroke();

		// Ridge
		ctx.beginPath();
		ctx.moveTo(-60, y + 130);
		ctx.lineTo(60, y + 130);
		ctx.lineWidth = 1;
		ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
		ctx.stroke();

		// Flange
		ctx.beginPath();
		ctx.moveTo(0, y + 130);
		ctx.lineTo(0, y + 230);
		ctx.lineWidth = 32;
		ctx.strokeStyle = "rgba(120, 120, 120, 0.2)";
		ctx.stroke();

		// White bit
		ctx.beginPath();
		ctx.moveTo(50, y + 240);
		ctx.lineTo(20, y + 260);
		ctx.lineTo(-20, y + 260);
		ctx.lineTo(-50, y + 240);
		ctx.closePath();
		ctx.lineWidth = 1;
		ctx.fillStyle = "rgba(255, 255, 255, 1)";
		ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
		ctx.fill();
		ctx.stroke();

		// Shaft and tip
		ctx.beginPath();
		ctx.moveTo(-10, y + 260);
		ctx.lineTo(+10, y + 260);
		ctx.lineTo(+10, a + 30);
		ctx.lineTo(-10, a);
		ctx.closePath();
		ctx.fillStyle = "rgba(120, 120, 120, 1)";
		ctx.fill();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(0, y));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Needle.prototype.description = function() {
	return "Needle";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Nerve Fibre Defect
 *
 * @class NerveFibreDefect
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.NerveFibreDefect = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "NerveFibreDefect";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.NerveFibreDefect.prototype = new ED.Doodle;
ED.NerveFibreDefect.prototype.constructor = ED.NerveFibreDefect;
ED.NerveFibreDefect.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.NerveFibreDefect.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.NerveFibreDefect.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-560, -400);
}

/**
 * Sets default parameters
 */
ED.NerveFibreDefect.prototype.setParameterDefaults = function() {
	this.arc = 20 * Math.PI / 180;
	this.apexY = -460;

	this.setRotationWithDisplacements(150, -120);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.NerveFibreDefect.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.NerveFibreDefect.superclass.draw.call(this, _point);

	// Radius of outer curve
	var ro = -this.apexY;
	var ri = 360;
	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of NerveFibreDefect
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(200, 200, 200, 0.75)";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.NerveFibreDefect.prototype.groupDescription = function() {
	return "Nerve fibre layer defect at ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.NerveFibreDefect.prototype.description = function() {
	return this.clockHour() + " o'clock";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Nuclear cataract
 *
 * @class NuclearCataract
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.NuclearCataract = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "NuclearCataract";

	// Derived parameters
	this.grade = 'Mild';

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.NuclearCataract.prototype = new ED.Doodle;
ED.NuclearCataract.prototype.constructor = ED.NuclearCataract;
ED.NuclearCataract.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.NuclearCataract.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.NuclearCataract.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isRotatable = false;
	this.isUnique = true;
	this.parentClass = "Lens";
	this.inFrontOfClassArray = ["Lens", "PostSubcapCataract" ];
	this.addAtBack = true;

	// Update validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-120, +0);
	this.parameterValidationArray['originX']['range'].setMinAndMax(-500, +500);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-500, +500);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['grade'] = {
		kind: 'derived',
		type: 'string',
		list: ['Mild', 'Moderate', 'Brunescent'],
		animate: true
	};
}

/**
 * Sets default parameters
 */
ED.NuclearCataract.prototype.setParameterDefaults = function() {
	this.setParameterFromString('grade', 'Mild');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.NuclearCataract.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			if (_value < -80) returnArray['grade'] = 'Mild';
			else if (_value < -40) returnArray['grade'] = 'Moderate';
			else returnArray['grade'] = 'Brunescent';
			break;

		case 'grade':
			switch (_value) {
				case 'Mild':
					returnArray['apexY'] = -120;
					break;
				case 'Moderate':
					returnArray['apexY'] = -80;
					break;
				case 'Brunescent':
					returnArray['apexY'] = +0;
					break;
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.NuclearCataract.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.NuclearCataract.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// NuclearCataract
	ctx.arc(0, 0, 200, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;

	// Colors for gradient
	yellowColour = "rgba(255, 255, 0, 0.75)";
	var brownColour = "rgba(" + Math.round(120 - this.apexY) + ", " + Math.round(60 - this.apexY) + ", 0, 0.75)";

	// Radial gradient
	var gradient = ctx.createRadialGradient(0, 0, 210, 0, 0, 50);
	gradient.addColorStop(0, yellowColour);
	gradient.addColorStop(1, brownColour);

	ctx.fillStyle = gradient;
	ctx.strokeStyle = "rgba(0,0,0,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.NuclearCataract.prototype.description = function() {
	return this.getParameter('grade') + " nuclear cataract";
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.NuclearCataract.prototype.snomedCode = function() {
	return 53889007;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.NuclearCataract.prototype.diagnosticHierarchy = function() {
	return 3;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Nuclear Cataract Cross Section ***TODO***
 *
 * @class NuclearCataractCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.NuclearCataractCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "NuclearCataractCrossSection";

	// Derived parameters
	this.grade = 'Mild';

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.NuclearCataractCrossSection.prototype = new ED.Doodle;
ED.NuclearCataractCrossSection.prototype.constructor = ED.NuclearCataractCrossSection;
ED.NuclearCataractCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.NuclearCataractCrossSection.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.NuclearCataractCrossSection.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isRotatable = false;
	this.isUnique = true;
	this.parentClass = "LensCrossSection";
	this.inFrontOfClassArray = ["LensCrossSection", "NuclearCataractCrossSection"];

	// Update validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(+100, +100);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-180, -20);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['grade'] = {
		kind: 'derived',
		type: 'string',
		list: ['Mild', 'Moderate', 'Brunescent'],
		animate: true
	};
}

/**
 * Sets default parameters
 */
ED.NuclearCataractCrossSection.prototype.setParameterDefaults = function() {
	this.apexX = 100;
	this.originX = 44;
	this.setParameterFromString('grade', 'Mild');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.NuclearCataractCrossSection.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			if (_value < -80) returnArray['grade'] = 'Mild';
			else if (_value < -40) returnArray['grade'] = 'Moderate';
			else returnArray['grade'] = 'Brunescent';
			break;

		case 'grade':
			switch (_value) {
				case 'Mild':
					returnArray['apexY'] = -120;
					break;
				case 'Moderate':
					returnArray['apexY'] = -80;
					break;
				case 'Brunescent':
					returnArray['apexY'] = +0;
					break;
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.NuclearCataractCrossSection.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.NuclearCataractCrossSection.superclass.draw.call(this, _point);

	// Height of cross section (half value of ro in AntSeg doodle)
	var h = 240;

	// Arbitrary radius of curvature corresponding to nucleus in Lens subclass
	var r = 300;

	// Displacement of lens from centre
	var ld = 100;

	// Angle of arc
	var theta = Math.asin(h / r);

	// X coordinate of centre of circle
	var x = r * Math.cos(theta);

	// Measurements of nucleus
	var rn = r - 60;

	// Calculate nucleus angles
	var phi = Math.acos(x / rn);

	// Lens
	ctx.beginPath();

	// Draw lens with two sections of circumference of circle
	ctx.arc(ld - x, 0, rn, phi, -phi, true);
	ctx.arc(ld + x, 0, rn, Math.PI + phi, Math.PI - phi, true);

	// Draw it
	ctx.stroke();

	// Set line attributes
	ctx.lineWidth = 0;

	// Colors for gradient
	yellowColour = "rgba(255, 255, 0, 0.75)";
	var brownColour = "rgba(" + Math.round(120 - this.apexY) + ", " + Math.round(60 - this.apexY) + ", 0, 0.75)";

	// Radial gradient
	var gradient = ctx.createRadialGradient(ld, 0, 210, ld, 0, 50);
	gradient.addColorStop(0, yellowColour);
	gradient.addColorStop(1, brownColour);

	ctx.fillStyle = gradient;
	ctx.strokeStyle = "rgba(0,0,0,1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * The optic disc
 *
 * @class OpticDisc
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.OpticDisc = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "OpticDisc";

	// Private parameters
	this.numberOfHandles = 8;

	// Derived parameters
	this.mode = "Basic";
	this.cdRatio = '0';

	// Saved parameters
	this.savedParameterArray = ['apexY', 'mode'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.OpticDisc.prototype = new ED.Doodle;
ED.OpticDisc.prototype.constructor = ED.OpticDisc;
ED.OpticDisc.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.OpticDisc.prototype.setHandles = function() {
	// Array of handles for expert mode
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	}

	// Apex handle for basic mode
	this.handleArray[this.numberOfHandles] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.OpticDisc.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isDeletable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-320, -20);
	this.parameterValidationArray['radius']['range'].setMinAndMax(50, 290);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['mode'] = {
		kind: 'derived',
		type: 'string',
		list: ['Basic', 'Expert'],
		animate: false
	};
	this.parameterValidationArray['cdRatio'] = {
		kind: 'derived',
		type: 'string',
		list: ['0.1', '0.2', '0.3', '0.4', '0.5', '0.6', '0.7', '0.8', '0.9', '1.0', 'No view'],
		animate: true
	};

	// Create ranges to constrain handles
	this.handleVectorRangeArray = new Array();
	for (var i = 0; i < this.numberOfHandles; i++) {
		// Full circle in radians
		var cir = 2 * Math.PI;

		// Create a range object for each handle
		var range = new Object;
		range.length = new ED.Range(+50, +290);
		range.angle = new ED.Range(((15 * cir / 16) + i * cir / 8) % cir, ((1 * cir / 16) + i * cir / 8) % cir);
		this.handleVectorRangeArray[i] = range;
	}
}

/**
 * Sets default parameters
 */
ED.OpticDisc.prototype.setParameterDefaults = function() {

	this.apexY = -150;

	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate with handles at equidistant points around circumference
	for (var i = 0; i < this.numberOfHandles; i++) {
		var point = new ED.Point(0, 0);
		point.setWithPolars(-this.apexY, i * 2 * Math.PI / this.numberOfHandles);
		this.addPointToSquiggle(point);
	}

	this.setParameterFromString('mode', 'Basic');
	this.setParameterFromString('cdRatio', '0.3');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.OpticDisc.prototype.dependentParameterValues = function(_parameter, _value) {

	var returnArray = new Array();

	switch (_parameter) {
		case 'mode':
			this.setHandleProperties();
			if (_value == 'Expert') {
				// Set points to mean
				if (this.drawing.isReady) {
					this.setMeanRadius(-this.apexY);
				}
			} else {
				// First calls to resetHandles occur prior to squiggleArray being initialised
				if (this.drawing.isReady) {
					this.resetHandles();
				}
			}
			break;

		case 'apexY':
			if (_value < -300) {
				returnArray['cdRatio'] = "No view";
			} else {
				returnArray['cdRatio'] = (-_value / 300).toFixed(1);
			}
			break;

		case 'cdRatio':
			if (_value != "No view") {
				var newValue = parseFloat(_value) * 300;
				returnArray['apexY'] = -newValue;
			} else {
				returnArray['apexY'] = -320;
			}
			break;

		case 'handles':
			// Sum distances of (vertical) control points from centre
			var sum = 0;
			sum += this.squiggleArray[0].pointsArray[0].length();
			sum += this.squiggleArray[0].pointsArray[this.numberOfHandles / 2].length();
			returnArray['apexY'] = -Math.round(sum / 2);
			var ratio = Math.round(10 * sum / (300 * 2)) / 10;
			returnArray['cdRatio'] = ratio.toFixed(1);
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.OpticDisc.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.OpticDisc.superclass.draw.call(this, _point);

	// Radius of disc
	var ro = 300;
	var ri = -this.apexY;

	// Calculate parameters for arcs
	var arcStart = 0;
	var arcEnd = 2 * Math.PI;

	// Boundary path
	ctx.beginPath();

	// Do a 360 arc
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 2;
	var ptrn = ctx.createPattern(this.drawing.imageArray['CribriformPattern'], 'repeat');
	ctx.fillStyle = ptrn;
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Begin path
		ctx.beginPath();

		// Do a 360 arc
		ctx.arc(0, 0, ro, arcStart, arcEnd, true);

		if (this.mode == "Basic") {
			// Move to inner circle
			ctx.moveTo(ri, 0);

			// Arc back the other way
			ctx.arc(0, 0, ri, arcEnd, arcStart, false);
		} else {
			// Bezier points
			var fp;
			var tp;
			var cp1;
			var cp2;

			// Angle of control point from radius line to point (this value makes path a circle Math.PI/12 for 8 points
			var phi = 2 * Math.PI / (3 * this.numberOfHandles);

			// Start curve
			ctx.moveTo(this.squiggleArray[0].pointsArray[0].x, this.squiggleArray[0].pointsArray[0].y);

			// Complete curve segments
			for (var i = 0; i < this.numberOfHandles; i++) {
				// From and to points
				fp = this.squiggleArray[0].pointsArray[i];
				var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
				tp = this.squiggleArray[0].pointsArray[toIndex];

				// Control points
				cp1 = fp.tangentialControlPoint(+phi);
				cp2 = tp.tangentialControlPoint(-phi);

				// Draw Bezier curve
				ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);
			}
		}

		ctx.closePath();

		// Set margin attributes
		var colour = new ED.Colour(0, 0, 0, 1);
		colour.setWithHexString('FFA83C'); // Taken from disc margin of a fundus photo
		ctx.fillStyle = colour.rgba();

		// Draw disc margin
		ctx.fill();

		// Disc vessels
		ctx.beginPath();

		// Vessels start on nasal side of disc
		var sign;
		if (this.drawing.eye == ED.eye.Right) {
			sign = -1;
		} else {
			sign = 1;
		}

		// Superotemporal vessel
		var startPoint = new ED.Point(0, 0);
		startPoint.setWithPolars(150, -sign * Math.PI / 2);

		var controlPoint1 = new ED.Point(0, 0);
		controlPoint1.setWithPolars(400, -sign * Math.PI / 8);
		var controlPoint2 = new ED.Point(0, 0);
		controlPoint2.setWithPolars(450, sign * Math.PI / 8);

		var endPoint = new ED.Point(0, 0);
		endPoint.setWithPolars(500, sign * Math.PI / 4);

		ctx.moveTo(startPoint.x, startPoint.y);
		ctx.bezierCurveTo(controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, endPoint.x, endPoint.y);

		// Inferotemporal vessel
		var startPoint = new ED.Point(0, 0);
		startPoint.setWithPolars(150, -sign * Math.PI / 2);

		var controlPoint1 = new ED.Point(0, 0);
		controlPoint1.setWithPolars(400, -sign * 7 * Math.PI / 8);
		var controlPoint2 = new ED.Point(0, 0);
		controlPoint2.setWithPolars(450, sign * 7 * Math.PI / 8);

		var endPoint = new ED.Point(0, 0);
		endPoint.setWithPolars(500, sign * 3 * Math.PI / 4);

		ctx.moveTo(startPoint.x, startPoint.y);
		ctx.bezierCurveTo(controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, endPoint.x, endPoint.y);

		// Superonasal vessel
		var startPoint = new ED.Point(0, 0);
		startPoint.setWithPolars(150, -sign * Math.PI / 2);

		var controlPoint1 = new ED.Point(0, 0);
		controlPoint1.setWithPolars(300, -sign * 2 * Math.PI / 8);
		var controlPoint2 = new ED.Point(0, 0);
		controlPoint2.setWithPolars(350, -sign * 5 * Math.PI / 16);

		var endPoint = new ED.Point(0, 0);
		endPoint.setWithPolars(450, -sign * 3 * Math.PI / 8);

		ctx.moveTo(startPoint.x, startPoint.y);
		ctx.bezierCurveTo(controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, endPoint.x, endPoint.y);

		// Inferonasal vessel
		var startPoint = new ED.Point(0, 0);
		startPoint.setWithPolars(150, -sign * Math.PI / 2);

		var controlPoint1 = new ED.Point(0, 0);
		controlPoint1.setWithPolars(300, -sign * 6 * Math.PI / 8);
		var controlPoint2 = new ED.Point(0, 0);
		controlPoint2.setWithPolars(350, -sign * 11 * Math.PI / 16);

		var endPoint = new ED.Point(0, 0);
		endPoint.setWithPolars(450, -sign * 5 * Math.PI / 8);

		ctx.moveTo(startPoint.x, startPoint.y);
		ctx.bezierCurveTo(controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, endPoint.x, endPoint.y);

		// Line attributes
		ctx.lineWidth = 48;
		ctx.lineCap = "round";
		ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";

		// Draw line
		ctx.stroke();

		// Obscure whole disc if no view
		if (this.cdRatio == "No view") {
			// disk to obscure disc
			ctx.beginPath();
			ctx.arc(0, 0, 400, 0, 2 * Math.PI, true);
			ctx.closePath();
			ctx.fillStyle = "gray";
			ctx.fill();
		}
	}

	// Coordinates of expert handles (in canvas plane)
	if (this.mode == "Expert") {
		for (var i = 0; i < this.numberOfHandles; i++) {
			this.handleArray[i].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[i]);
		}
	}

	// Location of apex handle
	this.handleArray[this.numberOfHandles].location = this.transform.transformPoint(new ED.Point(0, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.OpticDisc.prototype.description = function() {
	var returnString = "";

	// Expert mode
	if (this.mode == "Expert") {
		// Get mean
		var mean = this.getMeanRadius();

		// Look for notches by detecting outliers
		var notchArray = new Array();
		var inNotch = false;
		var notch;

		// Find a non-notch point to start with
		var s = 0;
		for (var i = 0; i < this.numberOfHandles; i++) {
			if (this.squiggleArray[0].pointsArray[i].length() < mean * 1.1) {
				s = i;
				break;
			}
		}

		// Iterate through points starting at a non-notch point
		for (var i = 0; i < this.numberOfHandles; i++) {
			var j = (i + s) % this.numberOfHandles;

			if (this.squiggleArray[0].pointsArray[j].length() > mean * 1.1) {
				if (!inNotch) {
					notch = new Object();
					notch.startHour = this.squiggleArray[0].pointsArray[j].clockHour();
					notch.endHour = this.squiggleArray[0].pointsArray[j].clockHour();
					inNotch = true;
				} else {
					notch.endHour = this.squiggleArray[0].pointsArray[j].clockHour();
				}
			} else {
				if (inNotch) {
					notchArray.push(notch);
					inNotch = false;
				}
			}

			// Deal with boundary condition
			if (i == this.numberOfHandles - 1) {
				if (inNotch) {
					notch.endHour = this.squiggleArray[0].pointsArray[j].clockHour();
					notchArray.push(notch);
					inNotch = false;
				}
			}
		}

		// Turn into a sensible report
		if (notchArray.length > 0) {
			var many = (notchArray.length > 1);

			returnString = many ? "Notches" : "Notch";

			for (var i = 0; i < notchArray.length; i++) {
				if (notchArray[i].startHour == notchArray[i].endHour) {
					returnString += " at " + notchArray[i].startHour;
				} else {
					returnString += " from " + notchArray[i].startHour + " to " + notchArray[i].endHour + " o'clock";
				}

				if (many && i != notchArray.length - 1) {
					returnString += ", and";
				}
			}
		} else {

			returnString = this.drawing.doodleArray.length == 1 ? "No abnormality" : "";
		}
	}
	// Basic mode
	else {
		if (this.cdRatio == "No view") {
			returnString = "No view";
		}
    if (returnString.length === 0 && this.drawing.doodleArray.length === 1) {
      returnString = "No abnormality";
    }

  }
	return returnString;
};

/**
 * Defines visibility of handles
 */
ED.OpticDisc.prototype.setHandleProperties = function() {
	// Basic mode
	if (this.mode == "Basic") {
		// Make handles invisible, except for apex handle
		for (var i = 0; i < this.numberOfHandles; i++) {
			this.handleArray[i].isVisible = false;
		}
		this.handleArray[this.numberOfHandles].isVisible = true;
	}
	// Expert mode
	else {
		// Make handles visible, except for apex handle,
		for (var i = 0; i < this.numberOfHandles; i++) {
			this.handleArray[i].isVisible = true;
		}
		this.handleArray[this.numberOfHandles].isVisible = false;
	}
}

/**
 * Returns minimum radius
 *
 * @returns {Float} Minimum radius regardless of mode
 */
ED.OpticDisc.prototype.minimumRadius = function() {
	var returnValue = 500;

	if (this.mode == "Basic") {
		returnValue = Math.abs(this.apexY);
	} else {
		// Iterate through points
		for (var i = 0; i < this.numberOfHandles; i++) {
			// Calculate minimum radius
			var radius = this.squiggleArray[0].pointsArray[i].length();

			if (radius < returnValue) {
				returnValue = radius;
			}
		}
	}

	return returnValue;
}

/**
 * Returns mean radius
 *
 * @returns {Float} Mean radius of handle points
 */
ED.OpticDisc.prototype.getMeanRadius = function() {
	// Sum distances of (vertical) control points from centre
	if (typeof(this.squiggleArray[0]) != 'undefined') {
		var sum = 0;
		for (var i = 0; i < this.numberOfHandles; i++) {
			sum += this.squiggleArray[0].pointsArray[i].length();
		}
		return sum / this.numberOfHandles;
	} else {
		return -this.apexY;
	}
}

/**
 * Sets radius of handle points
 *
 *@param {Float} _radius Value to set
 */
ED.OpticDisc.prototype.setMeanRadius = function(_radius) {
	// Get current mean
	var mean = this.getMeanRadius();

	// Go through scaling each point according to new mean
	for (var i = 0; i < this.numberOfHandles; i++) {
		// Get current length and direction
		var length = this.squiggleArray[0].pointsArray[i].length();
		var direction = this.squiggleArray[0].pointsArray[i].direction();

		// Calculate new length
		var newLength = length * _radius / mean;
		newLength = newLength > 300 ? 300 : newLength;

		// Set point
		this.squiggleArray[0].pointsArray[i].setWithPolars(newLength, direction);
	}
}

/**
 * Resets radius of handle points to equal values corresponding to c/d ratio
 */
ED.OpticDisc.prototype.resetHandles = function() {
	// Reset handles to equidistant points around circumference
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.squiggleArray[0].pointsArray[i].setWithPolars(-this.apexY, i * 2 * Math.PI / this.numberOfHandles);
	}
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * OpticDiscPit Acquired Pit of Optic Nerve (APON)
 *
 * @class OpticDiscPit
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.OpticDiscPit = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "OpticDiscPit";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.OpticDiscPit.prototype = new ED.Doodle;
ED.OpticDiscPit.prototype.constructor = ED.OpticDiscPit;
ED.OpticDiscPit.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.OpticDiscPit.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default dragging attributes
 */
ED.OpticDiscPit.prototype.setPropertyDefaults = function() {
	this.isSqueezable = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-200, +200);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-240, +240);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +3);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +3);
}

/**
 * Sets default parameters
 */
ED.OpticDiscPit.prototype.setParameterDefaults = function() {
	this.originX = 0;
	this.originY = 220;
	this.apexY = 0;
	this.scaleX = 1.5;

	// First pit at 6, second at 12, others somewhere else (won't usually be more than 2)
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		if (this.drawing.numberOfDoodlesOfClass(this.className) == 1) {
			this.originY = -220;
		}
		else {
			this.setOriginWithDisplacements(-60, -60);
		}
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.OpticDiscPit.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.OpticDiscPit.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Round hole
	var r = 80;
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Radial gradient
	var lightGray = "rgba(200, 200, 200, 0.75)";
	var darkGray = "rgba(100, 100, 100, 0.75)";
	var gradient = ctx.createRadialGradient(0, 0, r, 0, 0, 10);
	gradient.addColorStop(0, darkGray);
	gradient.addColorStop(1, lightGray);

	ctx.fillStyle = gradient;
	ctx.lineWidth = 2;
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(55, -55));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.OpticDiscPit.prototype.description = function() {
	return "Acquired pit of optic nerve";
}

/**
 * OpenEyes
 *
 * (C) OpenEyes Foundation, 2016
 *
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Outer leaf break
 *
 * @class OuterLeafBreak
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.OuterLeafBreak = function(_drawing, _parameterJSON)
{
    // Set classname
    this.className = "OuterLeafBreak";

    this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

    // Call superclass constructor
    ED.Doodle.call(this, _drawing, _parameterJSON);

}

/**
 * Sets superclass and constructor
 */
ED.OuterLeafBreak.prototype = new ED.Doodle;
ED.OuterLeafBreak.prototype.constructor = ED.OuterLeafBreak;
ED.OuterLeafBreak.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.OuterLeafBreak.prototype.setHandles = function()
{
    this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default dragging attributes
 */
ED.OuterLeafBreak.prototype.setPropertyDefaults = function()
{
    this.isSelectable = true;
    this.isOrientated = false;
    this.isScaleable = true;
    this.isSqueezable = false;
    this.isMoveable = true;
    this.isRotatable = false;
    this.rangeOfScale = new ED.Range(+0.5, +4);
    this.rangeOfArc = new ED.Range(Math.PI/6, Math.PI*2);
    this.rangeOfApexX = new ED.Range(-0, +0);
    this.rangeOfApexY = new ED.Range(-40, +30);
}

/**
 * Sets default parameters
 */
ED.OuterLeafBreak.prototype.setParameterDefaults = function()
{
    this.originX = -230;
    this.originY = 290;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.OuterLeafBreak.prototype.draw = function(_point)
{
    // Get context
    var ctx = this.drawing.context;

    // Call draw method in superclass
    ED.OuterLeafBreak.superclass.draw.call(this, _point);

    // Boundary path
    ctx.beginPath();

    // Round hole
    ctx.arc(0,0,60,0,Math.PI*2,true);

    // Close path
    ctx.closePath();

    // Set line attributes
    ctx.lineWidth = 4;
    ctx.fillStyle = "rgba(255, 140, 140, 0.75)";
    ctx.strokeStyle = "rgba(0, 255, 255, 0.75)";

    // Draw boundary path (also hit testing)
    this.drawBoundary(_point);

    // Other stuff here
    if (this.drawFunctionMode == ED.drawFunctionMode.Draw)
    {
    }

    // Coordinates of handles (in canvas plane)
    this.handleArray[2].location = this.transform.transformPoint(new ED.Point(41, -41));

    // Draw handles if selected
    if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

    // Calculate arc (Arc property not used naturally in this doodle ***TODO** more elegant method of doing this possible!)
    var centre = this.transform.transformPoint(new ED.Point(0,0));
    var oneWidthToRight = this.transform.transformPoint(new ED.Point(60,0));
    var xco = centre.x - this.drawing.canvas.width/2;
    var yco = centre.y - this.drawing.canvas.height/2;
    var radius = this.scaleX * Math.sqrt(xco * xco + yco * yco);
    var width = this.scaleX * (oneWidthToRight.x - centre.x);
    this.arc = Math.atan(width/radius);

    // Return value indicating successful hittest
    return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.OuterLeafBreak.prototype.description = function()
{
    var returnString = "";

    // Size description
    if (this.scaleX < 1) returnString = "Small ";
    if (this.scaleX > 1.5) returnString = "Large ";

    // Round hole
    returnString += "outer leaf break ";

    // Location (clockhours)
    returnString += this.clockHour() + " o'clock";

    return returnString;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 *
 *
 * @class PalpebralConjunctivitis
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PalpebralConjunctivitis = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PalpebralConjunctivitis";
	
	// Other parameters
	this.type = 'Papillary';
	this.hyperaemia = "+";
	
	// Saved parameters
	this.savedParameterArray = ['type', 'hyperaemia'];
	
	// Parameters in doodle control bar
	this.controlParameterArray = {'type':'Type', 'hyperaemia':'Hyperaemia'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PalpebralConjunctivitis.prototype = new ED.Doodle;
ED.PalpebralConjunctivitis.prototype.constructor = ED.PalpebralConjunctivitis;
ED.PalpebralConjunctivitis.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.PalpebralConjunctivitis.prototype.setPropertyDefaults = function() {
	this.isUnique = true;
	this.isMoveable = false;
	this.isRotatable = false;
	this.addAtBack = true;
	
	// Validation arrays for other parameters
	this.parameterValidationArray['type'] = {
		kind: 'other',
		type: 'string',
		list: ['Papillary', 'Follicular'],
		animate: false
	};
	this.parameterValidationArray['hyperaemia'] = {
		kind: 'other',
		type: 'string',
		list: ['+','++','+++'],
		animate: false
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.PalpebralConjunctivitis.prototype.setParameterDefaults = function() {
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PalpebralConjunctivitis.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PalpebralConjunctivitis.superclass.draw.call(this, _point);
	
	// Radius of arc
	var r = 480;
	
	// Height of arc
	var h = 700;
	
	// Start angle of arc
	var o = r - h;
	var theta = Math.asin(o/r);
	
	// Radius of plate
	var l = r * Math.cos(theta);
	
	// Draw superior plate
	ctx.moveTo(-l,o*0.5);
	ctx.arc(0,-o*0.5,r,theta,Math.PI-theta,true);
	ctx.lineTo(-l,o*0.5);
	
	// Draw inferior plate
	ctx.moveTo(-l,-o*0.5);
	ctx.arc(0,o*0.5,r,-theta,Math.PI+theta,false);
	ctx.lineTo(-l,-o*0.5);

	// Draw it
	ctx.stroke();

	// Set line attributes
	ctx.lineWidth = 4;
	var ptrn = ctx.createPattern(this.drawing.imageArray['NewVesselPattern'], 'repeat')
	ctx.fillStyle = ptrn;
	ctx.strokeStyle = "pink";

	if (this.hyperaemia == "+") ctx.filter = "opacity(10%)";
	else if (this.hyperaemia == "++") ctx.filter = "opacity(30%)";
	else if (this.hyperaemia == "+++") ctx.filter = "opacity(50%)";
	
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	ctx.filter = "none";

	// Return value indicating successful hittest
	return this.isClicked;
}


/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PalpebralConjunctivitis.prototype.description = function() {
	var returnValue = this.type + " conjunctivitis";
	
	returnValue += " with " + this.hyperaemia + " hyperaemia";

	return returnValue;
}


/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Papilloedema
 *
 * @class Papilloedema
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Papilloedema = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Papilloedema";
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Papilloedema.prototype = new ED.Doodle;
ED.Papilloedema.prototype.constructor = ED.Papilloedema;
ED.Papilloedema.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.Papilloedema.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;
	this.addAtBack = true;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Papilloedema.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Papilloedema.superclass.draw.call(this, _point);

	// Radii
	var ro = 450;
	var ri = 300;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, 0, Math.PI * 2, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, Math.PI * 2, 0, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;

	// Colors for gradient
	yellowColour = "rgba(255, 255, 0, 0.75)";
	var brownColour = "rgba(240, 140, 40, 0.75)";

	// Radial gradient
	var gradient = ctx.createRadialGradient(0, 0, ro, 0, 0, ri);
	gradient.addColorStop(0, yellowColour);
	gradient.addColorStop(1, brownColour);

	ctx.fillStyle = gradient;
	ctx.strokeStyle = "rgba(0,0,0,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Papilloedema.prototype.description = function() {
	return "Papilloedema";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Patch
 *
 * @class Patch
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Patch = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Patch";

	// Other parameters
	this.material = 'Sclera';

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'width', 'height', 'apexX', 'material'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'material':'Material'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Patch.prototype = new ED.Doodle;
ED.Patch.prototype.constructor = ED.Patch;
ED.Patch.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Patch.prototype.setHandles = function() {
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Size, false);
}

/**
 * Sets default dragging attributes
 */
ED.Patch.prototype.setPropertyDefaults = function() {
	this.isOrientated = true;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['material'] = {
		kind: 'other',
		type: 'string',
		list: ['Sclera', 'Tenons', 'Tutoplast', 'Cornea'],
		list: ['Sclera', 'Tenons', 'Tutoplast', 'Cornea'],
		animate: false
	};
}

/**
 * Sets default parameters
 */
ED.Patch.prototype.setParameterDefaults = function() {
	this.width = 200;
	this.height = 200;

	this.setParameterFromString('material', 'Sclera');
	
	// Position over tube if present
	var doodle = this.drawing.lastDoodleOfClass("Tube");
	if (doodle) {
		var isRE = (this.drawing.eye == ED.eye.Right);
		
		switch (doodle.platePosition) {
			case 'STQ':
				this.originX = isRE?-350:+350;
				this.originY = -350;
				this.rotation = (isRE?7:1) * Math.PI/4;
				break;
			case 'SNQ':
				this.originX = isRE?+350:-350;
				this.originY = -350;
				this.rotation = (isRE?1:7) * Math.PI/4;
				break;
			case 'INQ':
				this.originX = isRE?+350:-350;
				this.originY = +350;
				this.rotation = (isRE?3:5) * Math.PI/4;
				break;
			case 'ITQ':
				this.originX = isRE?-350:+350;
				this.originY = +350;
				this.rotation = (isRE?5:3) * Math.PI/4;
				break;	
		}
	}

	// Different size and position for a trabeculectomy flap
	var doodle = this.drawing.lastDoodleOfClass("TrabyFlap");
	if (doodle) {
		this.originY = -360;
		this.width = 488;
		this.height = 228;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Patch.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Patch.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();
	ctx.rect(-this.width / 2, -this.height / 2, this.width, this.height);
	ctx.closePath();

	// Colour of fill
	switch (this.material) {
		case 'Sclera':
			ctx.fillStyle = "rgba(200,200,50,0.5)";
			break;
        case 'Cornea':
        	ctx.fillStyle = "rgba(180,180,180,0.5)";
        	break;
		case 'Tenons':
			ctx.fillStyle = "rgba(200,200,200,0.5)";
			break;
		case 'Tutoplast':
			ctx.fillStyle = "rgba(230,230,230,0.5)";
			break;
	}
	ctx.strokeStyle = "rgba(120,120,120,0.5)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		var xd = this.width/2;
		var yd = this.height/2 - 10;

		// Suture knots
		this.drawSpot(ctx, -xd, -yd, 5, "blue");
		this.drawSpot(ctx, -xd, yd, 5, "blue");
		this.drawSpot(ctx, xd, -yd, 5, "blue");
		this.drawSpot(ctx, xd, yd, 5, "blue");
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(this.width / 2, -this.height / 2));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Patch.prototype.description = function() {
	return this.material + " patch";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Posterior chamber IOL
 *
 * @class PCIOL
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PCIOL = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PCIOL";

	// Other parameters
	this.fixation = 'In-the-bag';
	this.fx = 1;
    this.csOriginX = 0;

	// Saved parameters
	this.savedParameterArray = ['fixation', 'fx', 'originX', 'originY', 'rotation', 'csOriginX'];

	// Parameters in doodle control bar
	this.controlParameterArray = {'fixation':'Fixation'};

	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

	// Invariate parameters
	this.scaleX = 0.75;
	this.scaleY = 0.75;
}

/**
 * Sets superclass and constructor
 */
ED.PCIOL.prototype = new ED.Doodle;
ED.PCIOL.prototype.constructor = ED.PCIOL;
ED.PCIOL.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.PCIOL.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Rotate, false);
}

/**
 * Sets default properties
 */
ED.PCIOL.prototype.setPropertyDefaults = function() {
	this.addAtBack = true;
	this.isScaleable = false;
	this.isUnique = true;
	
	// Validation arrays for other parameters
	this.parameterValidationArray['fixation'] = {
		kind: 'derived',
		type: 'string',
		list: ['In-the-bag', 'Ciliary sulcus'],
		animate: true
	};
	this.parameterValidationArray['fx'] = {
		kind: 'other',
		type: 'int',
		range: [1, 2],
		animate: false
	};
	
	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-200, +200);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-200, +200);
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.PCIOL.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'fx':
			if (_value === 2) returnArray['fixation'] = 'Ciliary sulcus';
			else returnArray['fixation'] = 'In-the-bag';
			break;

		case 'fixation':
			switch (_value) {
				case 'In-the-bag':
					returnArray['fx'] = 1;
					break;
				case 'Ciliary sulcus':
					returnArray['fx'] = 2;
					break;
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PCIOL.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PCIOL.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Radius of IOL optic
	var r = 240;

	// Draw optic
	ctx.arc(0, 0, r, 0, Math.PI * 2, false);

	// Draw upper haptic
	ctx.moveTo(150, -190);
	ctx.bezierCurveTo(160, -200, 190, -350, 160, -380);
	ctx.bezierCurveTo(90, -440, -150, -410, -220, -370);
	ctx.bezierCurveTo(-250, -350, -260, -400, -200, -430);
	ctx.bezierCurveTo(-110, -480, 130, -470, 200, -430);
	ctx.bezierCurveTo(270, -390, 220, -140, 220, -100);

	// Draw lower haptic
	ctx.moveTo(-150, 190);
	ctx.bezierCurveTo(-160, 200, -190, 350, -160, 380);
	ctx.bezierCurveTo(-90, 440, 150, 410, 220, 370);
	ctx.bezierCurveTo(250, 350, 260, 400, 200, 430);
	ctx.bezierCurveTo(110, 480, -130, 470, -200, 430);
	ctx.bezierCurveTo(-270, 390, -220, 140, -220, 100);

	// Colour of fill is white but with transparency
	ctx.fillStyle = "rgba(255,255,255,0.75)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "darkgray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0)
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PCIOL.prototype.description = function() {
	var returnValue = "Posterior chamber IOL";
	returnValue += " (" + this.fixation + " fixation)";

	// Displacement limit
	var limit = 40;

	var displacementValue = "";

	if (this.originY < -limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += " superiorly";
	}
	if (this.originY > limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += " inferiorly";
	}
	if (this.originX < -limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += (this.drawing.eye == ED.eye.Right) ? " temporally" : " nasally";
	}
	if (this.originX > limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += (this.drawing.eye == ED.eye.Right) ? " nasally" : " temporally";
	}

	// Add displacement description
	if (displacementValue.length > 0) returnValue += " displaced" + displacementValue;

	return returnValue;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * PCIOL Cross Section ***TODO***
 *
 * @class PCIOLCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PCIOLCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PCIOLCrossSection";
	
	// Other parameters
	this.fixation = 'In-the-bag';
	this.fx = 1;
	
	// Saved parameters
	this.savedParameterArray = ['fixation', 'fx', 'originX', 'originY'];
	
	// Parameters in doodle control bar
	this.controlParameterArray = {'fixation':'Fixation'};


	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

    this.linkedDoodleParameters = {
        'PCIOL': {
            source: ['fixation', 'fx', 'originY'],
            store: [['originX', 'csOriginX']]
        }
    };
}

/**
 * Sets superclass and constructor
 */
ED.PCIOLCrossSection.prototype = new ED.Doodle;
ED.PCIOLCrossSection.prototype.constructor = ED.PCIOLCrossSection;
ED.PCIOLCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.PCIOLCrossSection.prototype.setPropertyDefaults = function() {
	this.isUnique = true;
	this.inFrontOfClassArray = ["HypopyonCrossSection", "HyphaemaCrossSection" ];
	this.addAtBack = true;

	// Validation arrays for other parameters
	this.parameterValidationArray['fixation'] = {
		kind: 'derived',
		type: 'string',
		list: ['In-the-bag', 'Ciliary sulcus'],
		animate: true
	};
	this.parameterValidationArray['fx'] = {
		kind: 'other',
		type: 'int',
		range: [1, 2],
		animate: false
	};
	
	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-150, +44);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-140, +140);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.PCIOLCrossSection.prototype.setParameterDefaults = function() {
	this.originX = 44;
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.PCIOLCrossSection.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'fx':
			if (_value === 2) returnArray['fixation'] = 'Ciliary sulcus';
			else returnArray['fixation'] = 'In-the-bag';
			break;

		case 'fixation':
			switch (_value) {
				case 'In-the-bag':
					returnArray['fx'] = 1;
					break;
				case 'Ciliary sulcus':
					returnArray['fx'] = 2;
					break;
			}
			break;
			
		case 'originX':
			var iris = this.drawing.lastDoodleOfClass('AntSegCrossSection');
			if (iris) {
				var minApexX = iris.parameterValidationArray['apexX']['range'].min;
				var maxApexX = 32 - (72 / 220) * (iris.apexY + 280) + this.originX;
				if (maxApexX < minApexX) maxApexX = minApexX;
				iris.parameterValidationArray['apexX']['range'].setMinAndMax(-40 - (140 / 220) * (iris.apexY + 280), maxApexX);
	
				// If being synced, make sensible decision about x
				if (!this.drawing.isActive) {
					var newOriginX = iris.parameterValidationArray['apexX']['range'].max;
				} else {
					var newOriginX = iris.parameterValidationArray['apexX']['range'].constrain(iris.apexX);
				}
				iris.setSimpleParameter('apexX', newOriginX);
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PCIOLCrossSection.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PCIOLCrossSection.superclass.draw.call(this, _point);

	// Height of cross section (half value of ro in AntSeg doodle)
	var h = 240;

	// Arbitrary radius of curvature
	var r = 450;

	// Displacement of lens from centre
	var ld = 100;

	// Angle of arc
	var theta = Math.asin(h / r);

	// X coordinate of centre of circle
	var x = r * Math.cos(theta);

	// Measurements of nucleus
	var rn = r - 60;

	// Calculate nucleus angles
	var phi = Math.acos(x / rn);

	// Draw lens
	ctx.beginPath();
	
	if (this.fixation == 'In-the-bag') {
		ctx.ellipse(100, 0, 160, 20, 0.5 * Math.PI, 0, 2 * Math.PI);
	}
	else {
		ctx.ellipse(50, 0, 160, 25, 0.5 * Math.PI, 0, 2 * Math.PI);
	}


	// Set line attributes
	ctx.lineWidth = 5;
	ctx.fillStyle = "rgba(255, 255, 255, 0.75)";
	ctx.strokeStyle = "#898989";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		
		var xShift = (this.fixation == 'In-the-bag') ? 0 : this.originX - 44;
		
		// Lens bag
		ctx.beginPath();
		ctx.arc(ld - x - xShift, 0 - this.originY, r, theta, -theta, true);
		ctx.arc(ld + x - xShift, 0 - this.originY, r, Math.PI + theta, Math.PI + 0.75*theta, true);
		ctx.moveTo(ld - xShift, 240 - this.originY);
		ctx.arc(ld + x - xShift, 0 - this.originY, r, Math.PI - theta, Math.PI - 0.75*theta, false);
		ctx.strokeStyle = "gray";
		ctx.lineWidth = 3;
		ctx.stroke();

		// Loops
		ctx.beginPath();
		if (this.fixation == 'In-the-bag') {	
/*
			ctx.arc(30 + 115 - this.originX, -210 - this.originY, 10, 2.2*Math.PI, 1*Math.PI, true);
			ctx.lineTo(85,-125);
			ctx.moveTo(120 - this.originX, 210 - this.originY);
			ctx.arc(25 + 115 - this.originX, 210 - this.originY, 13, 0, 1*Math.PI, false);
			ctx.moveTo(100 - this.originX, 210 - this.originY);
			ctx.lineTo(44 + 65,125);	
*/	
			ctx.ellipse(144 - 44, 0 - this.originY, 227, 20, 0.5 * Math.PI, 0.5 * Math.PI, 1.2 * Math.PI);
			ctx.moveTo(164 - 44,0 - this.originY);
			ctx.ellipse(144 - 44, 0 - this.originY, 227, 20, 0.5 * Math.PI, 1.5 * Math.PI, 0.2 * Math.PI);
		}
		else {
			ctx.arc(115 - this.originX, -350 - this.originY, 15, 0*Math.PI, 1*Math.PI, true);
			ctx.lineTo(35,-125);
			ctx.moveTo(120 - this.originX, 350 - this.originY);
			ctx.arc(115 - this.originX, 350 - this.originY, 15, 0, 1*Math.PI, false);
			ctx.moveTo(100 - this.originX, 350 - this.originY);
			ctx.lineTo(65,125);
		}
		ctx.strokeStyle = "#898989";
		ctx.lineWidth = 5;
		ctx.stroke();

		
		// Zonules
		ctx.beginPath();

		// Top zonules
		ctx.moveTo(44 - this.originX + 80, - this.originY - 349);
		ctx.lineTo(80 - xShift, -207 - this.originY);
		ctx.moveTo(44 - this.originX + 80, - this.originY - 349);
		ctx.lineTo(120 - xShift, -207 - this.originY);
		ctx.moveTo(44  - this.originX + 120, - this.originY - 349);
		ctx.lineTo(80 - xShift, -207 - this.originY);
		ctx.moveTo(44 - this.originX + 120, - this.originY - 349);
		ctx.lineTo(120 - xShift, -207 - this.originY);

		// Bottom zonules
		ctx.moveTo(44 - this.originX + 80, -this.originY + 349);
		ctx.lineTo(80 - xShift, 207 - this.originY);
		ctx.moveTo(44 - this.originX + 80, -this.originY + 349);
		ctx.lineTo(120 - xShift, 207 - this.originY);
		ctx.moveTo(44 - this.originX + 120, -this.originY + 349);
		ctx.lineTo(80 - xShift, 207 - this.originY);
		ctx.moveTo(44 - this.originX + 120, -this.originY + 349);
		ctx.lineTo(120 - xShift, 207 - this.originY);

		ctx.lineWidth = 2;
		ctx.strokeStyle = "gray";
		ctx.stroke();
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Corneal Oedema
 *
 * @class PCV
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PCV = function(_drawing, _parameterJSON) {
    // Set classname
    this.className = "PCV";

    this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

    // Call superclass constructor
    ED.Doodle.call(this, _drawing, _parameterJSON);
};

/**
 * Sets superclass and constructor
 */
ED.PCV.prototype = new ED.Doodle;
ED.PCV.prototype.constructor = ED.PCV;
ED.PCV.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.PCV.prototype.setHandles = function() {
    this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
};

/**
 * Sets default properties
 */
ED.PCV.prototype.setPropertyDefaults = function() {
    this.isRotatable = false;
    this.isUnique = true;

    this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.7);
    this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.7);

    this.parameterValidationArray['originY']['range'].setMinAndMax(-5, +5);
    this.parameterValidationArray['originX']['range'].setMinAndMax(-5 , +5);

};

ED.PCV.prototype.setParameterDefaults = function() {
    this.scaleY = 1.7;
    this.scaleX = 1.7;
};

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @param {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.PCV.prototype.dependentParameterValues = function(_parameter, _value) {

    var returnArray = [];

    var r = 175;
    switch (_parameter) {
        case 'scaleX':
        case 'scaleY':
            this.parameterValidationArray['originX']['range'].setMinAndMax(-300+(r*_value), 300-(r*_value));
            this.parameterValidationArray['originY']['range'].setMinAndMax(-300+(r*_value), 300-(r*_value));

            var newOriginY = this.parameterValidationArray['originY']['range'].constrain(this.originY);
            var newOriginX = this.parameterValidationArray['originX']['range'].constrain(this.originX);

            this.setSimpleParameter('originX', newOriginX);
            this.setSimpleParameter('originY', newOriginY);

            break;
    }

    return returnArray;
};

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PCV.prototype.draw = function(_point) {

    // Get context
    var ctx = this.drawing.context;

    // Call draw method in superclass
    ED.PCV.superclass.draw.call(this, _point);

    // Boundary path
    ctx.beginPath();

    // Invisible boundary
    var r = 200;
    ctx.arc(0, 0, r, 0, Math.PI * 2, true);

    // Set line attributes
    ctx.lineWidth = 0;
    ctx.fillStyle = "rgba(0, 0, 0, 0)";
    ctx.strokeStyle = "rgba(0, 0, 0, 0)";
    ctx.closePath();

    this.drawBoundary(_point);


    // Non boundary paths
    if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {

        var angle = Math.PI / 180;
        var angles = [33, 64 , 121, 153, 200, 232, 305, 338];
        var blood_color = 'rgba(188, 25, 0, 1)';

        ctx.beginPath();
        for (var i = 0; i < 8; i++) {
            var blob = new ED.Point(0, 0);
            blob.setWithPolars(155, angle * angles[i]);
            this.drawSpot(ctx, blob.x, blob.y, 20, blood_color);

            ctx.moveTo(0,0);
            //Bezier Curve to draw squiggly blood vessels - maybe later
            ctx.bezierCurveTo(0,0,0,0,blob.x, blob.y);
            ctx.lineWidth = 5;
            ctx.strokeStyle = blood_color;
            ctx.stroke();
        }
        ctx.closePath();
        ctx.beginPath();

        ctx.fillStyle = blood_color;
        ctx.ellipse(0,0, 85,70, 0, 0, 360);
        ctx.fill();
    }


    // Coordinates of handles (in canvas plane)
    this.handleArray[2].location = this.transform.transformPoint(new ED.Point(r * 0.7, -r * 0.7));

    // Draw handles if selected
    if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

    // Return value indicating successful hittest
    return this.isClicked;
};

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PCV.prototype.description = function() {
    return "";
};
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Peripapillary atrophy
 *
 * @class PeripapillaryAtrophy
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PeripapillaryAtrophy = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PeripapillaryAtrophy";

	// Private parameters
	this.outerRadius = 340;

	// Saved parameters
	this.savedParameterArray = ['rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PeripapillaryAtrophy.prototype = new ED.Doodle;
ED.PeripapillaryAtrophy.prototype.constructor = ED.PeripapillaryAtrophy;
ED.PeripapillaryAtrophy.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.PeripapillaryAtrophy.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	this.handleArray[1] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
}

/**
 * Sets default dragging attributes
 */
ED.PeripapillaryAtrophy.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.addAtBack = true;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['rotation']['range'].setMinAndMax(7 * Math.PI / 4, Math.PI / 4);

	// Create ranges to constrain handles
	this.handleCoordinateRangeArray = new Array();

	var max = this.outerRadius * 1.4;
	var min = this.outerRadius;
	this.handleCoordinateRangeArray[0] = {
		x: new ED.Range(-max, -min),
		y: new ED.Range(-0, +0)
	};
	this.handleCoordinateRangeArray[1] = {
		x: new ED.Range(-0, +0),
		y: new ED.Range(-max, -min)
	};
	this.handleCoordinateRangeArray[2] = {
		x: new ED.Range(min, max),
		y: new ED.Range(-0, +0)
	};
	this.handleCoordinateRangeArray[3] = {
		x: new ED.Range(-0, +0),
		y: new ED.Range(min, max)
	};
}

/**
 * Sets default parameters
 */
ED.PeripapillaryAtrophy.prototype.setParameterDefaults = function() {
	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Add four points to the squiggle
	this.addPointToSquiggle(new ED.Point(-this.outerRadius - (this.drawing.eye == ED.eye.Right ? 100 : 0), 0));
	this.addPointToSquiggle(new ED.Point(0, -this.outerRadius));
	this.addPointToSquiggle(new ED.Point(this.outerRadius + (this.drawing.eye == ED.eye.Right ? 0 : 100), 0));
	this.addPointToSquiggle(new ED.Point(0, this.outerRadius));
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PeripapillaryAtrophy.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PeripapillaryAtrophy.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// PeripapillaryAtrophy
	var f = 0.55; // Gives a circular bezier curve
	var fromX;
	var fromY;
	var toX;
	var toY;

	// Top left curve
	fromX = this.squiggleArray[0].pointsArray[0].x;
	fromY = this.squiggleArray[0].pointsArray[0].y;
	toX = this.squiggleArray[0].pointsArray[1].x;
	toY = this.squiggleArray[0].pointsArray[1].y;
	ctx.moveTo(fromX, fromY);
	ctx.bezierCurveTo(fromX, fromX * f, toY * f, toY, toX, toY);

	// Top right curve
	fromX = toX;
	fromY = toY;
	toX = this.squiggleArray[0].pointsArray[2].x;
	toY = this.squiggleArray[0].pointsArray[2].y;
	ctx.bezierCurveTo(-fromY * f, fromY, toX, -toX * f, toX, toY);

	// Bottom right curve
	fromX = toX;
	fromY = toY;
	toX = this.squiggleArray[0].pointsArray[3].x;
	toY = this.squiggleArray[0].pointsArray[3].y;
	ctx.bezierCurveTo(fromX, fromX * f, toY * f, toY, toX, toY);

	// Bottom left curve
	fromX = toX;
	fromY = toY;
	toX = this.squiggleArray[0].pointsArray[0].x;
	toY = this.squiggleArray[0].pointsArray[0].y;
	ctx.bezierCurveTo(-fromY * f, fromY, toX, -toX * f, toX, toY);

	// Only fill to margin, to allow cup to sit behind giving disc margin
	ctx.moveTo(280, 00);
	ctx.arc(0, 0, 280, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 2;
	var colour = new ED.Colour(0, 0, 0, 1);
	colour.setWithHexString('DFD989');
	ctx.fillStyle = colour.rgba();
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[0]);
	this.handleArray[1].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[1]);
	this.handleArray[2].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[2]);
	this.handleArray[3].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[3]);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PeripapillaryAtrophy.prototype.description = function() {
	var returnString = "";

	// Get distances of control points from centre
	var left = -this.squiggleArray[0].pointsArray[0].x;
	var top = -this.squiggleArray[0].pointsArray[1].y;
	var right = this.squiggleArray[0].pointsArray[2].x;
	var bottom = this.squiggleArray[0].pointsArray[3].y;

	// Get maximum control point, and its sector
	var sector = "";
	var max = this.radius;
	if (left > max) {
		max = left;
		sector = (this.drawing.eye == ED.eye.Right) ? "temporally" : "nasally";
	}
	if (top > max) {
		max = top;
		sector = "superiorly";
	}
	if (right > max) {
		max = right;
		sector = (this.drawing.eye == ED.eye.Right) ? "nasally" : "temporally";
	}
	if (bottom > max) {
		max = bottom;
		sector = "inferiorly";
	}

	// Grade degree of atrophy
	if (max > this.radius) {
		var degree = "Mild";
		if (max > 350) degree = "Moderate";
		if (max > 400) degree = "Signficant";
		returnString += degree;
		returnString += " peri-papillary atrophy, maximum ";
		returnString += sector;
	}

	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Peripheral retinectomy
 *
 * @class PeripheralRetinectomy
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PeripheralRetinectomy = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PeripheralRetinectomy";

	// Private parameter
	this.extent = "";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PeripheralRetinectomy.prototype = new ED.Doodle;
ED.PeripheralRetinectomy.prototype.constructor = ED.PeripheralRetinectomy;
ED.PeripheralRetinectomy.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.PeripheralRetinectomy.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.PeripheralRetinectomy.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 4, 2 * Math.PI);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-450, -350);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.PeripheralRetinectomy.prototype.setParameterDefaults = function() {
	this.arc = 240 * Math.PI / 180;
	this.apexY = -380;

	// If more than one, rotate it a bit to distinguish it
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		this.rotation = doodle.rotation + Math.PI / 4;
	} else {
		this.rotation = Math.PI;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PeripheralRetinectomy.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PeripheralRetinectomy.superclass.draw.call(this, _point);

	// Radius of outer curve just inside ora on right and left fundus diagrams
	var ro = 952 / 2;
	var ri = -this.apexY;
	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of PeripheralRetinectomy
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255,255,0,0)";
	ctx.strokeStyle = "rgba(255,0,255,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Path for retinectomy
		ctx.beginPath();

		// Unless 360, curve out from the ora
		if (this.arc < 1.95 * Math.PI) {
			// Angle to determine curve
			var phi1 = theta - Math.PI / 24;
			var phi2 = theta - 2 * Math.PI / 24;

			// Right points
			var rsp = new ED.Point(ro * Math.sin(theta), -ro * Math.cos(theta));
			var rcp1 = new ED.Point(r * Math.sin(theta), -r * Math.cos(theta));
			var rcp2 = new ED.Point(ri * Math.sin(phi1), -ri * Math.cos(phi1));
			var rep = new ED.Point(ri * Math.sin(phi2), -ri * Math.cos(phi2));

			// Inner arc
			arcStart = -Math.PI / 2 + phi2;
			arcEnd = -Math.PI / 2 - phi2;

			// Left points
			var lsp = new ED.Point(-ri * Math.sin(phi2), -ri * Math.cos(phi2));
			var lcp1 = new ED.Point(-ri * Math.sin(phi1), -ri * Math.cos(phi1));
			var lcp2 = new ED.Point(-r * Math.sin(theta), -r * Math.cos(theta));
			var lep = new ED.Point(-ro * Math.sin(theta), -ro * Math.cos(theta));

			// Path
			ctx.moveTo(rsp.x, rsp.y);
			ctx.bezierCurveTo(rcp1.x, rcp1.y, rcp2.x, rcp2.y, rep.x, rep.y);
			ctx.arc(0, 0, ri, arcStart, arcEnd, true);
			ctx.bezierCurveTo(lcp1.x, lcp1.y, lcp2.x, lcp2.y, lep.x, lep.y)

			// Angle to nearest 10 degrees.
			var degrees = Math.floor(this.arc * 18 / Math.PI) * 10;

			this.extent = "Retinectomy of " + degrees + " degrees centred at " + this.clockHour() + " o'clock";
		} else {
			// Just a circl to represent a 360 degree retinectomy
			ctx.arc(0, 0, ri, 0, 2 * Math.PI, true);

			// Description text
			this.extent = "360 degree retinectomy";
		}

		// Draw retinectomy
		ctx.lineWidth = 16;
		ctx.strokeStyle = "red";
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PeripheralRetinectomy.prototype.description = function() {
	return this.extent;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Peripheral RRD
 *
 * @class PeripheralRRD
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PeripheralRRD = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PeripheralRRD";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PeripheralRRD.prototype = new ED.Doodle;
ED.PeripheralRRD.prototype.constructor = ED.PeripheralRRD;
ED.PeripheralRRD.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.PeripheralRRD.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.PeripheralRRD.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 4, 2 * Math.PI);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-400, -300);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.PeripheralRRD.prototype.setParameterDefaults = function() {
	this.arc = 112 * Math.PI / 180;
	this.apexY = -380;

	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		if (this.drawing.eye == ED.eye.Right) {

		}
	} else {
		if (this.drawing.eye == ED.eye.Right) {
			this.rotation = -0.8 * Math.PI;
		} else {
			this.rotation = 0.8 * Math.PI;
		}
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PeripheralRRD.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PeripheralRRD.superclass.draw.call(this, _point);

	// Radius of outer curve just inside ora on right and left fundus diagrams
	var ro = 952 / 2;
	var ri = -this.apexY;
	var r = ri + (ro - ri) / 2;

	// Radius of quarter circle
	var rc = ro - ri;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of PeripheralRRD
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Centre of first quarter circle
	var c1 = new ED.Point(0, 0);
	c1.x = -ro * Math.sin(theta - rc / ro);
	c1.y = -ro * Math.cos(theta - rc / ro);

	// Centre of second quarter circle
	var c2 = new ED.Point(0, 0);
	c2.x = -ro * Math.sin(-theta + rc / ro);
	c2.y = -ro * Math.cos(-theta + rc / ro);

	// Boundary path
	ctx.beginPath();

	// Arc from right to left
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc round first quarter circle (slightly less than 90 degrees)
	var phi = arcEnd - Math.PI / 2;
	ctx.arc(c1.x, c1.y, rc, phi, phi - Math.PI / 2 + rc / ro, true);

	// Arc back to the right
	ctx.arc(0, 0, ri, c1.direction() - Math.PI / 2, c2.direction() - Math.PI / 2, false);

	// Arc round second quarter circle (slightly less than 90 degrees)
	phi = arcStart + Math.PI / 2;
	ctx.arc(c2.x, c2.y, rc, phi + Math.PI / 2 - rc / ro, phi, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(0, 0, 255, 0.75)";
	ctx.strokeStyle = "blue";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.PeripheralRRD.prototype.snomedCode = function() {
	return 232008001;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.PeripheralRRD.prototype.diagnosticHierarchy = function() {
	return 8;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * PhakoIncision
 *
 * @class PhakoIncision
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PhakoIncision = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PhakoIncision";

	// Private parameters
	this.defaultRadius = 330;
	this.sutureSeparation = 1.5;
	//this.apexYDelta = _radius + _apexY;

	// Derived parameters
	//this.incisionLength = (_arc * Math.PI / 180) * (6 * _radius) / this.defaultRadius;
	this.incisionSite = 'Corneal';
	this.incisionType = 'Pocket';
	this.incisionMeridian = 0;

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation', 'radius'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

	this.apexYDelta = this.radius + this.apexY;
};

/**
 * Sets superclass and constructor
 */
ED.PhakoIncision.prototype = new ED.Doodle;
ED.PhakoIncision.prototype.constructor = ED.PhakoIncision;
ED.PhakoIncision.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.PhakoIncision.prototype.setHandles = function() {
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
};

/**
 * Sets default properties
 */
ED.PhakoIncision.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = true;
	this.isArcSymmetrical = true;

	// Update validation array for simple parameters
	this.parameterValidationArray['radius']['range'].setMinAndMax(250, 450);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['incisionMeridian'] = {
		kind: 'derived',
		type: 'mod',
		range: new ED.Range(0, 360),
		clock: 'bottom',
		animate: true
	};
	this.parameterValidationArray['incisionLength'] = {
		kind: 'derived',
		type: 'float',
		range: new ED.Range(1, 9.9),
		precision: 1,
		animate: true
	};
	this.parameterValidationArray['incisionSite'] = {
		kind: 'derived',
		type: 'string',
		list: ['Corneal', 'Limbal', 'Scleral'],
		animate: true
	};
	this.parameterValidationArray['incisionType'] = {
		kind: 'derived',
		type: 'string',
		list: ['Pocket', 'Section'],
		animate: false
	};
};

/**
 * Sets default parameters (only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.PhakoIncision.prototype.setParameterDefaults = function() {
	this.setParameterFromString('incisionSite', 'Corneal');
	this.setParameterFromString('incisionLength', '3.5');
	this.setParameterFromString('incisionType', 'Pocket');

	// Default is temporal side, or 90 degrees to the last one
	this.setRotationWithDisplacements(90, -90);
};

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @param {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.PhakoIncision.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = {};

	switch (_parameter) {
		case 'rotation':
			var angle = (((Math.PI * 2 - _value + Math.PI / 2) * 180 / Math.PI) + 360) % 360;
			if (angle == 360) {
				angle = 0;
			}
			returnArray['incisionMeridian'] = angle;
			//  returnArray['arc'] = _value/2;
			break;

		case 'arc':
			returnArray['incisionLength'] = _value * (6 * this.radius) / this.defaultRadius;
			break;

		case 'radius':
			if (_value >= 428) {
			  returnArray['incisionSite'] = 'Scleral';
      } else if (_value >= 344) {
			  returnArray['incisionSite'] = 'Limbal';
      } else {
			  returnArray['incisionSite'] = 'Corneal';
      }

			// Incision length should remain constant despite changes in radius
			returnArray['arc'] = this.incisionLength * this.defaultRadius / (6 * _value);
			this.updateArcRange();

			// Move apexY as radius changes and adjust range
			returnArray['apexY'] = this.apexYDelta - _value;
			this.parameterValidationArray['apexY']['range'].setMinAndMax(-_value, -_value + 34);
			break;

		case 'apexY':
			returnArray['apexYDelta'] = this.radius + _value;
			returnArray['incisionType'] = this.radius + _value > 0 ? 'Section' : 'Pocket';
			break;

			// Incision Meridian (CND 5.15)
		case 'incisionMeridian':
			returnArray['rotation'] = (((90 - _value) + 360) % 360) * Math.PI / 180;
			// Example of animating two simple parameters simultaneously
			//returnArray['arc'] = (1 + _value/90) * Math.PI/12;
			break;

			// Incision length (CND 5.14)
		case 'incisionLength':
			returnArray['arc'] = _value * this.defaultRadius / (6 * this.radius);
			this.updateArcRange();
			break;

			// Incision site (CND 5.13)
		case 'incisionSite':
			switch (_value) {
				case 'Scleral':
					returnArray['radius'] = +428;
					break;
				case 'Limbal':
					returnArray['radius'] = +376;
					break;
				case 'Corneal':
					returnArray['radius'] = +330;
					break;
			}
			break;

		case 'incisionType':
			switch (_value) {
				case 'Pocket':
					returnArray['apexYDelta'] = +0;
					returnArray['apexY'] = -this.radius;
					break;
				case 'Section':
					returnArray['apexYDelta'] = +34;
					returnArray['apexY'] = +34 - this.radius;
					break;
			}
	}

	return returnArray;
};

/**
 * Private method to update range of arc parameter to account for values changing with radius and incisionSite
 */
ED.PhakoIncision.prototype.updateArcRange = function() {
	if (this.radius > 0) {
		this.parameterValidationArray['arc']['range'].min = this.parameterValidationArray['incisionLength']['range'].min * this.defaultRadius / (6 * this.radius);
		this.parameterValidationArray['arc']['range'].max = this.parameterValidationArray['incisionLength']['range'].max * this.defaultRadius / (6 * this.radius);
	} else {
		ED.errorHandler('ED.PhakoIncision', 'updateArcRange', 'Attempt to calculate a range of arc using an illegal value of radius: ' + this.radius);
	}
};

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PhakoIncision.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PhakoIncision.superclass.draw.call(this, _point);

	// Radii
	var r = this.radius;
	var d = 40;
	var ro = r + d;
	var ri = r - d;

	// Boundary path
	ctx.beginPath();

	// Half angle of arc
	var theta = this.arc / 2;

	// Arc across
	ctx.arc(0, 0, ro, -Math.PI / 2 + theta, -Math.PI / 2 - theta, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, -Math.PI / 2 - theta, -Math.PI / 2 + theta, false);

	// Close path
	ctx.closePath();

	// Pocket
	if (this.apexYDelta == 0) {
		// Colour of fill
		ctx.fillStyle = "rgba(200,200,200,0.75)";

		// Set line attributes
		ctx.lineWidth = 4;

		// Colour of outer line is dark gray
		ctx.strokeStyle = "rgba(120,120,120,0.75)";
	}
	// Section with sutures
	else {
		// Colour of fill
		ctx.fillStyle = "rgba(200,200,200,0)";

		// Set line attributes
		ctx.lineWidth = 4;

		// Colour of outer line is dark gray
		ctx.strokeStyle = "rgba(120,120,120,0)";
	}

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Section with sutures
		if (this.apexYDelta != 0) {
			// New path
			ctx.beginPath();

			// Arc across
			ctx.arc(0, 0, r, -Math.PI / 2 + theta, -Math.PI / 2 - theta, true);

			// Sutures
			var sutureSeparationAngle = this.sutureSeparation * this.defaultRadius / (6 * this.radius);
			var p = new ED.Point(0, 0);
			var phi = theta - sutureSeparationAngle / 2;

			do {
				p.setWithPolars(r - d, phi);
				ctx.moveTo(p.x, p.y);
				p.setWithPolars(r + d, phi);
				ctx.lineTo(p.x, p.y);

				phi = phi - sutureSeparationAngle;
			} while (phi > -theta);

			// Set line attributes
			ctx.lineWidth = 4;

			// Colour of outer line is dark gray
			ctx.strokeStyle = "rgba(120,120,120,0.75)";

			// Draw incision
			ctx.stroke();
		}

	}

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, theta);
	this.handleArray[3].location = this.transform.transformPoint(point);
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
};

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PhakoIncision.prototype.description = function() {
	var returnString = "";

	// Incision site
	if (this.radius > 428) {
		returnString = 'Scleral ';
	} else if (this.radius > 344) {
		returnString = 'Limbal ';
	} else {
		returnString = 'Corneal ';
	}

	// Incision type
	if(this.incisionType){
		returnString += this.incisionType.toLowerCase() + " ";
	} else {
		returnString += this.apexY + this.radius == 0 ? "pocket " : "section ";
	}

	returnString += "incision at ";
	returnString += this.clockHour() + " o'clock";

	return returnString;
};

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Peripheral iridectomy
 *
 * @class PI
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PI = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PI";

	// Derived parameters
	this.type = 'Surgical';
	this.patent = true;

	// Saved parameters
	this.savedParameterArray = ['rotation', 'type', 'patent'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'type':'Type', 'patent':'Patent'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PI.prototype = new ED.Doodle;
ED.PI.prototype.constructor = ED.PI;
ED.PI.superclass = ED.Doodle.prototype;

/**
 * Sets default properties
 */
ED.PI.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['type'] = {
		kind: 'derived',
		type: 'string',
		list: ['Surgical', 'Laser'],
		animate: false
	};
	this.parameterValidationArray['patent'] = {
		kind: 'derived',
		type: 'bool',
		display: false
	};
}

/**
 * Sets default parameters
 */
ED.PI.prototype.setParameterDefaults = function() {
	this.setRotationWithDisplacements(30, -30);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PI.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PI.superclass.draw.call(this, _point);

	// Outer radius
	var r = 360;

	// Boundary path
	ctx.beginPath();
	switch (this.type) {
		case 'Surgical':
			var phi = Math.PI / 24;
			ctx.arc(0, 0, r, -phi - Math.PI / 2, phi - Math.PI / 2, false);
			ctx.lineTo(0, -r * 0.8);
			ctx.closePath();
			break;
		case 'Laser':
			ctx.arc(0, -r * 0.9, 36, 0, Math.PI * 2, true);
			break;
	}

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "rgba(120,120,120,0.75)";;

	// Colour of fill
	if (this.patent) ctx.fillStyle = "rgba(255,255,255,1)";
	else ctx.fillStyle = "rgba(150,150,150,1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PI.prototype.description = function() {
	return "Peripheral iridectomy at " + this.clockHour() + " o'clock";
}

/**
 * OpenEyes
 *
 * (C) OpenEyes Foundation, 2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Pingueculum
 *
 * @class Pingueculum
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Pingueculum = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Pingueculum";

	// Derived parameters

	// Saved parameters
	this.savedParameterArray = ['arc','rotation'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Pingueculum.prototype = new ED.Doodle;
ED.Pingueculum.prototype.constructor = ED.Pingueculum;
ED.Pingueculum.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Pingueculum.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}


/**
 * Sets default dragging attributes
 */
ED.Pingueculum.prototype.setPropertyDefaults = function() {
	this.isUnique = false;
	this.isMoveable = false;
	this.isRotatable = false;
	
	this.parameterValidationArray['arc']['range'].setMinAndMax(0.75*Math.PI, 1.25*Math.PI);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Pingueculum.prototype.setParameterDefaults = function() {
	this.arc = 180 * Math.PI / 180;
	this.setRotationWithDisplacements(0, 180);
	if (this.rotation>0.5*Math.PI) this.rotation = Math.PI;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Pingueculum.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Pingueculum.superclass.draw.call(this, _point);

	//Set variables used to draw pingueculum
	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var outerR = 460;
	var xPos = outerR * Math.sin(theta); // x start coordinate
	var yPos = -outerR * Math.cos(theta); // y start coordinate

	var r = 38; // radius of circles used for pingueculum


	// Boundary path
	// Draw circle around pingueculum
	ctx.beginPath();
	ctx.arc(xPos, yPos, 2*r, 0, 2 * Math.PI, true);
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "rgba(255, 255, 255, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {

		//Draw pingueculum:
		ctx.fillStyle = 'yellow'; //Set pingueculum colour

		//Draw 3 circles around start point
		ctx.beginPath();
		ctx.arc(xPos - r, yPos - 0.5*r, r, 0, Math.PI * 2, false);
		ctx.fill();
		ctx.beginPath();
		ctx.arc(xPos - r, yPos + 0.5*r, r, 0, Math.PI * 2, false);
		ctx.fill();
		ctx.beginPath();
		ctx.arc(xPos, yPos, r, 0, Math.PI * 2, false);
		ctx.fill();
	}

	// Set handle position
	var topRightX = outerR * Math.sin(theta);
	var topRightY = -outerR * Math.cos(theta);
	var topLeftX = -outerR * Math.sin(theta);
	var topLeftY = topRightY;
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Pingueculum.prototype.description = function() {
	var returnValue = "Pingueculum";
	return returnValue;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Corneal Oedema
 *
 * @class PosteriorCapsularOpacity
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PosteriorCapsularOpacity = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PosteriorCapsularOpacity";

	// Private parameters
	this.numberOfHandles = 4;
	this.initialRadius = 360;

	// Derived parameters
	this.intensity = 'Mild';

	// Other parameters
	this.stromal = false;
	this.epithelial = false;
	this.endothelial = false;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexX', 'apexY', 'rotation', 'intensity', 'stromal', 'epithelial', 'endothelial'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'intensity':'Intensity',  'epithelial':'Epithelial', 'stromal':'Stromal','endothelial':'Endothelial'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PosteriorCapsularOpacity.prototype = new ED.Doodle;
ED.PosteriorCapsularOpacity.prototype.constructor = ED.PosteriorCapsularOpacity;
ED.PosteriorCapsularOpacity.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.PosteriorCapsularOpacity.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
	// Array of handles
// 	for (var i = 0; i < this.numberOfHandles; i++) {
// 		this.handleArray[i] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
// 	}
}

/**
 * Sets default properties
 */
ED.PosteriorCapsularOpacity.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-380, -80);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['intensity'] = {
		kind: 'derived',
		type: 'string',
		list: ['Mild', 'Moderate', 'Severe'],
		animate: false
	};
	this.parameterValidationArray['stromal'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['epithelial'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['endothelial'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};

	/*
	// Create ranges to constrain handles
	this.handleVectorRangeArray = new Array();
	for (var i = 0; i < this.numberOfHandles; i++) {
		// Full circle in radians
		var cir = 2 * Math.PI;

		// Create a range object for each handle
		var n = this.numberOfHandles;
		var range = new Object;
		range.length = new ED.Range(+50, +380);
		range.angle = new ED.Range((((2 * n - 1) * cir / (2 * n)) + i * cir / n) % cir, ((1 * cir / (2 * n)) + i * cir / n) % cir);
		this.handleVectorRangeArray[i] = range;
	}
	*/
}

/**
 * Sets default parameters
 */
ED.PosteriorCapsularOpacity.prototype.setParameterDefaults = function() {
	this.apexY = -this.initialRadius;
	this.setParameterFromString('stromal', 'false');
	this.setParameterFromString('epithelial', 'false');
	this.setParameterFromString('endothelial', 'false');

	// Put control handle at 45 degrees
	this.rotation = Math.PI / 4;

/*
	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate with handles at equidistant points around circumference
	for (var i = 0; i < this.numberOfHandles; i++) {
		var point = new ED.Point(0, 0);
		point.setWithPolars(this.initialRadius, i * 2 * Math.PI / this.numberOfHandles);
		this.addPointToSquiggle(point);
	}
*/
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PosteriorCapsularOpacity.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PosteriorCapsularOpacity.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	/*
	// Bezier points
	var fp;
	var tp;
	var cp1;
	var cp2;

	// Angle of control point from radius line to point (this value makes path a circle Math.PI/12 for 8 points
	var phi = 2 * Math.PI / (3 * this.numberOfHandles);

	// Start curve
	ctx.moveTo(this.squiggleArray[0].pointsArray[0].x, this.squiggleArray[0].pointsArray[0].y);

	// Complete curve segments
	for (var i = 0; i < this.numberOfHandles; i++) {
		// From and to points
		fp = this.squiggleArray[0].pointsArray[i];
		var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
		tp = this.squiggleArray[0].pointsArray[toIndex];

		// Control points
		cp1 = fp.tangentialControlPoint(+phi);
		cp2 = tp.tangentialControlPoint(-phi);

		// Draw Bezier curve
		ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);
	}

	// Close path
	ctx.closePath();
	*/

	// Round lesion
	var r = Math.sqrt(this.apexX * this.apexX + this.apexY * this.apexY);
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Set attributes
	ctx.lineWidth = 4;
	switch (this.intensity) {
		case 'Mild':
			ctx.fillStyle = "rgba(0, 0, 255, 0.2)";
			break;
		case 'Moderate':
			ctx.fillStyle = ctx.createPattern(this.drawing.imageArray['OedemaPattern'], 'repeat');
			break;
		case 'Severe':
			ctx.fillStyle = ctx.createPattern(this.drawing.imageArray['OedemaPatternBullous'], 'repeat');
			break;
	}
	ctx.strokeStyle = ctx.fillStyle;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		if (false) {
			var ptrn = ctx.createPattern(this.drawing.imageArray['OedemaPatternBullous'], 'repeat');
			ctx.fillStyle = ptrn;
			ctx.fill();
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));
// 	for (var i = 0; i < this.numberOfHandles; i++) {
// 		this.handleArray[i].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[i]);
// 	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PosteriorCapsularOpacity.prototype.description = function() {
	return "Corneal oedema";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * PosteriorCapsule
 *
 * @class PosteriorCapsule
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PosteriorCapsule = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PosteriorCapsule";

	// Derived parameters
	this.opacity = '1';
	this.capsulotomy = 'None';

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'opacity', 'capsulotomy'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {
		'opacity':'Opacity',
		'capsulotomy':'Capsulotomy',
		};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PosteriorCapsule.prototype = new ED.Doodle;
ED.PosteriorCapsule.prototype.constructor = ED.PosteriorCapsule;
ED.PosteriorCapsule.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.PosteriorCapsule.prototype.setPropertyDefaults = function() {
	this.isUnique = true;
	this.addAtBack = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-500, +500);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-500, +500);

	this.parameterValidationArray['opacity'] = {
		kind: 'derived',
		type: 'string',
		list: ['1', '2', '3', '4'],
		animate: false
	};
	this.parameterValidationArray['capsulotomy'] = {
		kind: 'derived',
		type: 'string',
		list: ['None', 'Diamond', 'Circle'],
		animate: false
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.PosteriorCapsule.prototype.setParameterDefaults = function() {}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PosteriorCapsule.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PosteriorCapsule.superclass.draw.call(this, _point);

	// Height of cross section (half value of ro in AntSeg doodle)
	var ro = 240;

	// Boundary path
	ctx.beginPath();

	// Do a 360 arc
	ctx.arc(0, 0, ro, 0, 2 * Math.PI, true);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255, 255, 255, 0)";

	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {

		// Capsulotomy
		if (this.capsulotomy != '1') {
			ctx.beginPath();
			ctx.arc(0, 0, ro, 0, 2 * Math.PI, true);
			var ri = 140;
			ctx.moveTo(ri, 0);

			switch (this.capsulotomy) {
				case 'Diamond':
					ctx.lineTo(0, ri);
					ctx.lineTo(-ri, 0);
					ctx.lineTo(0, -ri);
					ctx.lineTo(ri, 0);
					ctx.closePath();
					break;
				case 'Circle':
					ctx.arc(0, 0, ri, 0, 2 * Math.PI, false);
					break;
			}
		}

		// Opacity
		if (this.opacity != '1') {
			// Pattern

			var ptrn = ctx.createPattern(this.drawing.imageArray['PSCPattern'], 'repeat');
			ctx.fillStyle = ptrn;
			ctx.fill();

			// Opacity
			switch (this.opacity) {
				case '2':
					ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
					break;
				case '3':
					ctx.fillStyle = "rgba(200, 200, 200, 0.5)";
					break;
				case '4':
					ctx.fillStyle = "rgba(150, 150, 150, 0.5)";
					break;
			}
			ctx.fill();
			ctx.stroke();
		}


	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PosteriorCapsule.prototype.description = function() {
	var returnValue = "";

	if (this.opacity != '1') {
		returnValue += this.opacity + " posterior capsular opacity";
	}

	switch (this.opacity) {
				case '2':
					returnValue = "Mild PCO reducing the red reflex, Elschnig pearls to the IOL edge";
					break;
				case '3':
					returnValue = "Moderate fibrosis or Elschnig pearls inside IOL edge, but with a clear visual axis";
					break;
				case '4':
					returnValue = "Severe fibrosis or Elschnig pearls covering the visual axis and severely reducing the red reflex";
					break;
	}

	if (this.capsulotomy != 'None') {
		var shape = this.capsulotomy.toLowerCase();
		returnValue += " with " + shape + " shaped capsulotomy";
	}

	return returnValue;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Posterior embryotoxon
 *
 * @class PosteriorEmbryotoxon
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PosteriorEmbryotoxon = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PosteriorEmbryotoxon";

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PosteriorEmbryotoxon.prototype = new ED.Doodle;
ED.PosteriorEmbryotoxon.prototype.constructor = ED.PosteriorEmbryotoxon;
ED.PosteriorEmbryotoxon.superclass = ED.Doodle.prototype;

/**
 * Set default properties
 */
ED.PosteriorEmbryotoxon.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PosteriorEmbryotoxon.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PosteriorEmbryotoxon.superclass.draw.call(this, _point);

	// Radius of outer curve just inside pupil edge
	var ro = 370;
	var ri = 340;

	// Calculate parameters for arcs
	var arcStart = 0;
	var arcEnd = 2 * Math.PI;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "rgba(255,255,255,0.6)";
	ctx.strokeStyle = "rgba(255,255,255,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PosteriorEmbryotoxon.prototype.description = function() {
	return "Posterior Embryotoxon";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Posterior retinectomy
 *
 * @class PosteriorRetinectomy
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PosteriorRetinectomy = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PosteriorRetinectomy";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PosteriorRetinectomy.prototype = new ED.Doodle;
ED.PosteriorRetinectomy.prototype.constructor = ED.PosteriorRetinectomy;
ED.PosteriorRetinectomy.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.PosteriorRetinectomy.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.PosteriorRetinectomy.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-200, -50);
}

/**
 * Sets default parameters
 */
ED.PosteriorRetinectomy.prototype.setParameterDefaults = function() {
	this.apexX = 0;
	this.apexY = -100;

	// Displacement from fovea, and from last doodle
	var d = 100;

	this.originX = d;
	this.originY = -d;

	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		var point = new ED.Point(doodle.originX, doodle.originY);
		var direction = point.direction() + Math.PI / 8;
		var distance = point.length();
		var np = new ED.Point(0, 0);
		np.setWithPolars(distance, direction);

		this.originX = np.x;
		this.originY = np.y;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PosteriorRetinectomy.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PosteriorRetinectomy.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Circular retinectomy
	var r = Math.sqrt(this.apexX * this.apexX + this.apexY * this.apexY);
	var w = 16;

	// Two arcs
	ctx.arc(0, 0, r + w, 0, Math.PI * 2, true);
	ctx.arc(0, 0, r - w, Math.PI * 2, 0, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 1;
	ctx.fillStyle = "rgba(255,255,0,0)";
	ctx.strokeStyle = "rgba(255,255,0,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();
		ctx.arc(0, 0, r, 0, Math.PI * 2, true);
		ctx.lineWidth = 16;
		ctx.strokeStyle = "red";
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PosteriorRetinectomy.prototype.groupDescription = function() {
	return "Posterior retinectomy";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * PosteriorSynechia
 *
 * @class PosteriorSynechia
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PosteriorSynechia = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PosteriorSynechia";

	// Derived parameters
	this.size = 150;

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PosteriorSynechia.prototype = new ED.Doodle;
ED.PosteriorSynechia.prototype.constructor = ED.PosteriorSynechia;
ED.PosteriorSynechia.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.PosteriorSynechia.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.PosteriorSynechia.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-380, -0);
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 6, Math.PI * 2 / 3);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['size'] = {
		kind: 'derived',
		type: 'float',
		range: new ED.Range(20, 100),
		precision: 1,
		animate: true
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.PosteriorSynechia.prototype.setParameterDefaults = function() {
	this.arc = Math.PI / 6;
	this.setRotationWithDisplacements(90, 45);

	var doodle = this.drawing.lastDoodleOfClass("AntSeg");
	if (doodle) {
		this.apexY = doodle.apexY + this.size;
	} else {
		this.apexY = -200;
	}
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.PosteriorSynechia.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'size':
			var doodle = this.drawing.lastDoodleOfClass("AntSeg");
			if (doodle) {
				returnArray['apexY'] = doodle.apexY - _value;
			}
			break;

		case 'apexY':
			var doodle = this.drawing.lastDoodleOfClass("AntSeg");
			if (doodle) {
				returnArray['size'] = doodle.apexY - _value;
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PosteriorSynechia.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PosteriorSynechia.superclass.draw.call(this, _point);

	// Set outer radius according to pupil
	var ro = 200;
	var iris = this.drawing.lastDoodleOfClass("AntSeg");
	if (iris) ro = -iris.apexY;

	// Outer radius is position of apex handle
	var ri = -this.apexY;

	// Radius of control points
	var rc = ri + (ro - ri) / 2;

	// Boundary path
	ctx.beginPath();

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of SectorPRPPostPole
	var startHandle = new ED.Point(-ro * Math.sin(theta), -ro * Math.cos(theta));
	var endHandle = new ED.Point(ro * Math.sin(theta), -ro * Math.cos(theta));

	// Boundary path
	ctx.beginPath();

	// Arc at margin of pupil
	ctx.arc(0, 0, ro, arcEnd, arcStart, false);

	//var cp = bp.pointAtRadiusAndClockwiseAngle(pr/2, Math.PI/16);
	var apex = new ED.Point(this.apexX, this.apexY);

	// Curve from endpoint to apex
	var cp1 = endHandle.pointAtAngleToLineToPointAtProportion(Math.PI / 12, apex, 0.33);
	var cp2 = apex.pointAtAngleToLineToPointAtProportion(-Math.PI / 12, endHandle, 0.33);
	ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, this.apexX, this.apexY);

	// Curve from apex to startpoint
	var cp3 = apex.pointAtAngleToLineToPointAtProportion(Math.PI / 12, startHandle, 0.33);
	var cp4 = startHandle.pointAtAngleToLineToPointAtProportion(-Math.PI / 12, apex, 0.33);
	ctx.bezierCurveTo(cp3.x, cp3.y, cp4.x, cp4.y, startHandle.x, startHandle.y);

	// Close path
	ctx.closePath();

	// Iris colour
	switch (iris.colour) {
		case 'Blue':
			ctx.fillStyle = "rgba(100, 200, 250, 0.5)";
			break;
		case 'Brown':
			ctx.fillStyle = "rgba(172, 100, 55, 0.5)";
			break;
		case 'Gray':
			ctx.fillStyle = "rgba(125, 132, 116, 0.5)";
			break;
		case 'Green':
			ctx.fillStyle = "rgba(114, 172, 62, 0.5)";
			break;
	}

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is transparent
	ctx.strokeStyle = "rgba(250, 250, 250, 0.0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Visual 'hack' to overwrite line with white and then same colour as pupil fill
		ctx.beginPath();
		ctx.arc(0, 0, ro, arcEnd, arcStart, false);
		ctx.lineWidth = 6;
		ctx.strokeStyle = "white";
		ctx.stroke();
		ctx.strokeStyle = ctx.fillStyle;
		ctx.stroke();

		// Re-do the boundary to match pupil edge and overlap gaps at join
		ctx.beginPath();
		ctx.moveTo(endHandle.x, endHandle.y);
		ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, this.apexX, this.apexY);
		ctx.bezierCurveTo(cp3.x, cp3.y, cp4.x, cp4.y, startHandle.x, startHandle.y);
		ctx.lineWidth = 4;
		ctx.strokeStyle = "gray";
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(startHandle);
	this.handleArray[3].location = this.transform.transformPoint(endHandle);
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.PosteriorSynechia.prototype.groupDescription = function() {
	return "Posterior synechiae at ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PosteriorSynechia.prototype.description = function() {
	return this.clockHour() + " o'clock";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * PostPole template with disc and arcades
 *
 * @class PostPole
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PostPole = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PostPole";

	// Private parameters
	this.discRadius = 84;

	// Derived parameters
	this.cdRatio = '0';

	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PostPole.prototype = new ED.Doodle;
ED.PostPole.prototype.constructor = ED.PostPole;
ED.PostPole.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.PostPole.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.PostPole.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameterss
	var apexX = this.drawing.eye == ED.eye.Right ? 300 : -300;
	this.parameterValidationArray['apexX']['range'].setMinAndMax(apexX, apexX);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-80, -8);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['cdRatio'] = {
		kind: 'derived',
		type: 'float',
		range: new ED.Range(0, 1),
		precision: 1,
		animate: false
	};

	// Slow down ApexY animation for this doodle (small scope)
	this.parameterValidationArray['apexY']['delta'] = 5;
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.PostPole.prototype.setParameterDefaults = function() {
	this.setParameterFromString('cdRatio', '0.5');
	this.apexX = this.drawing.eye == ED.eye.Right ? 300 : -300;
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.PostPole.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			returnArray['cdRatio'] = -_value / 80;
			break;

		case 'cdRatio':
			returnArray['apexY'] = -(+_value * 80);
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PostPole.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PostPole.superclass.draw.call(this, _point);

	// Disc location
	var x = this.drawing.eye == ED.eye.Right ? 300 : -300;

	// Boundary path
	ctx.beginPath();

	// Optic disc
	ctx.arc(x, 0, this.discRadius, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "rgba(249,187,76,1)";
	ctx.fillStyle = "rgba(249,187,76,1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Optic cup
		ctx.beginPath();
		ctx.arc(x, 0, -this.apexY, 2 * Math.PI, 0, false);
		ctx.fillStyle = "white";
		var ptrn = ctx.createPattern(this.drawing.imageArray['CribriformPatternSmall'], 'repeat');
		ctx.fillStyle = ptrn;
		ctx.lineWidth = 4;
		ctx.fill();
		ctx.stroke();

		// Arcades
		ctx.beginPath();

		// Coordinates
		var sign = this.drawing.eye == ED.eye.Right ? 1 : -1;
		var startX = -300 * sign;
		var midX1 = -50 * sign;
		var midX2 = 300 * sign;
		var midX3 = 300 * sign;
		var endX1 = 300 * sign;
		var endX2 = 350 * sign;
		var endX3 = 400 * sign;
		var foveaX = 0;

		// Superior arcades
		ctx.moveTo(startX, -100);
		ctx.bezierCurveTo(midX1, -500, midX2, -200, midX3, -24);
		ctx.bezierCurveTo(endX1, -80, endX2, -140, endX3, -160);

		// Inferior arcades
		ctx.moveTo(endX3, 160);
		ctx.bezierCurveTo(endX2, 140, endX1, 80, midX3, 24);
		ctx.bezierCurveTo(midX2, 200, midX1, 500, startX, 100);

		// Small cross marking fovea
		var crossLength = 10;
		ctx.moveTo(foveaX, -crossLength);
		ctx.lineTo(foveaX, crossLength);
		ctx.moveTo(foveaX - crossLength, 0);
		ctx.lineTo(foveaX + crossLength, 0);

		// Draw arcades
		ctx.lineWidth = 8;
		ctx.lineCap = "round";
		ctx.strokeStyle = "red";
		ctx.stroke();

		// One disc diameter
		ctx.beginPath();
		ctx.arc(0, 0, 2 * this.discRadius, 2 * Math.PI, 0, false);
		ctx.lineWidth = 1;
		ctx.strokeStyle = "gray";
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PostPole.prototype.description = function() {
	return this.drawing.doodleArray.length == 1 ? "No abnormality" : "";
}

/**
 * Tests whether passed doodle is within a number of disc diameters of fovea
 *
 * @param {Doodle} _doodle The doodle to test
 * @param {Int} _diameters The number of disc diameters to test
 * @returns {Bool} True if doodle is within the passed number of disc diameters of fovea
 */
ED.PostPole.prototype.isWithinDiscDiametersOfFovea = function(_doodle, _diameters) {
	return (_doodle.originX * _doodle.originX + _doodle.originY * _doodle.originY) < _diameters * 4 * this.discRadius * this.discRadius;
}

/**
 * Tests whether passed doodle is within a the confines of the optic disc
 *
 * @param {Doodle} _doodle The doodle to test
 * @returns {Bool} True if doodle is within the confines of the optic disc
 */
ED.PostPole.prototype.isWithinDisc = function(_doodle) {
	// Disc location
	var x = _doodle.originX - (this.drawing.eye == ED.eye.Right ? 300 : -300);

	return (x * x + _doodle.originY * _doodle.originY) < this.discRadius * this.discRadius;
}

/**
 * Tests whether passed doodle is within a the vascular arcades
 *
 * @param {Doodle} _doodle The doodle to test
 * @returns {Bool} True if doodle is within the vascular arcades
 */
ED.PostPole.prototype.isWithinArcades = function(_doodle) {
	return (_doodle.originX * _doodle.originX + _doodle.originY * _doodle.originY) < (300 * 300);
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Posterior subcapsular cataract
 *
 * @class PostSubcapCataract
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PostSubcapCataract = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PostSubcapCataract";

	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PostSubcapCataract.prototype = new ED.Doodle;
ED.PostSubcapCataract.prototype.constructor = ED.PostSubcapCataract;
ED.PostSubcapCataract.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.PostSubcapCataract.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.PostSubcapCataract.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;
	this.parentClass = "Lens";
	this.inFrontOfClassArray = ["Lens"];
	this.addAtBack = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(+35, +100);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-100, -35);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.PostSubcapCataract.prototype.setParameterDefaults = function() {
	this.apexX = 35;
	this.apexY = 35;
	this.radius = 50;
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.PostSubcapCataract.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexX':
			returnArray['radius'] = Math.sqrt(this.apexX * this.apexX + this.apexY * this.apexY);
			break;

		case 'apexY':
			returnArray['radius'] = Math.sqrt(this.apexX * this.apexX + this.apexY * this.apexY);
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PostSubcapCataract.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PostSubcapCataract.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// PostSubcapCataract
	ctx.arc(0, 0, this.radius, 0, Math.PI * 2, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;

	// create pattern
	var ptrn = ctx.createPattern(this.drawing.imageArray['PSCPattern'], 'repeat');
	ctx.fillStyle = ptrn;

	ctx.strokeStyle = "lightgray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {}

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0)
	point.setWithPolars(this.radius, Math.PI / 4);
	this.handleArray[4].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PostSubcapCataract.prototype.description = function() {
	return "Posterior subcapsular cataract";
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.PostSubcapCataract.prototype.snomedCode = function() {
	return 315353005;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.PostSubcapCataract.prototype.diagnosticHierarchy = function() {
	return 3;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Posterior subcapsular cataract Cross Section ***TODO***
 *
 * @class PostSubcapCataractCrossSection
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PostSubcapCataractCrossSection = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PostSubcapCataractCrossSection";

	// Derived parameters
	this.grade = 'Mild';

	// Call superclass constructor
ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PostSubcapCataractCrossSection.prototype = new ED.Doodle;
ED.PostSubcapCataractCrossSection.prototype.constructor = ED.PostSubcapCataractCrossSection;
ED.PostSubcapCataractCrossSection.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.PostSubcapCataractCrossSection.prototype.setHandles = function() {
	//this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.PostSubcapCataractCrossSection.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isRotatable = false;
	this.isUnique = true;
	this.parentClass = "LensCrossSection";
	this.inFrontOfClassArray = ["LensCrossSection"];

	// Update validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-180, -20);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.PostSubcapCataractCrossSection.prototype.setParameterDefaults = function() {
	this.originX = 44;
	this.apexY = -35;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PostSubcapCataractCrossSection.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PostSubcapCataractCrossSection.superclass.draw.call(this, _point);

	// Height of cross section (half value of ro in AntSeg doodle)
	var h = 240;

	// Radius of curvature of lens
	var r = 300;

	// Displacement lens from centre
	var ld = 100;

	// Angle of arc
	var theta = Math.asin(h / r);

	// X coordinate of centre of circle
	var x = r * Math.cos(theta);

	// Radius of cataract (Just inside capsule)
	var rco = r - 10;

	// Calculate nucleus angles
	theta = Math.acos(x / rco);

	// Calculate cataract angles
	var phi = Math.asin(-this.apexY / rco);

	// Boundary path
	ctx.beginPath();

	// Draw cataract with two sections of circumference of circle
	ctx.arc(ld - x, 0, rco, -phi, phi, false);

	// Set line attributes
	ctx.lineWidth = 10;
	ctx.lineCap = 'round';
	ctx.lineJoin = 'round';
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(150,150,150,0.75)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {}

	// Coordinates of handles (in canvas plane)
	//this.handleArray[4].location = this.transform.transformPoint(new ED.Point(ld, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Pre-retinal Haemorrhage
 *
 * @class PreRetinalHaemorrhage
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PreRetinalHaemorrhage = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PreRetinalHaemorrhage";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PreRetinalHaemorrhage.prototype = new ED.Doodle;
ED.PreRetinalHaemorrhage.prototype.constructor = ED.PreRetinalHaemorrhage;
ED.PreRetinalHaemorrhage.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.PreRetinalHaemorrhage.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.PreRetinalHaemorrhage.prototype.setPropertyDefaults = function() {
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(50, 200);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +2.0);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +2.0);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.PreRetinalHaemorrhage.prototype.setParameterDefaults = function() {
	this.apexY = 200;

	this.setOriginWithDisplacements(-150, 150);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PreRetinalHaemorrhage.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PreRetinalHaemorrhage.superclass.draw.call(this, _point);

	// Dimensions of haemorrhage
	var r = 100;
	var f = 0.6;

	// Boundary path
	ctx.beginPath();

	// Haemorrhage
	ctx.moveTo(r, 0);
	ctx.lineTo(-r, 0);
	ctx.bezierCurveTo(-r * f, 0, -r * f, this.apexY, 0, this.apexY);
	ctx.bezierCurveTo(r * f, this.apexY, r * f, 0, r, 0);

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 1;
	ctx.strokeStyle = "red";
	ctx.fillStyle = "red";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {

	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(100, 0));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.PreRetinalHaemorrhage.prototype.groupDescription = function() {
	return "Pre-retinal haemorrages";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * PRP (Poterior pole)
 *
 * @class PRPPostPole
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PRPPostPole = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PRPPostPole";
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PRPPostPole.prototype = new ED.Doodle;
ED.PRPPostPole.prototype.constructor = ED.PRPPostPole;
ED.PRPPostPole.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.PRPPostPole.prototype.setPropertyDefaults = function() {
	this.addAtBack = true;
	this.isUnique = true;
	this.isMoveable = false;
	this.isRotatable = false;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PRPPostPole.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PRPPostPole.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Invisible boundary
	ctx.rect(-480, -480, 960, 960);
	var r = 320;
	ctx.moveTo(r, 0);
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes (NB Note strokeStyle in order to get a highlight when selected
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(255, 255, 255, 1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// PRP spot data
		var sr = 15;
		var si = 30;
		var ss = 48;
		var n = (1000 - 2 * ss) / (2 * sr + si);
		var sd = (2 * sr + si);
		var st = 10;

		// Draw spots
		for (var i = 0; i < n; i++) {
			for (var j = 0; j < n; j++) {
				// Calculate coordinates with a random element
				var x = -500 + ss + i * sd + Math.round((-0.5 + ED.randomArray[i + j]) * 20);
				var y = -500 + ss + j * sd + Math.round((-0.5 + ED.randomArray[i + j + 100]) * 20);

				// Avoid macula
				if ((x * x + y * y) > r * r) {
					// Avoid disc
					if (this.drawing.eye == ED.eye.Right) {
						if (!((i == 13 && (j == 6 || j == 7 || j == 8 || j == 9)) || (i == 14) && (j == 7 || j == 8))) {
							this.drawCircle(ctx, x, y, sr, "Yellow", st, "rgba(255, 128, 0, 1)");
						}
					} else {
						if (!((i == 2 && (j == 6 || j == 7 || j == 8 || j == 9)) || (i == 1) && (j == 7 || j == 8))) {
							this.drawCircle(ctx, x, y, sr, "Yellow", st, "rgba(255, 128, 0, 1)");
						}
					}
				}
			}
		}
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PRPPostPole.prototype.description = function() {
	return "Panretinal photocoagulation";
}

/**
 * Pterygium
 *
 * @class Pterygium
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Pterygium = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Pterygium";
	
	this.plane = 0;
	
	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation','injection','stockersLine'];
	
	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {
		'injection':'Injection',
		'stockersLine':"Stocker's line"
	};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Pterygium.prototype = new ED.Doodle;
ED.Pterygium.prototype.constructor = ED.Pterygium;
ED.Pterygium.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Pterygium.prototype.setHandles = function() {
	this.handleArray[1] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
	
	this.handleArray[5] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	this.handleArray[6] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
}

/**
 * Sets default dragging attributes
 */
ED.Pterygium.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isUnique = false;
	
	// Add complete validation arrays for derived parameters
	this.parameterValidationArray.injection = {
		kind: 'derived',
		type: 'string',
		list: ['+', '++', '+++'],
		animate: true
	};
	this.parameterValidationArray.stockersLine = {
		kind: 'derived',
		type: 'bool',
		display: true
	};

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-360, +100);
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 6, Math.PI);
	this.parameterValidationArray['rotation']['range'].setMinAndMax(0, 2*Math.PI);
}

/**
 * Sets default parameters
 */
ED.Pterygium.prototype.setParameterDefaults = function() {
	this.apexY = -120;
	this.arc = 60 * Math.PI / 180;

	// Default to temporal quadrant
    this.setRotationWithDisplacements(270, 180);
	if (this.rotation>Math.PI) this.rotation = 1.5*Math.PI;
	
	this.setParameterFromString('injection', '+');
	this.setParameterFromString('stockersLine', 'false');
	
	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate with handles at  points around circumference
	var point = new ED.Point(-80, -170);
	this.squiggleArray[0].pointsArray[5] = point;
	point = new ED.Point(80, -170);
	this.squiggleArray[0].pointsArray[6] = point;

}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @param {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.Pterygium.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = {},
		returnValue;

	switch (_parameter) {
		
		// insure handles y coodinate set distance away from apex
		case 'apexY':
			this.squiggleArray[0].pointsArray[5].y = _value - 50;
			this.squiggleArray[0].pointsArray[6].y = _value - 50;
			break;
			
		// constrain handles to only move in the X plane
		case 'handles':
			this.squiggleArray[0].pointsArray[this.draggingHandleIndex].y = this.apexY - 50;
			break;
	}

	return returnArray;
};


/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Pterygium.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RRD.superclass.draw.call(this, _point);

	// Fit outer curve just inside ora on right and left fundus diagrams
	var r = 470;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of corners of arc
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across from top right to to mirror image point on the other side
	ctx.arc(0, 0, r, arcStart, arcEnd, true);

	// Connect across the bottom via the apex point
	var bp = +0.4;

	// Bezier curves between handles, back to start point at bottom
	ctx.bezierCurveTo(topLeftX - 0.7*(topLeftX - this.squiggleArray[0].pointsArray[5].x), topLeftY, this.squiggleArray[0].pointsArray[5].x,this.squiggleArray[0].pointsArray[5].y, this.squiggleArray[0].pointsArray[5].x,this.squiggleArray[0].pointsArray[5].y);
	ctx.bezierCurveTo(this.squiggleArray[0].pointsArray[5].x, this.apexY, this.apexX, this.apexY, this.apexX, this.apexY);
	ctx.bezierCurveTo(this.apexX, this.apexY, this.squiggleArray[0].pointsArray[6].x, this.apexY, this.squiggleArray[0].pointsArray[6].x,this.squiggleArray[0].pointsArray[6].y);
	ctx.bezierCurveTo(this.squiggleArray[0].pointsArray[6].x,this.squiggleArray[0].pointsArray[6].y, topRightX - 0.7*(topRightX - this.squiggleArray[0].pointsArray[6].x), topRightY, topRightX, topRightY);


	// Set line attributes
	ctx.lineWidth = 4;
	
	switch (this.injection) {
		case '+':
			ctx.fillStyle = "rgba(255, 204, 204, 0.7)";
			break;
		case '++':
			ctx.fillStyle = "rgba(255, 153, 153, 0.7)";
			break;
		case '+++':
			ctx.fillStyle = "rgba(255, 102, 102, 0.7)";
			break;
	}
	
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
		// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Draw Stocker's line
		if (this.stockersLine) {
			ctx.beginPath();
			ctx.moveTo(this.squiggleArray[0].pointsArray[5].x - 20,this.squiggleArray[0].pointsArray[5].y + 20);
			ctx.bezierCurveTo(this.squiggleArray[0].pointsArray[5].x, this.apexY + 20, this.apexX, this.apexY + 20, this.apexX, this.apexY + 20);
			ctx.bezierCurveTo(this.apexX, this.apexY + 20, this.squiggleArray[0].pointsArray[6].x, this.apexY + 20, this.squiggleArray[0].pointsArray[6].x + 20,this.squiggleArray[0].pointsArray[6].y  + 20);
			ctx.strokeStyle = "brown";
			ctx.lineWidth = 8;
			ctx.stroke();
		}
		
		// Draw vessels
		var v = 6;
		var phi = this.arc/v;
		var lX = Math.abs(this.squiggleArray[0].pointsArray[5].x - this.squiggleArray[0].pointsArray[6].x);
		var xDif = lX/(v+1);

		// Start and end points of vessel
		var sp = new ED.Point(0, 0);
		var ep = new ED.Point(0, 0);
		var ap = new ED.Point(this.apexX, this.apexY);

		// Path for vessels
		ctx.beginPath();

		// Radial vessels	
		for (var i = 0; i < v; i++) {
			var angle = Math.PI / 2 + phi/2 + arcEnd + i * phi;
			sp.setWithPolars(460, angle);
			
			// Go a proportion along line to apex Point
			var p = 0.8;
			ep.x = this.squiggleArray[0].pointsArray[5].x + xDif*(i+1);
// 			ep.x = sp.x + p * (ap.x - sp.x);
			ep.y = sp.y + p * (ap.y - sp.y);
			ctx.moveTo(sp.x, sp.y);
			ctx.bezierCurveTo(ep.x-0.7*(ep.x-sp.x), sp.y, ep.x, ep.y, ep.x, ep.y);
		}

		ctx.strokeStyle = "rgba(255,0,0,0.6)";
		switch (this.injection) {
		case '+':
			ctx.lineWidth = 4;
			break;
		case '++':
			ctx.lineWidth = 6;
			break;
		case '+++':
			ctx.lineWidth = 8;
			break;
	}
		
		ctx.stroke();
	}


	// Coordinates of handles (in canvas plane)
	this.handleArray[1].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));	
	this.handleArray[5].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[5]);
	this.handleArray[6].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[6]);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}


/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Pterygium.prototype.description = function() {
	
	// calculate distance between apex and visual axis
	var n = Math.sqrt((this.apexX*this.apexX) + (this.apexY*this.apexY));
	n = (n / 380 * 6).toFixed(2);
	
	var returnString = "";
	
	// If injection+++, then injected
	if (this.injection == "+++") returnString += "injected ";

	// Temrporal / nasal
	if (this.rotation>=0 && this.rotation< Math.PI) {
		if (this.drawing.eye == ED.eye.Right) returnString += "nasal ";
		else returnString += "temporal ";
	}
	else {
		if (this.drawing.eye == ED.eye.Right) returnString += "temporal ";
		else returnString += "nasal ";
	}
	
	returnString += "pterygium within " + n + "mm of visual axis";

	return returnString;
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.Pterygium.prototype.snomedCode = function() {
	return 77489003;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.Pterygium.prototype.diagnosticHierarchy = function() {
	return 4;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * PTK (Photo Therapeutic Keratectomy
 *
 * @class PTK
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.PTK = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "PTK";

	// Derived parameters
	this.diameter = 8;
	
	// Other parameters
	this.depth = 80;
	this.transepithelialTreatment = false;
	this.topographyGuidedTreatment = false;

	// Saved parameters
	this.savedParameterArray = [
		'apexX', 
		'apexY', 
		'diameter', 
		'depth',
		'transepithelialTreatment',
		'topographyGuidedTreatment' 
	];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {
		'diameter':'Diameter', 
		'depth':'Depth',
		'transepithelialTreatment':'Transepithelial',
		'topographyGuidedTreatment':'Topography guided'
	};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.PTK.prototype = new ED.Doodle;
ED.PTK.prototype.constructor = ED.PTK;
ED.PTK.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.PTK.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.PTK.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-320, -32);

	// Derived parameters
	this.parameterValidationArray['diameter'] = {
		kind: 'derived',
		type: 'float',
		range: new ED.Range(1, 10),
		precision: 1,
		animate: true
	};
	
	// Other parameters
	this.parameterValidationArray['depth'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(1, 400),
		animate: false
	};
	this.parameterValidationArray['transepithelialTreatment'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
	this.parameterValidationArray['topographyGuidedTreatment'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
}

/**
 * Sets default parameters
 */
ED.PTK.prototype.setParameterDefaults = function() {
	this.rotation = Math.PI/4;
	this.setParameterFromString('diameter', '8.0');
	this.setParameterFromString('depth', '100');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.PTK.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {

		case 'apexY':
			returnArray['diameter'] = -10 * _value/320;
			break;

		case 'diameter':
			returnArray['apexY'] = -320 * parseFloat(_value)/10;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.PTK.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.PTK.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Do an arc
	ctx.arc(0, 0, -this.apexY, 0, Math.PI * 2, true);

	// Close path to produce straight line
	ctx.closePath();

	// Create transparent fill pattern
	ctx.fillStyle = ctx.createPattern(this.drawing.imageArray['TranslucentPattern'], 'repeat');

	// Transparent stroke
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgba(100,100,100,0.9)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(this.apexX, this.apexY);
	this.handleArray[4].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.PTK.prototype.description = function() {
	var returnString = "";

	returnString = "PTK";

	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * RadialSponge
 *
 * @class RadialSponge
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RadialSponge = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RadialSponge";

	// Saved parameters
	this.savedParameterArray = ['rotation'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RadialSponge.prototype = new ED.Doodle;
ED.RadialSponge.prototype.constructor = ED.RadialSponge;
ED.RadialSponge.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.RadialSponge.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.addAtBack = true;
}

/**
 * Sets default parameters
 */
ED.RadialSponge.prototype.setParameterDefaults = function() {
	// Make rotation 30 degrees to last one of same class
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		this.rotation = doodle.rotation + Math.PI / 6;
	} else {
		this.rotation = -60 * Math.PI / 180
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RadialSponge.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RadialSponge.superclass.draw.call(this, _point);

	// Radii
	var y = -220;
	var h = 200;
	var w = 80;

	// Boundary path
	ctx.beginPath();

	ctx.moveTo(-w / 2, y);
	ctx.lineTo(-w / 2, y - h);
	ctx.lineTo(w / 2, y - h);
	ctx.lineTo(w / 2, y);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "lightgray";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		// Knot
		ctx.arc(0, y - h + 40, 5, 0, Math.PI * 2, true);
		ctx.lineTo(-20, y - h + 30);
		ctx.moveTo(0, y - h + 40);
		ctx.lineTo(20, y - h + 30);

		// Suture
		ctx.moveTo(-w / 2 - 20, y - 40);
		ctx.lineTo(-w / 2 - 20, y - h + 40);
		ctx.lineTo(w / 2 + 20, y - h + 40);
		ctx.lineTo(w / 2 + 20, y - 40);
		ctx.closePath();
		ctx.stroke();
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}


/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.RadialSponge.prototype.groupDescription = function() {
	return "Radial sponge at ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.RadialSponge.prototype.description = function() {
	// Location (clockhours)
	return this.clockHour() + " o'clock";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * A rectus muscle
 *
 * @class Rectus
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 * @constructor
 */
ED.Rectus = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Rectus";

	// Private parameters
	this.insertionY = -200;
	this.hangback = false;
	this.canTranspose = true;

	// Derived parameters
	this.recession = 0;
	this.transposition = 'None';

	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Rectus.prototype = new ED.Doodle;
ED.Rectus.prototype.constructor = ED.Rectus;
ED.Rectus.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Rectus.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.Rectus.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = false;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['recession'] = {
		kind: 'derived',
		type: 'float',
		range: new ED.Range(-12.5, 6.5),
		precision: 1,
		animate: true
	};
	this.parameterValidationArray['transposition'] = {
		kind: 'derived',
		type: 'string',
		list: ['Up', 'None', 'Down'],
		animate: true
	};
	this.parameterValidationArray['canTranspose'] = {
		kind: 'derived',
		type: 'bool',
		animate: true
	};
}

/**
 * Sets default parameters
 */
ED.Rectus.prototype.setParameterDefaults = function() {
	this.setParameterFromString('recession', '0');
	this.setParameterFromString('transposition', 'None');
	this.apexY = this.insertionY;
	this.canTranspose = true;
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.Rectus.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			returnArray['recession'] = Math.round(2 * (_value - this.insertionY) / 16) / 2;
			break;

		case 'recession':
			returnArray['apexY'] = _value * 16 + this.insertionY;
			break;

		case 'apexX':
			if (this.rotation > 0 && this.rotation < Math.PI) {
				if (_value < 0) returnArray['transposition'] = "Up";
				else if (_value > 0) returnArray['transposition'] = "Down";
				else returnArray['transposition'] = "None";
			} else {
				if (_value < 0) returnArray['transposition'] = "Down";
				else if (_value > 0) returnArray['transposition'] = "Up";
				else returnArray['transposition'] = "None";
			}
			break;

		case 'transposition':
			switch (_value) {
				case "Up":
					if (this.rotation > 0 && this.rotation < Math.PI) {
						returnArray['apexX'] = -50;
					} else {
						returnArray['apexX'] = +50;
					}
					break;
				case "Down":
					if (this.rotation > 0 && this.rotation < Math.PI) {
						returnArray['apexX'] = +50;
					} else {
						returnArray['apexX'] = -50;
					}
					break;
				case "None":
					returnArray['apexX'] = +0;
					break;
			}
			break;
	}

	// Constrain to a cross shaped path
	var cw = 15;
	if (this.apexY > this.insertionY - cw && this.apexY < this.insertionY + cw && this.canTranspose) {
		this.parameterValidationArray['apexX']['range'].setMinAndMax(-100, +100);
	} else {
		this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	}
	if (this.apexX > -cw && this.apexX < cw) {
		this.parameterValidationArray['apexY']['range'].setMinAndMax(-400, -100);
	} else {
		this.parameterValidationArray['apexY']['range'].setMinAndMax(-200, -200);
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Rectus.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Rectus.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	var muscleHalfWidth = 60;
	var startY = -450;

	// Rectus
	ctx.moveTo(-muscleHalfWidth, startY);
	ctx.lineTo(muscleHalfWidth, startY);
	ctx.lineTo(this.apexX + muscleHalfWidth, this.apexY);
	ctx.lineTo(this.apexX - muscleHalfWidth, this.apexY);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 2;
	ctx.fillStyle = "rgba(255, 140 , 80, 1)";
	ctx.strokeStyle = "rgba(255, 184, 93, 1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Indicate a recection by continuing muscle beyond insertion with different fill
		if (this.insertionY < this.apexY) {
			// x coordinate of left side of muscle at insertion
			var xi = -muscleHalfWidth + this.apexX * (this.insertionY - startY) / (this.apexY - startY);

			// Part of muscle anterior to insertion
			ctx.beginPath();
			ctx.moveTo(xi, this.insertionY);
			ctx.lineTo(xi + 2 * muscleHalfWidth, this.insertionY);
			ctx.lineTo(this.apexX + muscleHalfWidth, this.apexY);
			ctx.lineTo(this.apexX - muscleHalfWidth, this.apexY);
			ctx.closePath();

			ctx.fillStyle = "rgba(255, 220, 140, 1)";
			ctx.fill();
		}

		// Suture
		if (!(this.apexX == 0 && this.apexY == this.insertionY)) //&& this.recession() == "0.0"))
		{
			var margin = 15;
			var sutureLength = 15;
			var indent = 10;
			var bite = 20;

			// Y coordinate of muscle bite
			var ym;
			if (this.insertionY > this.apexY) {
				ym = this.apexY;
			} else {
				ym = this.insertionY;
			}

			// Y coordinate of knot
			var yk;
			if (!this.hangback && this.insertionY > this.apexY) {
				yk = this.apexY + margin;
			} else {
				yk = this.insertionY + margin;
			}

			// X coordinate
			var x = this.apexX;

			ctx.beginPath();
			ctx.moveTo(x, yk);
			ctx.lineTo(x - sutureLength, yk + sutureLength);
			ctx.moveTo(x + sutureLength, yk + sutureLength);
			ctx.lineTo(x, yk);
			ctx.arc(x, yk, 4, 0, Math.PI * 2, true);
			ctx.moveTo(x, yk);
			ctx.lineTo(x - muscleHalfWidth + indent, yk);
			ctx.lineTo(x - muscleHalfWidth + indent, ym);
			ctx.moveTo(x - muscleHalfWidth + indent, ym - margin);
			ctx.lineTo(x - muscleHalfWidth + indent + bite, ym - margin);
			ctx.moveTo(x + muscleHalfWidth - indent - bite, ym - margin);
			ctx.lineTo(x + muscleHalfWidth - indent, ym - margin);
			ctx.moveTo(x + muscleHalfWidth - indent, ym);
			ctx.lineTo(x + muscleHalfWidth - indent, yk);
			ctx.lineTo(x, yk);

			ctx.lineWidth = 4;
			ctx.strokeStyle = "black";
			ctx.stroke();
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Sector PRP
 *
 * @class RetinalArteryOcclusionPostPole
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RetinalArteryOcclusionPostPole = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RetinalArteryOcclusionPostPole";

	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY', 'arc', 'rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RetinalArteryOcclusionPostPole.prototype = new ED.Doodle;
ED.RetinalArteryOcclusionPostPole.prototype.constructor = ED.RetinalArteryOcclusionPostPole;
ED.RetinalArteryOcclusionPostPole.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.RetinalArteryOcclusionPostPole.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.RetinalArteryOcclusionPostPole.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 6, Math.PI * 2);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-200, -30);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.RetinalArteryOcclusionPostPole.prototype.setParameterDefaults = function() {
	this.arc = Math.PI / 2;
	this.apexY = -100;
	this.setRotationWithDisplacements(45, 120);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RetinalArteryOcclusionPostPole.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RetinalArteryOcclusionPostPole.superclass.draw.call(this, _point);

	// Radii
	var ro = 420;
	var ri = -this.apexY;
	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of CircumferentialBuckle
	var topRightX = ro * Math.sin(theta);
	var topRightY = -ro * Math.cos(theta);
	var topLeftX = -ro * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(200,200,200,0.5)";
	ctx.strokeStyle = "rgba(200,200,200,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Cherry red spot
		if (this.apexY > -70) {
			ctx.beginPath();
			ctx.arc(0, 0, -this.apexY, 0, 2 * Math.PI, true);
			ctx.fillStyle = "rgba(200,0,0,0.5)";
			ctx.fill();
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.RetinalArteryOcclusionPostPole.prototype.description = function() {
	var returnString = "";

	// Type
	var type = this.type();
	switch (type){
		case 'branch':
			if (this.rotation > Math.PI / 2 && this.rotation < 3 * Math.PI / 2) {
				returnString = 'Inferotemporal ';
			}
			else {
				returnString = 'Superotemporal ';
			}
			returnString += 'branch ';
			break;

		case 'hemispheric':
			if (this.rotation > Math.PI / 2 && this.rotation < 3 * Math.PI / 2) {
				returnString = 'Inferior ';
			}
			else {
				returnString = 'Superior ';
			}
			returnString += 'hemispheric ';
			break;

		case 'central':
			returnString += 'Central ';
			break;
	}
	returnString += "retinal artery occlusion";

	// Macula
	if (this.apexY < -150) {
		returnString += ' sparing';
	}
	else {
		returnString += ' involving';
	}

	returnString += ' the macula';

	if (this.apexY > -70) returnString += ' with a cherry red spot';

	return returnString;
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.RetinalArteryOcclusionPostPole.prototype.snomedCode = function() {
	// Type
	var type = this.type();
	switch (type) {
		case 'branch':
			return 232035005;
			break;
		case 'hemispheric':
			return 232035005;
			break;
		case 'central':
			return 38742007;
			break;
	}
}

/**
 * Determines type of the vein occlusion
 *
 * @returns {String} String describing type of occlusion
 */
ED.RetinalArteryOcclusionPostPole.prototype.type = function() {
	// Arc defines type
	if (this.arc > 1.5 * Math.PI) return "central";
	else if (this.arc > 0.8 * Math.PI) return 'hemispheric';
	else return 'branch';
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Blot Haemorrhage
 *
 * @class RetinalHaemorrhage
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RetinalHaemorrhage = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RetinalHaemorrhage";
	
	// Derived parameters
	this.layer = 'Pre-retinal';
	
	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];
	
	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'layer':'Layer'};
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RetinalHaemorrhage.prototype = new ED.Doodle;
ED.RetinalHaemorrhage.prototype.constructor = ED.RetinalHaemorrhage;
ED.RetinalHaemorrhage.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.RetinalHaemorrhage.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default dragging attributes
 */
ED.RetinalHaemorrhage.prototype.setPropertyDefaults = function() {
	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['layer'] = {
		kind: 'other',
		type: 'string',
		list: ['Pre-retinal', 'Intra-retinal', 'Sub-retinal', 'Sub-RPE'],
		animate: false
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.RetinalHaemorrhage.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(0, -60);
	this.setParameterFromString('layer', 'Pre-retinal');
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RetinalHaemorrhage.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RetinalHaemorrhage.superclass.draw.call(this, _point);

	// Radius
	var r = 90;

	// Boundary path
	ctx.beginPath();

	// Haemorrhage
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 1;
	
	switch (this.layer) {
		case 'Pre-retinal':
			ctx.fillStyle = "rgba(255,0,0,1.0)";
			ctx.strokeStyle = ctx.fillStyle;
			break;
		case 'Intra-retinal':
			ctx.fillStyle = "rgba(255,0,0,0.75)";
			ctx.strokeStyle = ctx.fillStyle;
			break;
		case 'Sub-retinal':
			ctx.fillStyle = "rgba(255,0,0,0.5)";
			ctx.strokeStyle = ctx.fillStyle;
			break;
		case 'Sub-RPE':
			ctx.fillStyle = "rgba(255,0,0,0.25)";
			ctx.strokeStyle = ctx.fillStyle;
			break;
	}

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.RetinalHaemorrhage.prototype.groupDescription = function() {
	var returnString = "";
	
	switch (this.layer) {
		case 'Pre-retinal':
			returnString = 'Pre-retinal'
			break;
		case 'Intra-retinal':
			returnString = 'Intra-retinal'
			break;
		case 'Sub-retinal':
			returnString = 'Sub-retinal'
			break;
		case 'Sub-RPE':
			returnString = 'Sub-RPE'
			break;
	}
	
	returnString += ' haemorrhage';
	
	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * RetinalTouch
 *
 * @class RetinalTouch
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RetinalTouch = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RetinalTouch";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RetinalTouch.prototype = new ED.Doodle;
ED.RetinalTouch.prototype.constructor = ED.RetinalTouch;
ED.RetinalTouch.superclass = ED.Doodle.prototype;

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.RetinalTouch.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(140, 100);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RetinalTouch.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RetinalTouch.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Circle
	ctx.arc(0, 0, 60, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255,0,0,0)";
	ctx.strokeStyle = "rgba(255,0,0,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		var n = 8;
		var ri = 20;
		var ro = 40;

		ctx.beginPath();

		// Circle
		ctx.arc(0, 0, ri, 0, 2 * Math.PI, true);

		// Radial lines
		var theta = 0;
		for (var i = 0; i < n; i++) {
			theta += 2 * Math.PI / n;
			var sp = new ED.Point(0, 0);
			var ep = new ED.Point(0, 0);
			sp.setWithPolars(ri, theta);
			ep.setWithPolars(ro, theta);

			ctx.moveTo(sp.x, sp.y);
			ctx.lineTo(ep.x, ep.y);
		}

		ctx.lineWidth = 8;
		ctx.strokeStyle = "red";
		ctx.stroke();
	}

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Sector PRP
 *
 * @class RetinalVeinOcclusionPostPole
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RetinalVeinOcclusionPostPole = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RetinalVeinOcclusionPostPole";

	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY', 'arc', 'rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RetinalVeinOcclusionPostPole.prototype = new ED.Doodle;
ED.RetinalVeinOcclusionPostPole.prototype.constructor = ED.RetinalVeinOcclusionPostPole;
ED.RetinalVeinOcclusionPostPole.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.RetinalVeinOcclusionPostPole.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.RetinalVeinOcclusionPostPole.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 6, Math.PI * 2);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-200, -30);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.RetinalVeinOcclusionPostPole.prototype.setParameterDefaults = function() {
	this.arc = Math.PI / 2;
	this.apexY = -100;
	this.setRotationWithDisplacements(45, 120);;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RetinalVeinOcclusionPostPole.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RetinalVeinOcclusionPostPole.superclass.draw.call(this, _point);

	// Radii
	var ro = 420;
	var ri = -this.apexY;
	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of CircumferentialBuckle
	var topRightX = ro * Math.sin(theta);
	var topRightY = -ro * Math.cos(theta);
	var topLeftX = -ro * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255,255,0,0)";
	ctx.strokeStyle = "rgba(255,255,0,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {

		// Distribution data
		var si = 30;
		var sd = (30 + si);

		// Array of number of spots for each radius value
		var count = [26, 24, 22, 18, 14, 10];

		// Iterate through radius and angle to draw sector
		var i = 0;
		for (var r = ro - si; r > ri; r -= sd) {
			var j = 0;

			for (var a = -Math.PI / 2 - arcStart; a < this.arc - Math.PI / 2 - arcStart; a += sd / r) {
				a = -Math.PI / 2 - arcStart + j * 2 * Math.PI / count[i];

				var p = new ED.Point(0, 0);
				p.setWithPolars(r, a);
				this.drawNFLHaem(ctx, p.x, p.y);

				j++;
			}

			i++;
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.RetinalVeinOcclusionPostPole.prototype.description = function() {
	var returnString = "";

	// Type
	var type = this.type();
	switch (type){
		case 'branch':
			if (this.rotation > Math.PI / 2 && this.rotation < 3 * Math.PI / 2) {
				returnString = 'Inferotemporal ';
			}
			else {
				returnString = 'Superotemporal ';
			}
			returnString += 'branch ';
			break;

		case 'hemispheric':
			if (this.rotation > Math.PI / 2 && this.rotation < 3 * Math.PI / 2) {
				returnString = 'Inferior ';
			}
			else {
				returnString = 'Superior ';
			}
			returnString += 'hemispheric ';
			break;

		case 'central':
			returnString += 'Central ';
			break;
	}
	returnString += "retinal vein occlusion ";

	// Macula
	if (this.apexY < -150) {
		returnString += 'sparing ';
	}
	else {
		returnString += 'involving ';
	}

	returnString += 'the macula ';

	return returnString;
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.RetinalVeinOcclusionPostPole.prototype.snomedCode = function() {
	// Type
	var type = this.type();
	switch (type) {
		case 'branch':
			return 24596005;
			break;
		case 'hemispheric':
			return 232043000;
			break;
		case 'central':
			return 68478007;
			break;
	}
}

/**
 * Determines type of the vein occlusion
 *
 * @returns {String} String describing type of occlusion
 */
ED.RetinalVeinOcclusionPostPole.prototype.type = function() {
	// Arc defines type
	if (this.arc > 1.5 * Math.PI) return "central";
	else if (this.arc > 0.8 * Math.PI) return 'hemispheric';
	else return 'branch';
}

/**
 * OpenEyes
 *
 * (C) OpenEyes Foundation, 2016
 *
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Retinoschisis
 *
 * @class Retinoschisis
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Retinoschisis = function(_drawing, _parameterJSON)
{
    // Set classname
    this.className = "Retinoschisis";

    // Saved parameters
    this.savedParameterArray = ['arc', 'rotation', 'apexY'];

    // Call superclass constructor
    ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Retinoschisis.prototype = new ED.Doodle;
ED.Retinoschisis.prototype.constructor = ED.Retinoschisis;
ED.Retinoschisis.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Retinoschisis.prototype.setHandles = function()
{
    this.handleArray[1] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
    this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
    this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.Retinoschisis.prototype.setPropertyDefaults = function()
{
    this.isSelectable = true;
    this.isOrientated = false;
    this.isScaleable = true;
    this.isSqueezable = false;
    this.isMoveable = false;
    this.isRotatable = true;
    this.rangeOfScale = new ED.Range(+1, +4);
    this.rangeOfArc = new ED.Range(Math.PI/6, Math.PI*2);
    this.rangeOfApexX = new ED.Range(-0, +0);
    this.rangeOfApexY = new ED.Range(-400, +400);
}

/**
 * Sets default parameters
 */
ED.Retinoschisis.prototype.setParameterDefaults = function()
{
    this.arc = 60 * Math.PI/180;
    this.rotation = 225 * Math.PI/180;
    this.apexY = -260;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Retinoschisis.prototype.draw = function(_point)
{
    // Get context
    var ctx = this.drawing.context;

    // Call draw method in superclass
    ED.Retinoschisis.superclass.draw.call(this, _point);

    // Fit outer curve just inside ora on right and left fundus diagrams
    var r = 952/2;

    // Calculate parameters for arcs
    var theta = this.arc/2;
    var arcStart = - Math.PI/2 + theta;
    var arcEnd = - Math.PI/2 - theta;

    // Coordinates of corners of arc
    var topRightX = r * Math.sin(theta);
    var topRightY = - r * Math.cos(theta);
    var topLeftX = - r * Math.sin(theta);
    var topLeftY = topRightY;

    // Boundary path
    ctx.beginPath();

    // Start at top right
    //ctx.moveTo(topRightX, topRightY);

    // Arc across from top right to to mirror image point on the other side
    ctx.arc(0, 0, r, arcStart, arcEnd, true);

    // Connect across the bottom via the apex point
    var bp = +0.6;

    // Radius of disk (from Fundus doodle)
    var dr = +25;

    // RD above optic disk
    if (this.apexY < -dr)
    {
        ctx.bezierCurveTo(topLeftX, topLeftY, bp * topLeftX, this.apexY, this.apexX, this.apexY);
        ctx.bezierCurveTo(-bp * topLeftX, this.apexY, topRightX, topRightY, topRightX, topRightY);
    }
    // Retinoschisis involves optic disk
    else if (this.apexY < dr)
    {
        // Angle from origin to intersection of disk margin with a horizontal line through apexY
        var phi = Math.acos((0 - this.apexY)/dr);

        // Curve to disk, curve around it, then curve out again
        var xd = dr * Math.sin(phi);
        ctx.bezierCurveTo(topLeftX, topLeftY, bp * topLeftX, this.apexY, -xd, this.apexY);
        ctx.arc(0, 0, dr, -Math.PI/2 - phi, -Math.PI/2 + phi, false);
        ctx.bezierCurveTo(-bp * topLeftX, this.apexY, topRightX, topRightY, topRightX, topRightY);
    }
    // Retinoschisis beyond optic disk
    else
    {
        ctx.bezierCurveTo(topLeftX, topLeftY, bp * topLeftX, this.apexY, 0, 25);
        ctx.arc(0, 0, dr, Math.PI/2, 2.5*Math.PI, false);
        ctx.bezierCurveTo(-bp * topLeftX, this.apexY, topRightX, topRightY, topRightX, topRightY);
    }

    // Set line attributes
    ctx.lineWidth = 4;
    ctx.fillStyle = "rgba(0, 255, 255, 0.75)";
    ctx.strokeStyle = "rgba(0, 200, 255, 0.75)";

    // Draw boundary path (also hit testing)
    this.drawBoundary(_point);

    // Other stuff here
    if (this.drawFunctionMode == ED.drawFunctionMode.Draw)
    {
    }

    // Coordinates of handles (in canvas plane)
    this.handleArray[1].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
    this.handleArray[2].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
    this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

    // Draw handles if selected
    if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

    // Return value indicating successful hittest
    return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Retinoschisis.prototype.description = function()
{
    // Get side
    if(this.drawing.eye == ED.eye.Right)
    {
        var isRightSide = true;
    }
    else
    {
        var isRightSide = false;
    }

    // Construct description
    var returnString = "";

    // Use trigonometry on rotation field to determine quadrant
    returnString = returnString + (Math.cos(this.rotation) > 0?"Supero":"Infero");
    returnString = returnString + (Math.sin(this.rotation) > 0?(isRightSide?"nasal":"temporal"):(isRightSide?"temporal":"nasal"));
    returnString = returnString + " retinoschisis";

    // Return description
    return returnString;
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.Retinoschisis.prototype.snomedCode = function()
{
    return 44268007;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.Retinoschisis.prototype.diagnosticHierarchy = function()
{
    return 6;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 *
 *
 * @class RetinoscopyPowerCross
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RetinoscopyPowerCross = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RetinoscopyPowerCross";

	this.workingDistance = 0.5;
	this.angle1 = 180;
	this.angle2 = 90;
	this.powerSign1 = "+";
	this.powerSign2 = "+";
	this.powerInt1 = 0;
	this.powerInt2 = 0;
	this.powerDp1 = ".00";
	this.powerDp2 = ".00";
	
	// Saved parameters
	this.savedParameterArray = ['rotation', 'powerSign1', 'powerSign2', 'powerInt1', 'powerInt2', 'powerDp1', 'powerDp2'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {};
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RetinoscopyPowerCross.prototype = new ED.Doodle;
ED.RetinoscopyPowerCross.prototype.constructor = ED.RetinoscopyPowerCross;
ED.RetinoscopyPowerCross.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.RetinoscopyPowerCross.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	
	// Update component of validation array for simple parameters
	this.parameterValidationArray['rotation']['range'].setMinAndMax(Math.PI, 2*Math.PI);

	// Add complete validation arrays for derived parameters

	this.parameterValidationArray['workingDistance'] = {
		kind: 'derived',
		type: 'string',
		list: ['0.333','0.500','0.667','1.000','1.500'],
		animate: true
	};
	this.parameterValidationArray['angle1'] = {
		kind: 'derived',
		type: 'int',
		range: new ED.Range(1, 180),
		animate: true
	};
	this.parameterValidationArray['powerSign1'] = {
		kind: 'derived',
		type: 'string',
		list: ['+', '-'],
		animate: true
	};
	this.parameterValidationArray['powerInt1'] = {
		kind: 'derived',
		type: 'int',
		range: new ED.Range(0,20),
		animate: true
	};
	this.parameterValidationArray['powerDp1'] = {
		kind: 'derived',
		type: 'string',
		list: ['.00', '.25','.50','.75'],
		animate: true
	};
	this.parameterValidationArray['angle2'] = {
		kind: 'derived',
		type: 'int',
		range: new ED.Range(1, 180),
		animate: true
	};
	this.parameterValidationArray['powerSign2'] = {
		kind: 'derived',
		type: 'string',
		list: ['+', '-'],
		animate: true
	};
	this.parameterValidationArray['powerInt2'] = {
		kind: 'derived',
		type: 'int',
		range: new ED.Range(0,20),
		animate: true
	};
	this.parameterValidationArray['powerDp2'] = {
		kind: 'derived',
		type: 'string',
		list: ['.00', '.25','.50','.75'],
		animate: true
	};

}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.RetinoscopyPowerCross.prototype.setParameterDefaults = function() {
	this.rotation = Math.PI;
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.RetinoscopyPowerCross.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'angle1':
			returnArray['rotation'] = 2*Math.PI - parseFloat(_value*Math.PI/180);
			returnArray['angle2'] = (parseInt(_value)>90) ? parseInt(_value) - 90 : parseInt(_value) + 90;
			break;
			
		case 'rotation':
			var degAngle = Math.round(_value * 180 / Math.PI);
			returnArray['angle1'] = 360 - degAngle;
			returnArray['angle2'] = (360 - degAngle>90) ? 360 - degAngle - 90 : 360 - degAngle + 90;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RetinoscopyPowerCross.prototype.draw = function(_point) {
	
	// Axis length
	var l = 340;
	
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RetinoscopyPowerCross.superclass.draw.call(this, _point);
	
	// Draw invisible boundary box around axes
	ctx.moveTo(-l,-l);
	ctx.lineTo(-l,l);
	ctx.lineTo(l,l);
	ctx.lineTo(l,-l);
	ctx.lineTo(-l,-l);
	
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "rgba(0,0,0,0)";
	
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();
		
		// Draw y axis
		ctx.moveTo(0,-l);
		ctx.lineTo(0,l);
		
		// Draw X axis
		ctx.moveTo(l,0);
		ctx.lineTo(-l,0);
	
		// Set line attributes
		ctx.lineWidth = 7;
		ctx.fillStyle = "rgba(255, 255, 255, 0)";
		ctx.strokeStyle = "black";
		
		// Draw it
		ctx.stroke();
		
		// Text labels
		ctx.save();
		ctx.rotate(-this.rotation);
		var x;
		var y;

		ctx.font="48px Arial";
		ctx.fillStyle="black";
		ctx.textAlign="center"; 
		ctx.textBaseline = "middle";
	
		ctx.beginPath();

		var sp = l + 70;

		// axis 1		
		x = sp * Math.cos(this.rotation);
		y = -sp*Math.sin(-this.rotation);
		ctx.fillText(this.angle1 + "\xB0",x,y);
		
		// axis 2
		x = -sp * Math.sin(this.rotation);
		y = sp * Math.cos(this.rotation);
		ctx.fillText(this.angle2 + "\xB0",x,y);
		
		// power 1
		x = -sp * Math.cos(this.rotation);
		y = sp*Math.sin(-this.rotation);
		ctx.fillText(this.powerSign1 + parseInt(this.powerInt1) + this.powerDp1,x,y);
		
		// power 2
		x = sp * Math.sin(this.rotation);
		y = -sp * Math.cos(-this.rotation);
		ctx.fillText(this.powerSign2 + parseInt(this.powerInt2) + this.powerDp2,x,y);
		
		ctx.restore();

	}

	// Return value indicating successful hittest
	return this.isClicked;
};

ED.RetinoscopyPowerCross.prototype.calcRx = function() {
	var wdCompensation = (1 / this.workingDistance).toFixed(2);

	// Calculate minus cyl form
	var power1 = parseFloat(this.powerSign1 + parseInt(this.powerInt1) + this.powerDp1);
	var power2 = parseFloat(this.powerSign2 + parseInt(this.powerInt2) + this.powerDp2);
	var pSphere = (power1 >= power2) ? (power1 - wdCompensation).toFixed(2) : (power2 - wdCompensation).toFixed(2);
	var pCyl = (Math.abs(power1 - power2) * -1).toFixed(2); // reports in minus cyl format
	var angle = (power1>=power2) ? this.angle2 : this.angle1; // as per JEM, use angle of lowest power lens

	// force to be within the range of 0-180
	if (angle > 180)
		angle -= 180;

	// correction for cylinder axis offset
	angle -= 90;

	// cannot be negative
	if (angle < 0)
		angle += 180;

	return {
		pSphere: pSphere,
		pCyl: pCyl,
		angle: angle
	};
};

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.RetinoscopyPowerCross.prototype.description = function() {
	calcRx = this.calcRx();

	var Rx = (calcRx.pSphere >= 0 ) ? '+' + calcRx.pSphere: calcRx.pSphere;
	Rx += (calcRx.pCyl == 0) ? ' / -' : ' / ';
	Rx += calcRx.pCyl + ' x ' + calcRx.angle;
		
	return Rx;
}


/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * RingSegment
 *
 * @class RingSegment
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RingSegment = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RingSegment";

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RingSegment.prototype = new ED.Doodle;
ED.RingSegment.prototype.constructor = ED.RingSegment;
ED.RingSegment.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.RingSegment.prototype.setHandles = function() {
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Sets default dragging attributes
 */
ED.RingSegment.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = true;
	this.isArcSymmetrical = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(20 * Math.PI / 180, Math.PI / 2);
}

/**
 * Sets default parameters
 */
ED.RingSegment.prototype.setParameterDefaults = function() {
	// Default arc
	this.arc = 30 * Math.PI / 180;

	// Make it 180 degrees to last one of same class
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		this.rotation = doodle.rotation + Math.PI;
		this.arc = doodle.arc;
	} else {
		// LRIs are usually temporal
		if (this.drawing.eye == ED.eye.Right) {
			this.rotation = -Math.PI / 2;
		} else {
			this.rotation = Math.PI / 2;
		}
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RingSegment.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RingSegment.superclass.draw.call(this, _point);

	// Radius
	var r = 300;
	var d = 20;
	var ro = r + d;
	var ri = r - d;

	// Boundary path
	ctx.beginPath();

	// Half angle of arc
	var theta = this.arc / 2;

	// Arc across
	ctx.arc(0, 0, ro, -Math.PI / 2 + theta, -Math.PI / 2 - theta, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, -Math.PI / 2 - theta, -Math.PI / 2 + theta, false);

	// Close path
	ctx.closePath();

	// Colour of fill is white but with transparency
	ctx.fillStyle = "rgba(255,255,255,0.75)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "darkgray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, theta);
	this.handleArray[3].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.RingSegment.prototype.description = function() {
	var returnString = "Limbal relaxing incision " + (this.arc * 180 / Math.PI).toFixed(0) + " degrees at ";
	returnString += this.clockHour() + " o'clock";

	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Radial keratotomy
 *
 * @class RK
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RK = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RK";
	
	// Other parameters
	this.numberOfCuts = '8';

	// Saved parameters
	this.savedParameterArray = ['apexY', 'scaleX', 'scaleY', 'rotation', 'numberOfCuts'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'numberOfCuts':'Number of Cuts'};
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RK.prototype = new ED.Doodle;
ED.RK.prototype.constructor = ED.RK;
ED.RK.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.RK.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.RK.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isUnique;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.15);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.15);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-200, -60);
	
	this.parameterValidationArray['numberOfCuts'] = {
		kind: 'other',
		type: 'string',
		list: ['4', '8', '16'],
		animate: false
	};
}

/**
 * Sets default parameters
 */
ED.RK.prototype.setParameterDefaults = function() {
	this.apexY = -100;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RK.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RK.superclass.draw.call(this, _point);

	// RK number and size
	var ro = 320;
	var ri = -this.apexY;
	var n = parseInt(this.numberOfCuts);

	// Calculate parameters for arcs
	var arcStart = 0;
	var arcEnd = 2 * Math.PI;

	// Boundary path
	ctx.beginPath();

	// Do a 360 arc
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Move to inner circle
	ctx.moveTo(ri, 0);

	// Arc back the other way
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Create fill pattern
	ctx.fillStyle = "rgba(155,255,255,0)";

	// Transparent stroke
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgba(100,100,100,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		var theta = 2 * Math.PI / n; // Angle between radii
		ctx.strokeStyle = "rgba(100,100,100,0.7)";

		// Draw radii spokes
		ctx.beginPath();
		var i;
		for (i = 0; i < n; i++) {
			var angle = i * theta;
			var pi = new ED.Point(0, 0);
			pi.setWithPolars(ri, angle);
			var po = new ED.Point(0, 0);
			po.setWithPolars(ro, angle);
			ctx.moveTo(pi.x, pi.y);
			ctx.lineTo(po.x, po.y);
			ctx.closePath();
		}
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0)
	point.setWithPolars(ro, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.RK.prototype.description = function() {
	return "Radial keratotomy";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Round hole
 *
 * @class RoundHole
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RoundHole = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RoundHole";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RoundHole.prototype = new ED.Doodle;
ED.RoundHole.prototype.constructor = ED.RoundHole;
ED.RoundHole.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.RoundHole.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default properties
 */
ED.RoundHole.prototype.setPropertyDefaults = function() {}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.RoundHole.prototype.setParameterDefaults = function() {
	// Displacement from fovea, and from last doodle
	var d = 300;
	this.originX = d;
	this.originY = d;

	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		var point = new ED.Point(doodle.originX, doodle.originY);
		var direction = point.direction() + Math.PI / 8;
		var distance = point.length();
		var np = new ED.Point(0, 0);
		np.setWithPolars(distance, direction);

		this.originX = np.x;
		this.originY = np.y;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RoundHole.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RoundHole.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Round hole
	ctx.arc(0, 0, 30, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "red";
	ctx.strokeStyle = "blue";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {}

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(21, -21));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Calculate arc (Arc property not used naturally in this doodle ***TODO** more elegant method of doing this possible!)
	var centre = this.transform.transformPoint(new ED.Point(0, 0));
	var oneWidthToRight = this.transform.transformPoint(new ED.Point(60, 0));
	var xco = centre.x - this.drawing.canvas.width / 2;
	var yco = centre.y - this.drawing.canvas.height / 2;
	var radius = this.scaleX * Math.sqrt(xco * xco + yco * yco);
	var width = this.scaleX * (oneWidthToRight.x - centre.x);
	this.arc = Math.atan(width / radius);
	//console.log(this.arc * 180/Math.PI + " + " + this.calculateArc() * 180/Math.PI);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.RoundHole.prototype.description = function() {
	var returnString = "";

	// Size description
	if (this.scaleX < 1) returnString = "Small ";
	if (this.scaleX > 1.5) returnString = "Large ";

	// Round hole
	returnString += "Round hole ";

	// Location (clockhours)
	returnString += this.clockHour() + " o'clock";

	return returnString;
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.RoundHole.prototype.snomedCode = function() {
	return 302888003;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.RoundHole.prototype.diagnosticHierarchy = function() {
	return 3;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Blot Haemorrhage
 *
 * @class RPEAtrophy
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RPEAtrophy = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RPEAtrophy";
	
	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RPEAtrophy.prototype = new ED.Doodle;
ED.RPEAtrophy.prototype.constructor = ED.RPEAtrophy;
ED.RPEAtrophy.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.RPEAtrophy.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.RPEAtrophy.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(0, -60);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RPEAtrophy.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RPEAtrophy.superclass.draw.call(this, _point);

	// Radius
	var r = 120;

	// Boundary path
	ctx.beginPath();

	// Haemorrhage
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 1;
	ctx.fillStyle = "rgba(253, 238, 173, 0.75)";
	ctx.strokeStyle = ctx.fillStyle;
	
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.RPEAtrophy.prototype.groupDescription = function() {
	return "RPE atrophy";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * The optic disc
 *
 * @class RPEDetachment
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RPEDetachment = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RPEDetachment";

	// Private parameters
	this.numberOfHandles = 4;
	this.initialRadius = 80;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RPEDetachment.prototype = new ED.Doodle;
ED.RPEDetachment.prototype.constructor = ED.RPEDetachment;
ED.RPEDetachment.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.RPEDetachment.prototype.setHandles = function() {
	// Array of handles
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	}

	// Allow top handle to rotate doodle
	this.handleArray[0].isRotatable = true;
}

/**
 * Sets default properties
 */
ED.RPEDetachment.prototype.setPropertyDefaults = function() {
	// Create ranges to constrain handles
	this.handleVectorRangeArray = new Array();
	for (var i = 0; i < this.numberOfHandles; i++) {
		// Full circle in radians
		var cir = 2 * Math.PI;

		// Create a range object for each handle
		var n = this.numberOfHandles;
		var range = new Object;
		range.length = new ED.Range(+50, +290);
		range.angle = new ED.Range((((2 * n - 1) * cir / (2 * n)) + i * cir / n) % cir, ((1 * cir / (2 * n)) + i * cir / n) % cir);
		this.handleVectorRangeArray[i] = range;
	}
}

/**
 * Sets default parameters
 */
ED.RPEDetachment.prototype.setParameterDefaults = function() {
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		var np = new ED.Point(doodle.originX + 150, 0);
		this.move(np.x, np.y);
	} else {
		//this.move((this.drawing.eye == ED.eye.Right ? -1 : 1) * 100, 0);
	}

	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate with handles at equidistant points around circumference
	for (var i = 0; i < this.numberOfHandles; i++) {
		var point = new ED.Point(0, 0);
		point.setWithPolars(this.initialRadius, i * 2 * Math.PI / this.numberOfHandles);
		this.addPointToSquiggle(point);
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RPEDetachment.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RPEDetachment.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Bezier points
	var fp;
	var tp;
	var cp1;
	var cp2;

	// Angle of control point from radius line to point (this value makes path a circle Math.PI/12 for 8 points
	var phi = 2 * Math.PI / (3 * this.numberOfHandles);

	// Start curve
	ctx.moveTo(this.squiggleArray[0].pointsArray[0].x, this.squiggleArray[0].pointsArray[0].y);

	// Complete curve segments
	for (var i = 0; i < this.numberOfHandles; i++) {
		// From and to points
		fp = this.squiggleArray[0].pointsArray[i];
		var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
		tp = this.squiggleArray[0].pointsArray[toIndex];

		// Control points
		cp1 = fp.tangentialControlPoint(+phi);
		cp2 = tp.tangentialControlPoint(-phi);

		// Draw Bezier curve
		ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);
	}

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(173, 48, 14, 1)";
	ctx.strokeStyle = "brown";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of expert handles (in canvas plane)
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[i]);
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.RPEDetachment.prototype.description = function() {
	return 'Retinal pigment epithelial detachment';
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Blot Haemorrhage
 *
 * @class RPEHypertrophy
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RPEHypertrophy = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RPEHypertrophy";
	
	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RPEHypertrophy.prototype = new ED.Doodle;
ED.RPEHypertrophy.prototype.constructor = ED.RPEHypertrophy;
ED.RPEHypertrophy.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.RPEHypertrophy.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.RPEHypertrophy.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(-300, -60);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RPEHypertrophy.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RPEHypertrophy.superclass.draw.call(this, _point);

	// Radius
	var r = 60;

	// Boundary path
	ctx.beginPath();

	// Haemorrhage
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set attributes
	ctx.lineWidth = 1;
	ctx.fillStyle = "rgba(145, 96, 80, 1.0)";
	ctx.strokeStyle = ctx.fillStyle;
	
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.RPEHypertrophy.prototype.groupDescription = function() {
	return "RPE hypertrophy";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Retinal detachment
 *
 * @class RPERip
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RPERip = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RPERip";

	// Private parameters
	this.initialRadius = 150;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexY', 'scaleX', 'scaleY', 'arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RPERip.prototype = new ED.Doodle;
ED.RPERip.prototype.constructor = ED.RPERip;
ED.RPERip.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.RPERip.prototype.setHandles = function() {
	this.handleArray[1] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, true);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.RPERip.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-120, +120);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-120, +120);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-this.initialRadius, +this.initialRadius);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(0.5, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(0.5, +1.5);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.RPERip.prototype.setParameterDefaults = function() {
	this.arc = 120 * Math.PI / 180;
	this.setRotationWithDisplacements(90, 0);
	this.setOriginWithDisplacements(0, 100);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RPERip.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RPERip.superclass.draw.call(this, _point);

	// Radius of outer curve
	var r = this.initialRadius;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of corners of arc
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across from top right to to mirror image point on the other side
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(251, 147, 76, 0.75)";
	ctx.strokeStyle = "red";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Boundary path
		ctx.beginPath();

		// Arc across from top right to to mirror image point on the other side
		ctx.arc(0, 0, r, arcStart, arcEnd, true);

		// Connect across the bottom via the apex point
		var bp = +0.6;
		ctx.bezierCurveTo(topLeftX, topLeftY, bp * topLeftX, this.apexY, this.apexX, this.apexY);
		ctx.bezierCurveTo(-bp * topLeftX, this.apexY, topRightX, topRightY, topRightX, topRightY);

		// Set line attributes
		ctx.lineWidth = 4;
		ctx.fillStyle = "rgba(180, 125, 60, 0.75)";
		ctx.strokeStyle = "brown";

		ctx.fill();
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[1].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, Math.PI / 8);
	this.handleArray[3].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.RPERip.prototype.description = function() {
	// Return description
	return "RPE rip";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Retinal detachment
 *
 * @class RRD
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.RRD = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "RRD";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.RRD.prototype = new ED.Doodle;
ED.RRD.prototype.constructor = ED.RRD;
ED.RRD.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.RRD.prototype.setHandles = function() {
	this.handleArray[1] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.RRD.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this._isMacOff = false;
    if (this.drawing.eye == ED.eye.Right) {
        this._macPoint = new ED.Point(-100, 0);
    } else {
        this._macPoint = new ED.Point(100, 0);
    }


	// Update component of validation array for simple parameters
// 	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+1, +4);
// 	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+1, +4);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-400, +400);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.RRD.prototype.setParameterDefaults = function() {
	this.arc = 120 * Math.PI / 180;
	this.apexY = -100;
	this.setRotationWithDisplacements(45, 120);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.RRD.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.RRD.superclass.draw.call(this, _point);

	// Fit outer curve just inside ora on right and left fundus diagrams
	var r = 952 / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of corners of arc
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across from top right to to mirror image point on the other side
	ctx.arc(0, 0, r, arcStart, arcEnd, true);

	// Connect across the bottom via the apex point
	var bp = +0.6;

	// Radius of disc (from Fundus doodle)
	var dr = +25;

	// RD above optic disc
	if (this.apexY < -dr) {
		ctx.bezierCurveTo(topLeftX, topLeftY, bp * topLeftX, this.apexY, this.apexX, this.apexY);
		ctx.bezierCurveTo(-bp * topLeftX, this.apexY, topRightX, topRightY, topRightX, topRightY);
	}
	// RRD involves optic disc
	else if (this.apexY < dr) {
		// Angle from origin to intersection of disc margin with a horizontal line through apexY
		var phi = Math.acos((0 - this.apexY) / dr);

		// Curve to disc, curve around it, then curve out again
		var xd = dr * Math.sin(phi);
		ctx.bezierCurveTo(topLeftX, topLeftY, bp * topLeftX, this.apexY, -xd, this.apexY);
		ctx.arc(0, 0, dr, -Math.PI / 2 - phi, -Math.PI / 2 + phi, false);
		ctx.bezierCurveTo(-bp * topLeftX, this.apexY, topRightX, topRightY, topRightX, topRightY);
	}
	// RRD beyond optic disc
	else {
		ctx.bezierCurveTo(topLeftX, topLeftY, bp * topLeftX, this.apexY, 0, 25);
		ctx.arc(0, 0, dr, Math.PI / 2, 2.5 * Math.PI, false);
		ctx.bezierCurveTo(-bp * topLeftX, this.apexY, topRightX, topRightY, topRightX, topRightY);
	}

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(0, 0, 255, 0.75)";
	ctx.strokeStyle = "blue";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	// create the Mac point
	// not sure if we need to do this conversion every time, but if the canvas properties change it may be necessary
	// so for safeties sake
    var maculaCanvasPt = this.drawing.transform.transformPoint(this._macPoint);
    // Determine whether macula is off or not
	this._isMacOff = this.hitTest(ctx, maculaCanvasPt);

	// Coordinates of handles (in canvas plane)
	this.handleArray[1].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.RRD.prototype.description = function() {
	// Construct description
	var returnString = "";

	// Use trigonometry on rotation field to determine quadrant
	returnString = returnString + (Math.cos(this.rotation) > 0 ? "Supero" : "Infero");
	returnString = returnString + (Math.sin(this.rotation) > 0 ? (this.drawing.eye == ED.eye.Right ? "nasal" : "temporal") : (this.drawing.eye == ED.eye.Right ? "temporal" : "nasal"));
	returnString = returnString + " retinal detachment";
	returnString = returnString + (this.isMacOff() ? " (macula off)" : " (macula on)");

	// Return description
	return returnString;
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.RRD.prototype.snomedCode = function() {
	return (this.isMacOff() ? 232009009 : 232008001);
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.RRD.prototype.diagnosticHierarchy = function() {
	return (this.isMacOff() ? 10 : 9);
}

/**
 * Determines whether the macula is off or not
 *
 * @returns {boolean} True if macula is off
 */
ED.RRD.prototype.isMacOff = function() {
	return this._isMacOff;
};

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Rubeosis
 *
 * @class Rubeosis
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Rubeosis = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Rubeosis";

	// Derived parameters
	this.severity = 50;

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Rubeosis.prototype = new ED.Doodle;
ED.Rubeosis.prototype.constructor = ED.Rubeosis;
ED.Rubeosis.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Rubeosis.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.Rubeosis.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-380, -200);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['severity'] = {
		kind: 'derived',
		type: 'float',
		range: new ED.Range(20, 100),
		precision: 1,
		animate: true
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Rubeosis.prototype.setParameterDefaults = function() {
	this.arc = Math.PI / 12;
	this.setRotationWithDisplacements(90, 45);

	var doodle = this.drawing.lastDoodleOfClass("AntSeg");
	if (doodle) {
		this.apexY = doodle.apexY - this.severity;
	} else {
		this.apexY = -320;
	}
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.Rubeosis.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'severity':
			var doodle = this.drawing.lastDoodleOfClass("AntSeg");
			if (doodle) {
				returnArray['apexY'] = doodle.apexY - _value;
			}
			break;

		case 'apexY':
			var doodle = this.drawing.lastDoodleOfClass("AntSeg");
			if (doodle) {
				returnArray['severity'] = doodle.apexY - _value;
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Rubeosis.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Rubeosis.superclass.draw.call(this, _point);

	// Set inner radius according to pupil
	var ri = 200;
	var doodle = this.drawing.lastDoodleOfClass("AntSeg");
	if (doodle) ri = -doodle.apexY;

	// Boundary starts further out to allow selection of pupil handle
	var rib = ri + 16;

	// Set apexY and range
	this.parameterValidationArray['apexY']['range'].max = -ri - 50;
	this.apexY = this.parameterValidationArray['apexY']['range'].constrain(-ri - this.severity);

	// Outer radius is position of apex handle
	var ro = -this.apexY;

	// Radius for control handles
	var r = rib + (ro - rib) / 2;

	// Boundary path
	ctx.beginPath();

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of SectorPRPPostPole
	var startHandle = new ED.Point(-r * Math.sin(theta), -r * Math.cos(theta));
	var endHandle = new ED.Point(r * Math.sin(theta), -r * Math.cos(theta));

	// Boundary path
	ctx.beginPath();

	// Path
	ctx.arc(0, 0, rib, arcStart, arcEnd, true);
	ctx.arc(0, 0, ro, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = this.isSelected ? "rgba(240,240,240,0.5)" : "rgba(240,240,240,0.0)";

	// Set line attributes
	ctx.lineWidth = 1;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "rgba(120,120,120,0.0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non-boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		// Angular separation of vessels
		var inc = 2 * Math.PI / 16;
		var disp = Math.PI / 24;
		var phi = 2 * Math.PI / 60;
		var rc = ri + 2 * (ro - ri) / 3;

		// Number of vessels to draw
		var n = 1 + Math.floor(this.arc / inc);

		// Draw each vessel tree
		for (var i = 0; i < n; i++) {
			// Start point
			var sp = startHandle.pointAtRadiusAndClockwiseAngle(ri, disp + i * inc);

			// First branch
			var ep = startHandle.pointAtRadiusAndClockwiseAngle(ro, disp + i * inc + phi);
			var cp1 = startHandle.pointAtRadiusAndClockwiseAngle(rc, disp + i * inc);
			var cp2 = startHandle.pointAtRadiusAndClockwiseAngle(ro, disp + i * inc + phi / 2);
			ctx.moveTo(sp.x, sp.y);
			ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, ep.x, ep.y);

			// Second branch
			ep = startHandle.pointAtRadiusAndClockwiseAngle(ro, disp + i * inc - phi);
			cp1 = startHandle.pointAtRadiusAndClockwiseAngle(rc, disp + i * inc);
			cp2 = startHandle.pointAtRadiusAndClockwiseAngle(ro, disp + i * inc - phi / 2);
			ctx.moveTo(sp.x, sp.y);
			ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, ep.x, ep.y);
		}

		// Set line attributes
		ctx.lineWidth = 4;
		ctx.strokeStyle = "red";

		// Draw vessels
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(startHandle);
	this.handleArray[3].location = this.transform.transformPoint(endHandle);
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.Rubeosis.prototype.groupDescription = function() {
	return "Rubeotic vessels on margin of pupil at ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Rubeosis.prototype.description = function() {
	return this.clockHour() + " o'clock";
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Number} SnoMed code of entity represented by doodle
 */
ED.Rubeosis.prototype.snomedCode = function()
{
    return 51995000;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Scleral incision
 *
 * @class ScleralIncision
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ScleralIncision = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ScleralIncision";

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.ScleralIncision.prototype = new ED.Doodle;
ED.ScleralIncision.prototype.constructor = ED.ScleralIncision;
ED.ScleralIncision.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.ScleralIncision.prototype.setHandles = function() {
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Sets default properties
 */
ED.ScleralIncision.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = true;
	this.isArcSymmetrical = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 16, Math.PI / 2);
}

/**
 * Sets default parameters (only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.ScleralIncision.prototype.setParameterDefaults = function() {
	this.arc = Math.PI / 8;
	this.setRotationWithDisplacements(60, -120);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ScleralIncision.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ScleralIncision.superclass.draw.call(this, _point);

	// Radii
	var r = 560;
	var d = 40;
	var ro = r + d;
	var ri = r - d;

	// Boundary path
	ctx.beginPath();

	// Half angle of arc
	var theta = this.arc / 2;

	// Arc across
	ctx.arc(0, 0, ro, -Math.PI / 2 + theta, -Math.PI / 2 - theta, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, -Math.PI / 2 - theta, -Math.PI / 2 + theta, false);

	// Close path
	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = "rgba(200,200,200,0)";

	// Set line attributes
	ctx.lineWidth = 5;

	// Colour of outer line
	ctx.strokeStyle = "rgba(120,120,120,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// New path
		ctx.beginPath();

		// Arc across
		ctx.arc(0, 0, r, -Math.PI / 2 + theta, -Math.PI / 2 - theta, true);

		// Sutures
		var sutureSeparationAngle = 0.2;
		var p = new ED.Point(0, 0);
		var phi = theta - sutureSeparationAngle / 2;

		do {
			p.setWithPolars(r - d, phi);
			ctx.moveTo(p.x, p.y);
			p.setWithPolars(r + d, phi);
			ctx.lineTo(p.x, p.y);

			phi = phi - sutureSeparationAngle;
		} while (phi > -theta);

		// Set line attributes
		ctx.lineWidth = 6;

		// Colour of outer line is dark gray
		ctx.strokeStyle = "rgba(120,120,120,0.75)";

		// Draw incision
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0);
	point.setWithPolars(r, theta);
	this.handleArray[3].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ScleralIncision.prototype.groupDescription = function() {
	return "Scleral incision at ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ScleralIncision.prototype.description = function() {
	return this.clockHour();
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ScleralIncision.prototype.groupDescriptionEnd = function() {
	return " o'clock";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Sclerostomy - bind an HTML element with 'overallGauge' parameter in order to achieve one way binding
 *
 * Also an example of using 'spare' properties to save otherwise unsaved parameters
 *
 * @class Sclerostomy
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Sclerostomy = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Sclerostomy";

	// Private parameters
	this.parsPlana = -560;

	// Derived parameters
	this.overallGauge = '23g';
	this.gauge = '23g';
	this.isSutured = false;

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Sclerostomy.prototype = new ED.Doodle;
ED.Sclerostomy.prototype.constructor = ED.Sclerostomy;
ED.Sclerostomy.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Sclerostomy.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.Sclerostomy.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-660, -460);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['overallGauge'] = {
		kind: 'derived',
		type: 'string',
		list: ['20g', '23g', '25g', '27g'],
		animate: false
	};
	this.parameterValidationArray['gauge'] = {
		kind: 'derived',
		type: 'string',
		list: ['20g', '23g', '25g', '27g'],
		animate: false
	};
	this.parameterValidationArray['isSutured'] = {
		kind: 'derived',
		type: 'bool',
		display: true
	};
}

/**
 * Sets default parameters
 */
ED.Sclerostomy.prototype.setParameterDefaults = function() {
	this.apexY = -600;
	this.gauge = "23g";
	this.isSutured = false;

	// Arc property is unused, so used it to store isSutured property
	this.arc = 1;

	this.setRotationWithDisplacements(60, -45);
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.Sclerostomy.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'apexY':
			if (_value < -610) returnArray['gauge'] = "20g";
			else if (_value < -560) returnArray['gauge'] = "23g";
			else if (_value < -510) returnArray['gauge'] = "25g";
			else returnArray['gauge'] = "27g";
			break;

		case 'overallGauge':
			returnArray['gauge'] = _value;
			break;

		case 'gauge':
			if (_value == "20g") returnArray['apexY'] = -650;
			else if (_value == "23g") returnArray['apexY'] = -600;
			else if (_value == "25g") returnArray['apexY'] = -550;
			else returnArray['apexY'] = -500;
			break;

		case 'arc':
			if (_value < 2) returnArray['isSutured'] = false;
			else returnArray['isSutured'] = true;
			break;

		case 'isSutured':
			if (_value) returnArray['arc'] = 3;
			else returnArray['arc'] = 1;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Sclerostomy.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Sclerostomy.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Port
	ctx.rect(-60, this.parsPlana - 120, 120, 160);

	// Set line attributes
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";
	ctx.fillStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Draw different shape according to gauge
		switch (this.gauge) {
			case "20g":
				ctx.beginPath();
				ctx.moveTo(-50, this.parsPlana);
				ctx.bezierCurveTo(-30, this.parsPlana - 30, 30, this.parsPlana - 30, 50, this.parsPlana);
				ctx.bezierCurveTo(30, this.parsPlana + 30, -30, this.parsPlana + 30, -50, this.parsPlana);
				ctx.closePath();
				ctx.fillStyle = "red";
				ctx.fill();
				break;

			case "23g":
				ctx.beginPath();
				ctx.rect(-60, this.parsPlana - 120, 120, 60);
				ctx.fillStyle = "rgba(0, 0, 255, 0.5)";
				ctx.fill();
				ctx.beginPath();
				ctx.rect(-30, this.parsPlana - 60, 60, 60);
				ctx.fillStyle = "rgba(120, 120, 120, 0.5)";
				ctx.fill();
				ctx.beginPath();
				ctx.rect(-30, this.parsPlana, 60, 100);
				ctx.fillStyle = "rgba(220, 220, 220, 0.5)";
				ctx.fill();
				break;

			case "25g":
				ctx.beginPath();
				ctx.rect(-50, this.parsPlana - 120, 100, 60);
				ctx.fillStyle = "rgba(255, 128, 0, 0.5)";
				ctx.fill();
				ctx.beginPath();
				ctx.rect(-20, this.parsPlana - 60, 40, 60);
				ctx.fillStyle = "rgba(120, 120, 120, 0.5)";
				ctx.fill();
				ctx.beginPath();
				ctx.rect(-20, this.parsPlana, 40, 100);
				ctx.fillStyle = "rgba(220, 220, 220, 0.5)";
				ctx.fill();
				break;

			case "27g":
				ctx.beginPath();
				ctx.rect(-40, this.parsPlana - 120, 80, 60);
				ctx.fillStyle = "rgba(0, 255, 0, 0.5)";
				ctx.fill();
				ctx.beginPath();
				ctx.rect(-15, this.parsPlana - 60, 30, 60);
				ctx.fillStyle = "rgba(120, 120, 120, 0.5)";
				ctx.fill();
				ctx.beginPath();
				ctx.rect(-15, this.parsPlana, 30, 100);
				ctx.fillStyle = "rgba(220, 220, 220, 0.5)";
				ctx.fill();
				break;
		}
		ctx.fill();

		// Draw suture
		if (this.isSutured || this.gauge == "20g") {
			ctx.beginPath();
			ctx.moveTo(-40, this.parsPlana + 40);
			ctx.lineTo(-40, this.parsPlana - 40);
			ctx.lineTo(+40, this.parsPlana + 40);
			ctx.lineTo(+40, this.parsPlana - 40);
			ctx.lineTo(-40, this.parsPlana + 40);

			ctx.lineWidth = 6;
			ctx.strokeStyle = "rgba(0,0,120,0.7)";
			ctx.closePath();
			ctx.stroke();
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Draws extra items if the doodle is highlighted
 */
ED.Sclerostomy.prototype.drawHighlightExtras = function() {
	// Get context
	var ctx = this.drawing.context;

	// Draw text description of gauge
	ctx.lineWidth = 1;
	ctx.fillStyle = "gray";
	ctx.font = "64px sans-serif";
	ctx.fillText(this.gauge, 80, this.parsPlana + 20);
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.Sclerostomy.prototype.groupDescription = function() {
	return "Sclerostomies at ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Sclerostomy.prototype.description = function() {
	// Sutured?
	var sutured = this.isSutured ? " (sutured)" : "";

	// Location (clockhours)
	return this.clockHour() + sutured;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Sclerostomy.prototype.groupDescriptionEnd = function() {
	return " o'clock";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * SectorIridectomy
 *
 * @class SectorIridectomy
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.SectorIridectomy = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "SectorIridectomy";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.SectorIridectomy.prototype = new ED.Doodle;
ED.SectorIridectomy.prototype.constructor = ED.SectorIridectomy;
ED.SectorIridectomy.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.SectorIridectomy.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Sets default dragging attributes
 */
ED.SectorIridectomy.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = true;
	this.isArcSymmetrical = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(20 * Math.PI / 180, Math.PI / 2);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-334, -300);
}

/**
 * Sets default parameters
 */
ED.SectorIridectomy.prototype.setParameterDefaults = function() {
	// Default arc
	this.arc = 60 * Math.PI / 180;

	// Make a second one 90 degress to last one of same class
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		this.rotation = doodle.rotation + Math.PI / 2;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.SectorIridectomy.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.SectorIridectomy.superclass.draw.call(this, _point);

	// Radii
	var ro = 376;

	// If iris there, take account of pupil size
	var ri;
	var doodle = this.drawing.lastDoodleOfClass("AntSeg");
	if (doodle) ri = -doodle.apexY - 2;
	else ri = 300;

	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of doodle
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Half angle of arc
	var theta = this.arc / 2;

	// Arc across
	ctx.arc(0, 0, ro, -Math.PI / 2 + theta, -Math.PI / 2 - theta, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, -Math.PI / 2 - theta, -Math.PI / 2 + theta, false);

	// Close path
	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = "rgba(218,230,241,1)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line
	ctx.strokeStyle = "rgba(218,230,241,1)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.SectorIridectomy.prototype.description = function() {
	var returnString = "Sector iridectomy of " + (this.arc * 180 / Math.PI).toFixed(0) + " degrees at ";
	returnString += this.clockHour() + " o'clock";

	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Sector PRP
 *
 * @class SectorPRP
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.SectorPRP = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "SectorPRP";

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.SectorPRP.prototype = new ED.Doodle;
ED.SectorPRP.prototype.constructor = ED.SectorPRP;
ED.SectorPRP.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.SectorPRP.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Set default properties
 */
ED.SectorPRP.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 6, Math.PI * 2);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.SectorPRP.prototype.setParameterDefaults = function() {
	this.arc = 55 * Math.PI / 180;

	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		this.rotation = doodle.rotation + (this.drawing.eye == ED.eye.Right ? -1 : 1) * (doodle.arc / 2 + this.arc / 2 + Math.PI / 12);
	} else {
		this.rotation = (this.drawing.eye == ED.eye.Right ? -1 : 1) * this.arc / 2;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.SectorPRP.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.SectorPRP.superclass.draw.call(this, _point);

	// Radius of outer curve just inside ora on right and left fundus diagrams
	var ro = 952 / 2;
	var ri = 100;
	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of SectorPRP
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 40;
	ctx.fillStyle = "rgba(255,255,255,0)";
	ctx.strokeStyle = "rgba(255,255,255,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// PRP spot data
		var si = 30;
		var sd = (30 + si);

		// Array of number of spots for each radius value
		var count = [47, 41, 35, 28, 22, 15];

		// Iterate through radius and angle to draw sector
		var i = 0;
		for (var r = ro - si; r > ri; r -= sd) {
			var j = 0;

			for (var a = -Math.PI / 2 - arcStart; a < this.arc - Math.PI / 2 - arcStart; a += sd / r) {
				a = -Math.PI / 2 - arcStart + j * 2 * Math.PI / count[i];

				var p = new ED.Point(0, 0);
				p.setWithPolars(r, a);
				this.drawLaserSpot(ctx, p.x, p.y);

				j++;
			}

			i++;
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Sector PRP
 *
 * @class SectorPRPPostPole
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.SectorPRPPostPole = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "SectorPRPPostPole";

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.SectorPRPPostPole.prototype = new ED.Doodle;
ED.SectorPRPPostPole.prototype.constructor = ED.SectorPRPPostPole;
ED.SectorPRPPostPole.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.SectorPRPPostPole.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Set default properties
 */
ED.SectorPRPPostPole.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 6, Math.PI * 2);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.SectorPRPPostPole.prototype.setParameterDefaults = function() {
	this.arc = 55 * Math.PI / 180;

	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		this.rotation = doodle.rotation + (this.drawing.eye == ED.eye.Right ? -1 : 1) * (doodle.arc / 2 + this.arc / 2 + Math.PI / 12);
	} else {
		this.rotation = (this.drawing.eye == ED.eye.Right ? -1 : 1) * this.arc / 2;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.SectorPRPPostPole.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.SectorPRPPostPole.superclass.draw.call(this, _point);

	// Radius of outer curve just inside ora on right and left fundus diagrams
	var ro = 1000 / 2;
	var ri = 300;
	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of SectorPRPPostPole
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 40;
	ctx.fillStyle = "rgba(255,255,255,0)";
	ctx.strokeStyle = "rgba(255,255,255,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// PRP spot data
		var si = 30;
		var sd = (30 + si);

		// Array of number of spots for each radius value
		var count = [47, 41, 35, 28, 22, 15];

		// Iterate through radius and angle to draw sector
		var i = 0;
		for (var r = ro - si; r > ri; r -= sd) {
			var j = 0;

			for (var a = -Math.PI / 2 - arcStart; a < this.arc - Math.PI / 2 - arcStart; a += sd / r) {
				a = -Math.PI / 2 - arcStart + j * 2 * Math.PI / count[i];

				var p = new ED.Point(0, 0);
				p.setWithPolars(r, a);
				this.drawLaserSpot(ctx, p.x, p.y);

				j++;
			}

			i++;
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.SectorPRPPostPole.prototype.description = function() {
	return "Sector PRP";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * SidePort
 *
 * @class SidePort
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.SidePort = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "SidePort";

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
};

/**
 * Sets superclass and constructor
 */
ED.SidePort.prototype = new ED.Doodle();
ED.SidePort.prototype.constructor = ED.SidePort;
ED.SidePort.superclass = ED.Doodle.prototype;

/**
 * Sets default properties
 */
ED.SidePort.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.isRotatable = true;
	this.isArcSymmetrical = true;
};

/**
 * Sets default parameters
 */
ED.SidePort.prototype.setParameterDefaults = function() {
	this.setRotationWithDisplacements(90, 180);
};

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.SidePort.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.SidePort.superclass.draw.call(this, _point);

	// Radius
	var r = 334;
	var d = 30;
	var ro = r + d;
	var ri = r - d;

	// Boundary path
	ctx.beginPath();

	// Half angle of arc
	var theta = 0.125;

	// Arc across
	ctx.arc(0, 0, ro, -Math.PI / 2 + theta, -Math.PI / 2 - theta, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, -Math.PI / 2 - theta, -Math.PI / 2 + theta, false);

	// Close path
	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = "rgba(200,200,200,0.75)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "rgba(120,120,120,0.75)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
};

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.SidePort.prototype.groupDescription = function() {
	return "Sideport at ";
};

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.SidePort.prototype.description = function() {
	return this.clockHour();
};

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.SidePort.prototype.groupDescriptionEnd = function() {
	return " o'clock";
};

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * SMILE (Photo Therapeutic Keratectomy
 *
 * @class SMILE
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.SMILE = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "SMILE";

	// Derived parameters
	this.diameter = 8;
	this.incisionLength = 0;
	
	// Other parameters
	this.thickness = 15;
	this.spotSeparation = "";
	this.lineSeparation = "";
	this.energyLevel = "";

	// Saved parameters
	this.savedParameterArray = [
		'scaleX', 
		'scaleY',
		'arc', 
		'diameter',
		'incisionLength', 
		'thickness',
		'spotSeparation', 
		'lineSeparation',
		'energyLevel',
	];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {
		'diameter':'lenticule diameter (mm)', 
		'incisionLength':'Pocket length (mm)',
		'thickness':'Lenticule bed thickness (um)', 
		'spotSeparation':'Spot separation',
		'lineSeparation':'Line separation',
		'energyLevel':'Energy level (uJ)',
	};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.SMILE.prototype = new ED.Doodle;
ED.SMILE.prototype.constructor = ED.SMILE;
ED.SMILE.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.SMILE.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
}

/**
 * Sets default dragging attributes
 */
ED.SMILE.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;
	this.isArcSymmetrical = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.7, +0.9);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.7, +0.9);
	this.parameterValidationArray['arc']['range'].setMinAndMax(1/3, 2/3);

	// Derived parameters
	this.parameterValidationArray['diameter'] = {
		kind: 'derived',
		type: 'float',
		range: new ED.Range(7, 9),
		precision: 1,
		animate: true
	};
	this.parameterValidationArray['incisionLength'] = {
		kind: 'derived',
		type: 'float',
		range: new ED.Range(2, 4),
		precision: 1,
		animate: true
	};
	
	// Other parameters
	this.parameterValidationArray['thickness'] = {
		kind: 'other',
		type: 'int',
		range: new ED.Range(10, 30),
		animate: false
	};
	this.parameterValidationArray['spotSeparation'] = {
		kind: 'other',
		type: 'string',
		list: ['0.5um', '0.6um', '0.7um', '0.8um', '0.9um', '1.0um'],
		animate: false
	};
	this.parameterValidationArray['lineSeparation'] = {
		kind: 'other',
		type: 'string',
		list: ['0.5um', '0.6um', '0.7um', '0.8um', '0.9um', '1.0um'],
		animate: false
	};
	this.parameterValidationArray['energyLevel'] = {
		kind: 'other',
		type: 'float',
		range: new ED.Range(0.1, 2),
		precision: 2,
		animate: false
	};
}

/**
 * Sets default parameters
 */
ED.SMILE.prototype.setParameterDefaults = function() {
	this.setParameterFromString('diameter', '8.0');
	this.setParameterFromString('incisionLength', '4.0');
	this.setParameterFromString('thickness', '15');
	this.setParameterFromString('spotSeparation', '0.6um');
	this.setParameterFromString('lineSeparation', '0.6um');
	this.setParameterFromString('energyLevel', '0.17');
	
	/*
	a) what are the default laser energy (depends on the individual machine and user preference, recommended around 170nJ = energy setting 34), spot and line separations ( 4.5 m in the lamellar interfaces, I believe 2m in the sidecuts) for SMILE
	b) what are the standard side pocket dimensions?  we call it access incision  Do these vary? Below 4mm length. Depending on surgeon preference and skills typically around 3 mm, a few surgeons go down to 2 mm. Donald and Jod are doing this in Singapore
	*/
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.SMILE.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'scaleX':
			returnArray['diameter'] = _value * 10;
			break;

		case 'arc':
			returnArray['incisionLength'] = _value * 6;
			break;

		case 'diameter':
			returnArray['scaleX'] = parseFloat(_value)/10;
			returnArray['scaleY'] = parseFloat(_value)/10;
			break;
			
		case 'incisionLength':
			returnArray['arc'] = _value / 6;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.SMILE.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.SMILE.superclass.draw.call(this, _point);

	// SMILE
	var r = 320;
	var theta = this.arc / 2;		

	// Boundary path
	ctx.beginPath();

	// Do a circle
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Close path to produce straight line
	ctx.closePath();

	// Create transparent fill pattern
	ctx.fillStyle = "rgba(155,255,255,0)";

	// Transparent stroke
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgba(100,100,100,0.9)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Flap
		ctx.beginPath();
		ctx.arc(0, 0, r * 0.8, 0, Math.PI * 2, true);
		ctx.setLineDash([8,12]);
		ctx.stroke();
		ctx.setLineDash([]);
		
		// Incision
		ctx.beginPath();
		var arcStart = -Math.PI / 2 + theta;
		var arcEnd = -Math.PI / 2 - theta;
		ctx.arc(0, 0, r, arcStart, arcEnd, true);
		ctx.arc(0, 0, r - 30, arcEnd, arcStart, false);
		ctx.closePath();
		ctx.fillStyle = "rgba(100,100,200,0.75)";
		ctx.fill();
	}
	
	// Coordinates of handles (in canvas plane)
	var startHandle = new ED.Point(-r * Math.sin(theta), -r * Math.cos(theta));
	this.handleArray[0].location = this.transform.transformPoint(startHandle);
	var point = new ED.Point(0, 0)
	point.setWithPolars(r, Math.PI/4);
	this.handleArray[2].location = this.transform.transformPoint(point);
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.SMILE.prototype.description = function() {
	var returnString = "";

	returnString = "SMILE";

	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * 
 *
 * @class SPEE
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.SPEE = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "SPEE";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexY', 'apexX', 'scaleX','scaleY', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.SPEE.prototype = new ED.Doodle;
ED.SPEE.prototype.constructor = ED.SPEE;
ED.SPEE.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.SPEE.prototype.setHandles = function() {
	
	// pigmentation density
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	
	// shape
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
	this.handleArray[4].isRotatable = true;
}

/**
 * Sets default properties
 */
ED.SPEE.prototype.setPropertyDefaults = function() {
	this.isSqueezable = true;
	
	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-400, +400);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-400, +400);
	
	
	this.handleVectorRangeArray = new Array();
	var range = new Object;
	range.length = new ED.Range(+1, +150);
	range.angle = new ED.Range(0.5*Math.PI, 0.5*Math.PI);
	this.handleVectorRangeArray[0] = range;
}

/**
 * Sets default parameters
 */
ED.SPEE.prototype.setParameterDefaults = function() {
	this.originX = 150;
	this.originY = 40;
	this.apexY = -50;
	this.apexX = 170;
	
	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	var point = new ED.Point(40, 0);
	this.addPointToSquiggle(point);

}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.SPEE.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.SPEE.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Invisible boundary
	ctx.ellipse(0, 0, Math.abs(this.apexY), Math.abs(this.apexX), 0.5 * Math.PI, 0, 2 * Math.PI);
	
	// Set line attributes  
	ctx.lineWidth = 1;
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";
	ctx.fillStyle = "rgba(0,0,0,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Coordinates of expert handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[0]);
	
	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Pigment dots
		
		// Colours
		var fill = "rgba(50,205,50,1)";
		
		// Pigmentation density
		var pD = this.squiggleArray[0].pointsArray[0].x;
		
		// Radius
		var dr = 2;

		// Calculate shape area
		var A = Math.PI * Math.abs(this.apexX * this.apexY);
		
		// Calculate number of dots within boundary
		var n = A / 250 * (pD / 30);
		
		var p = new ED.Point(0, 0);
		
		// Calculate random positions for dots			
		for (var i = 0; i < n; i++) {
			var j = (i < 150) ? i : (i < 199) ? i - 50 : (i < 249) ? i - 100 : (i < 299) ? i - 150 : (i < 349) ? i - 200 : i - 250;

			var k = (i < 200) ? i : (i < 398) ? (i - 199) : (i < 397) ? (i - 298) : (i - 396);

			var r = Math.sqrt(n * ED.randomArray[k]);
			var rX = this.apexX * ED.randomArray[k];
			var rY = this.apexY * ED.randomArray[j];
			var theta = 2 * Math.PI * ED.randomArray[j + 50];
							
			p.x = rX * Math.cos(theta*r);
			p.y = rY * Math.sin(theta*r);
			
			// Draw dot
			this.drawSpot(ctx, p.x, p.y, dr, fill);
		}
		
		// Additionally draw spots at boundarys to ensure indicated
		this.drawSpot(ctx, 0, Math.abs(this.apexY), dr, fill);
		this.drawSpot(ctx, 0, -1 * Math.abs(this.apexY), dr, fill);
		this.drawSpot(ctx, Math.abs(this.apexX), 0, dr, fill);
		this.drawSpot(ctx, -1 * Math.abs(this.apexX), 0, dr, fill);
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.SPEE.prototype.groupDescription = function() {	
	return "Superficial punctate epithelial erosions";
}

/**
 * Star fold of PVR
 *
 * @class StarFold
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.StarFold = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "StarFold";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexY', 'scaleX', 'scaleY', 'arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.StarFold.prototype = new ED.Doodle;
ED.StarFold.prototype.constructor = ED.StarFold;
ED.StarFold.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.StarFold.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.StarFold.prototype.setPropertyDefaults = function() {
	this.isOrientated = true;
	this.isSqueezable = true;
	this.isRotatable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(+50, +250);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.125, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.125, +1.5);
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 6, Math.PI * 2);
}

/**
 * Sets default parameters
 */
ED.StarFold.prototype.setParameterDefaults = function() {
	this.apexY = 50;

	// Example of x4 drawing in doodle space
	this.scaleX = 0.25;
	this.scaleY = 0.25;

	// Place at 6 o'clock
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		var p = new ED.Point(doodle.originX, doodle.originY);

		var np = new ED.Point(0, 0);
		np.setWithPolars(p.length(), p.direction() + Math.PI / 6);

		this.move(np.x, np.y);
	} else {
		this.move(0, 400);
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.StarFold.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.StarFold.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	ctx.moveTo(0, -this.apexY);
	ctx.bezierCurveTo(100, -50, 260, -240, 300, -200);
	ctx.bezierCurveTo(340, -160, 100, -100, 2 * this.apexY, 0);
	ctx.bezierCurveTo(100, 100, 340, 160, 300, 200);
	ctx.bezierCurveTo(260, 240, 100, 50, 0, this.apexY);
	ctx.bezierCurveTo(-100, 50, -260, 240, -300, 200);
	ctx.bezierCurveTo(-340, 160, -100, 100, -2 * this.apexY, 0);
	ctx.bezierCurveTo(-100, -100, -340, -160, -300, -200);
	ctx.bezierCurveTo(-260, -240, -100, -50, 0, -this.apexY);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "lightgreen";
	ctx.strokeStyle = "green";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Calculate arc for doodles with no natural arc setting
	this.arc = Math.atan2(600 * this.scaleX, Math.abs(this.originY));

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(-300, 200));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.StarFold.prototype.description = function() {
	var returnString = "Star fold at ";

	// Location (clockhours)
	returnString += this.clockHour() + " o'clock";

	return returnString;
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.StarFold.prototype.snomedCode = function() {
	return 232018006;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.StarFold.prototype.diagnosticHierarchy = function() {
	return 2;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * SteepAxis
 *
 * @class SteepAxis
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.SteepAxis = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "SteepAxis";

	// Derived parameters
	this.axis = '0';

	// Saved parameters
	this.savedParameterArray = ['rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.SteepAxis.prototype = new ED.Doodle;
ED.SteepAxis.prototype.constructor = ED.SteepAxis;
ED.SteepAxis.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.SteepAxis.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isShowHighlight = false;
	this.isMoveable = false;
	this.addAtBack = true;
	this.isUnique = true;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['axis'] = {
		kind: 'derived',
		type: 'mod',
		range: new ED.Range(0, 180),
		clock: 'bottom',
		animate: true
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.SteepAxis.prototype.setParameterDefaults = function() {
	this.setParameterFromString('axis', '0');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.SteepAxis.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'rotation':
			returnArray['axis'] = (360 - 180 * _value / Math.PI) % 180;
			break;

		case 'axis':
			returnArray['rotation'] = (180 - _value) * Math.PI / 180;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.SteepAxis.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.SteepAxis.superclass.draw.call(this, _point);

	// Radius of outer curve just inside ora on right and left fundus diagrams
	var ro = 300;

	// Boundary path
	ctx.beginPath();

	// Arc a circle
	ctx.arc(0, 0, ro, 0, 2 * Math.PI, true);

	// Set line attributes
	ctx.lineWidth = 8;
	ctx.fillStyle = "rgba(255,255,255,0)";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		var d = 140;
		ctx.beginPath();
		ctx.moveTo(-ro - d, 0);
		ctx.lineTo(ro + d, 0);

		ctx.lineWidth = 8;
		ctx.strokeStyle = "gray";
		ctx.stroke();

		var h = 200;
		var r = 540;
		ctx.beginPath();
		ctx.moveTo(-ro, 0);
		ctx.arcTo(0, h, ro, 0, r);
		ctx.closePath();

		ctx.strokeStyle = "gray";
		ctx.fillStyle = "lightgray";
		ctx.fill();
		ctx.stroke();
	}

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 *
 *
 * @class STFB
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.STFB = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "STFB";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY', 'rotation'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.STFB.prototype = new ED.Doodle;
ED.STFB.prototype.constructor = ED.STFB;
ED.STFB.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.STFB.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[2].isRotatable = true;
}

/**
 * Sets default dragging attributes
 */
ED.STFB.prototype.setPropertyDefaults = function() {
	this.isSqueezable = true;
		
	// Update component of validation array for simple parameters
	this.parameterValidationArray['originX']['range'].setMinAndMax(-380, +380);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-370, +370);
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(0.5, 5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(0.5, 3);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.STFB.prototype.setParameterDefaults = function() {	
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		var np = new ED.Point(doodle.originX, doodle.originY + 70);
		this.move(np.x, np.y);
	} else {
		this.move(120, -200);
	};
	this.rotation = 0.25 * Math.PI;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.STFB.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.STFB.superclass.draw.call(this, _point);
	
	// Boundary path
	ctx.beginPath();
	
	ctx.ellipse(0, 0, 15, 40, 0, 0, 2 * Math.PI);
	
	// Set line attributes
	ctx.lineWidth = 3;
	ctx.fillStyle = "#402A15";
	ctx.strokeStyle = "#402A15";
	
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(15, -40);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);
	
	// Return value indicating successful hittest
	return this.isClicked;
}


/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.STFB.prototype.description = function() {
	var position = "";
	var str = "Sub tarsal foreign body";
	
	if (this.originY < -110) position = "Upper lid ";
	else if (this.originY > 110) position = "Lower lid ";
	
	var returnValue = (position.length>0) ? position + str.toLowerCase() : str;

	return returnValue;
}


/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */
 
/**
 * APattern
 *
 * @class APattern
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.APattern = function(_drawing, _parameterJSON)
{
    this.savedParameterArray = ['rotation'];
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

    // Set classname
	this.className = "APattern";
}

/**
 * Sets superclass and constructor
 */
ED.APattern.prototype = new ED.Doodle;
ED.APattern.prototype.constructor = ED.APattern;
ED.APattern.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.APattern.prototype.setHandles = function()
{
}

/**
 * Sets default dragging attributes
 */
ED.APattern.prototype.setPropertyDefaults = function()
{
	this.isSelectable = false;
	this.isOrientated = false;
	this.isScaleable = false;
	this.isSqueezable = false;
	this.isMoveable = false;
	this.isRotatable = false;
}

/**
 * Sets default parameters
 */
ED.APattern.prototype.setParameterDefaults = function()
{
    if(this.drawing.eye == ED.eye.Right)
    {
        this.rotation = Math.PI/8;
    }
    else
    {
        this.rotation = -Math.PI/8;        
    }
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.APattern.prototype.draw = function(_point)
{
	// Get context
	var ctx = this.drawing.context;
	
	// Call draw method in superclass
	ED.APattern.superclass.draw.call(this, _point);
    
	// Boundary path
	ctx.beginPath();
    
	// Dotted Line
    var dash = 4;
    var gap = 4;
    var length = 0;
    var startY = -500;
    ctx.moveTo(0, startY)
    while (length < -2*startY)
    {
        length += dash;
        ctx.lineTo(0, startY + length);
        length += gap;            
        ctx.moveTo(0, startY + length);
    }
    
	// Close path
	ctx.closePath();
	
	// Set line attributes
	ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(80, 80, 80, 1)";
    
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Other stuff here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw)
	{
	}
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);
	
	// Return value indicating successful hittest
	return this.isClicked;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */
 
/**
 * 
 *
 * @class InverseYPattern
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.InverseYPattern = function(_drawing, _parameterJSON)
{
    this.savedParameterArray = ['side'];

    // Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
	
	// Set classname
	this.className = "InverseYPattern";
}

/**
 * Sets superclass and constructor
 */
ED.InverseYPattern.prototype = new ED.Doodle;
ED.InverseYPattern.prototype.constructor = ED.InverseYPattern;
ED.InverseYPattern.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.InverseYPattern.prototype.setHandles = function()
{
}

/**
 * Sets default dragging attributes
 */
ED.InverseYPattern.prototype.setPropertyDefaults = function()
{
	this.isSelectable = false;
	this.isOrientated = false;
	this.isScaleable = false;
	this.isSqueezable = false;
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;
}

/**
 * Sets default parameters
 */
ED.InverseYPattern.prototype.setParameterDefaults = function()
{
    if(this.drawing.eye == ED.eye.Right)
    {
        this.side = 1;
    }
    else
    {
        this.side = -1;        
    }
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.InverseYPattern.prototype.draw = function(_point)
{
	// Get context
	var ctx = this.drawing.context;
	
	// Call draw method in superclass
	ED.InverseYPattern.superclass.draw.call(this, _point);
    
	// Boundary path
	ctx.beginPath();
    
	// Dotted Line
    var dash = 4;
    var gap = 4;
    var length = 0;
    var depth = 0;
    var startY = -450;
        
    ctx.moveTo(-350 * this.side, -1*startY);
    while (length < 185)
    {
        length += 2 * dash;
        depth += dash;
        ctx.lineTo((-350 + length) * this.side, -1*startY - depth);
        length += gap; 
        depth += gap;           
        ctx.moveTo((-350 + length) * this.side, -1*startY - depth);
    }
    
    length = 0;
    depth = 0;
    ctx.moveTo(0, startY - 20);
    while (length < 40)
    {
        depth += dash * 2;
        ctx.lineTo(0, startY + depth - 20);
        length += gap; 
        depth += gap;             
        ctx.moveTo(-0, startY + depth - 20);
    }
    
	// Close path
	ctx.closePath();
	
	// Set line attributes
	ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(80, 80, 80, 1)";
    
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Other stuff here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw)
	{
	}
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);
	
	// Return value indicating successful hittest
	return this.isClicked;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * 
 *
 * @class OrthopticEye
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.OrthopticEye = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "OrthopticEye";

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.OrthopticEye.prototype = new ED.Doodle;
ED.OrthopticEye.prototype.constructor = ED.OrthopticEye;
ED.OrthopticEye.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.OrthopticEye.prototype.setHandles = function() {
}

/**
 * Sets default dragging attributes
 */
ED.OrthopticEye.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
	this.isOrientated = false;
	this.isScaleable = false;
	this.isSqueezable = false;
	this.isMoveable = false;
	this.isRotatable = false;
    this.isFilled = false;
}

/**
 * Sets default parameters
 */
ED.OrthopticEye.prototype.setParameterDefaults = function() {
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.OrthopticEye.prototype.draw = function(_point) {
	
	// Get context
	var ctx = this.drawing.context;
	
	// Call draw method in superclass
	ED.OrthopticEye.superclass.draw.call(this, _point);
    
	// Boundary path
	//ctx.beginPath();
	
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Other stuff here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		
        // Set line attributes
        ctx.lineWidth = 12;
        ctx.strokeStyle = "rgba(80,80,80,1)";
        
        // Upper Eye lid
        ctx.beginPath();
        ctx.arc(0,150,500,-Math.PI*3/4,-Math.PI*1/4,false);
        ctx.stroke();
        
        // Lower Eye lid
        ctx.beginPath();
        ctx.arc(0,-150,500,Math.PI*1/4,Math.PI*3/4,false);
        ctx.stroke();
	}
	
	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */
 
/**
 * 
 *
 * @class OrthopticShading
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.OrthopticShading = function(_drawing, _parameterJSON)
{
	
	// Set classname
	this.className = "OrthopticShading";
	
	// parameters for underaction drop down calculations
	this.uR = false;
	this.cR = false;
	this.dR = false;
	this.rL = false;
	this.cL = false;
	this.dL = false;

	this.savedParameterArray = ['originX', 'originY', 'rotation', 'apexX', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.OrthopticShading.prototype = new ED.Doodle;
ED.OrthopticShading.prototype.constructor = ED.OrthopticShading;
ED.OrthopticShading.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.OrthopticShading.prototype.setHandles = function()
{
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
	this.handleArray[3].isRotatable = true;
}

/**
 * Sets default dragging attributes
 */
ED.OrthopticShading.prototype.setPropertyDefaults = function()
{
	this.isSelectable = true;
	this.isOrientated = false; // MSC BC edit
	this.isScaleable = true;
	this.isSqueezable = true;
	this.isMoveable = true;
	this.isRotatable = true;
	
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-360, +360);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-360, -3);
}

/**
 * Sets default parameters
 */
ED.OrthopticShading.prototype.setParameterDefaults = function()
{
	this.apexX = 350;
	this.apexY = -100;

	this.setRotationWithDisplacements(0, 90.5);

//     this.originY = -200;
}



/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.OrthopticShading.prototype.draw = function(_point)
{
	// Get context
	var ctx = this.drawing.context;
	
	// Call draw method in superclass
	ED.OrthopticShading.superclass.draw.call(this, _point);
    
	// Boundary path
	ctx.beginPath();
    
	// Rectangular area
	var w = this.apexX - -350;
	var h = this.apexY - -350;
	ctx.rect(-350, -350, w, h);
    
	// Close path
	ctx.closePath();
    
    // create pattern
	ctx.fillStyle = "rgba(190, 190, 190, 0.55)";
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";
	
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Other stuff here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw)
	{
        ctx.beginPath();
        ctx.moveTo(-350, this.apexY);
        var dash = 42;
        var gap = 20;
        var length = 0;
        while (length < w-40)
        {
            length += dash;
            ctx.lineTo(-350 + length, this.apexY);
            length += gap;            
            ctx.moveTo(-350 + length, this.apexY);
        }
        ctx.lineTo(this.apexX, this.apexY);
        
        // Draw line
        ctx.lineWidth = 12;
        ctx.strokeStyle = "rgba(80, 80, 80, 1)";
        ctx.stroke();
	}
	
	// Coordinates of handles (in canvas plane)
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);
		this.calculateUnderActions();
		
	// Return value indicating successful hittest
	return this.isClicked;
}


/**
 * 
 */
ED.OrthopticShading.prototype.calculateUnderActions = function() {
	var x;
	var y;
	var d;
	var intersectionPoint;
	
	// shading boundary line
	var sp = this.transform.transformPoint(new ED.Point(-350, this.apexY));
	var ep = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));
	
	var dy1 = ep.y - sp.y;
	var dx1 = ep.x - sp.x;
	var m1 = dy1/dx1;	
	var c1 = sp.y - m1*sp.x;
	
	if (dx1 == 0) {
		m1 = 0;
		c1 = 70;
	}
	
	
	// in canvas plane
	var origin = new ED.Point(100,100);

	var uR = new ED.Point(30,30);
	var dL = new ED.Point(170,170);
	var m2 = 1;
	// if lines not parallel
	if (m1 !== m2) {
		// find intersection point: 0 = m1*x + c1 - x
		x = -c1 / (m1-1);
		y = x;
		intersectionPoint = new ED.Point(x,y);
		
		// up right
		d = uR.distanceTo(new ED.Point(x,y));
		if (y>=30 && y<=100 && (sp.x<=100 || ep.x<=100) && (sp.y<=100 || ep.y<=100)) {
			if (d>79.192) this.uR = "-4";
			else if (d>59.394) this.uR = "-3";
			else if (d>39.596) this.uR = "-2";
			else if (d>19.798) this.uR = "-1";
/*
			if (d>98.99) this.uR = "-4";
			else if (d>74.2425) this.uR = "-3";
			else if (d>49.495) this.uR = "-2";
			else if (d>24.7475) this.uR = "-1";
*/
			else this.uR = "-0.5";			
		}
// 		else if (this.rotation < Math.PI && y>100) this.uR = "<-4";
		else this.uR = false;
		
		// down left
		d = dL.distanceTo(new ED.Point(x,y));
		if (y<=170 && y>=100 && (sp.x>=100 || ep.x>=100) && (sp.y>=100 || ep.y>=100)) {
			if (d>79.192) this.dL = "-4";
			else if (d>59.394) this.dL = "-3";
			else if (d>39.596) this.dL = "-2";
			else if (d>19.798) this.dL = "-1";
			else this.dL = "-0.5";			
		}
		else this.dL = false;
	}
	
	/// y=100
	var cR = new ED.Point(30,100);
	var cL = new ED.Point(170,100);
	var m3 = 0;
	if (m1 !== m3 || dx1 == 0) {
		// find intersection point: x = (y-c)/m
		y = 100;
		x = (y-c1) / m1;
		intersectionPoint = new ED.Point(x,y);
		
		// centre right
		d = cR.distanceTo(new ED.Point(x,y));
		if (x>=30 && x<=100) {
			if (d>56) this.cR = "-4";
			else if (d>42) this.cR = "-3";
			else if (d>28) this.cR = "-2";
			else if (d>14) this.cR = "-1";
			else this.cR = "-0.5";			
		}
		else this.cR = false;
		
		// centre left
		d = cL.distanceTo(new ED.Point(x,y));
		if (x<=170 && x>=100) {
			if (d>56) this.cL = "-4";
			else if (d>42) this.cL = "-3";
			else if (d>28) this.cL = "-2";
			else if (d>14) this.cL = "-1";
			else this.cL = "-0.5";			
		}
		else this.cL = false;
	}
	
	var dR = new ED.Point(30,170);
	var uL = new ED.Point(170,30);
	var m4 = -1;
	if (m1 !== m4) {
		// find intersection point: (200-c1)/(m1+1) = x
		x = (200-c1) / (m1+1);
		y = -x + 200;
		intersectionPoint = new ED.Point(x,y);
		
		// up left
		d = uL.distanceTo(new ED.Point(x,y));
		if (y>=30 /* && y<=100 */ && (sp.x>=100 || ep.x>=100) && (sp.y<=100 || ep.y<=100)) {
			if (d>79.192) this.uL = "-4";
			else if (d>59.394) this.uL = "-3";
			else if (d>39.596) this.uL = "-2";
			else if (d>19.798) this.uL = "-1";
			else this.uL = "-0.5";			
		}
		else this.uL = false;


		// down right
		d = dR.distanceTo(new ED.Point(x,y));
		if (y<=170 && y>=100 && (sp.x<=100 || ep.x<=100) && (sp.y>=100 || ep.y>=100)) {
			if (d>79.192) this.dR = "-4";
			else if (d>59.394) this.dR = "-3";
			else if (d>39.596) this.dR = "-2";
			else if (d>19.798) this.dR = "-1";
			else this.dR = "-0.5";			
		}
		else this.dR = false;
	}

}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */
 
/**
 * UpDrift
 *
 * @class UpDrift
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.UpDrift = function(_drawing, _parameterJSON)
{

	this.savedParameterArray = ['originX', 'originY', 'quadrantPoint'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
	
	// Set classname
	this.className = "UpDrift";
}

/**
 * Sets superclass and constructor
 */
ED.UpDrift.prototype = new ED.Doodle;
ED.UpDrift.prototype.constructor = ED.UpDrift;
ED.UpDrift.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.UpDrift.prototype.setHandles = function()
{
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
}

/**
 * Sets default dragging attributes
 */
ED.UpDrift.prototype.setPropertyDefaults = function()
{
	this.isSelectable = true;
	this.isOrientated = false;
	this.isScaleable = false;
	this.isSqueezable = false;
	this.isMoveable = true;
	this.isRotatable = false;
    this.snapToQuadrant = true;
    this.quadrantPoint = new ED.Point(335, 220);
    
    this.handleVectorRangeArray = new Array();
	var range = new Object;
	range.length = new ED.Range(+50, +320);
	range.angle = new ED.Range(1.75*Math.PI, 1.75*Math.PI);
	this.handleVectorRangeArray[0] = range;
}

/**
 * Sets default parameters
 */
ED.UpDrift.prototype.setParameterDefaults = function()
{
	
	// Create a squiggle to store handle points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	var point = new ED.Point(-125, -125);
	this.addPointToSquiggle(point);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.UpDrift.prototype.draw = function(_point)
{
    // Use scale to flip arrow into correct position for quadrant
    this.scaleX = this.originX/Math.abs(this.originX);
    this.scaleY = this.originY/Math.abs(this.originY);
    
    
	// Get context
	var ctx = this.drawing.context;
	
	// Call draw method in superclass
	ED.UpDrift.superclass.draw.call(this, _point);
    
	// Boundary path
	ctx.beginPath();
	
	var c = Math.abs(this.squiggleArray[0].pointsArray[0].x);
    var r = 100 + c;
    
	// Rectangular area
	ctx.rect(c * -1, c * -1, r, r);
    
	// Close path
	ctx.closePath();
	
	// Set line attributes
	// Set line attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = ctx.fillStyle;
    
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Coordinates of expert handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[0]);
	
	// Other stuff here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw)
	{
        // Arrow body
        ctx.beginPath();
        ctx.arc(c * -1, 100, r, -Math.PI/2, -0.1, false);
        ctx.lineWidth = 6;
        ctx.lineJoin = 'miter';
        ctx.strokeStyle = "rgba(80, 80, 80, 1)";
        ctx.fillStyle = "rgba(0, 0, 0, 0)";
        if (this.isSelected) {
	        ctx.shadowBlur = 10;
			ctx.shadowColor = "rgba(0,0,0,0.9)";
        }
        ctx.stroke();
        
        // Arrow head
        ctx.beginPath();
        ctx.moveTo(100, 100);
        ctx.lineTo(70, 60);
        ctx.lineTo(130, 60);
        ctx.closePath();
        ctx.fillStyle = "rgba(80, 80, 80, 1)";
        if (this.isSelected) {
	        ctx.shadowBlur = 10;
			ctx.shadowColor = "rgba(0,0,0,0.9)";
        }
        ctx.fill();
	}
	
// 	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);
	
	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.UpDrift.prototype.description = function()
{
    var returnString = "Up drift";
	
	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */
 
/**
 * UpShoot
 *
 * @class UpShoot
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.UpShoot = function(_drawing, _parameterJSON)
{

	this.savedParameterArray = ['originX', 'originY', 'quadrantPoint'];
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
	
	// Set classname
	this.className = "UpShoot";
}

/**
 * Sets superclass and constructor
 */
ED.UpShoot.prototype = new ED.Doodle;
ED.UpShoot.prototype.constructor = ED.UpShoot;
ED.UpShoot.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.UpShoot.prototype.setHandles = function()
{
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
}

/**
 * Sets default dragging attributes
 */
ED.UpShoot.prototype.setPropertyDefaults = function()
{
	this.isSelectable = true;
	this.isOrientated = false;
	this.isScaleable = false;
	this.isSqueezable = false;
	this.isMoveable = true;
	this.isRotatable = false;
    this.snapToQuadrant = true;
    this.quadrantPoint = new ED.Point(335, 220);
    
    this.handleVectorRangeArray = new Array();
	var range = new Object;
	range.length = new ED.Range(+50, +320);
	range.angle = new ED.Range(1.75*Math.PI, 1.75*Math.PI);
	this.handleVectorRangeArray[0] = range;
}

/**
 * Sets default parameters
 */
ED.UpShoot.prototype.setParameterDefaults = function()
{
	// Create a squiggle to store handle points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	var point = new ED.Point(-125, -125);
	this.addPointToSquiggle(point);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.UpShoot.prototype.draw = function(_point)
{
    // Use scale to flip arrow into correct position for quadrant
    this.scaleX = this.originX/Math.abs(this.originX);
    this.scaleY = this.originY/Math.abs(this.originY);
    
	// Get context
	var ctx = this.drawing.context;
	
	// Call draw method in superclass
	ED.UpShoot.superclass.draw.call(this, _point);
    
	// Boundary path
	ctx.beginPath();
    
	var c = Math.abs(this.squiggleArray[0].pointsArray[0].x);
    var r = 100 + c;
    
	// Rectangular area
	ctx.rect(c * -1, c * -1, r, r);
    
	// Close path
	ctx.closePath();
	
	// Set line attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = ctx.fillStyle;
    
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Coordinates of expert handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[0]);
	
	// Other stuff here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw)
	{
        // Arrow shaft
        ctx.beginPath();
        ctx.moveTo(c * -1, c * -1);
        ctx.lineTo(c * -1 + r, c * -1);
        ctx.lineTo(c * -1 + r, c * -1 + r);
        
        ctx.lineWidth = 6;
        ctx.lineJoin = 'miter';
        ctx.strokeStyle = "rgba(80, 80, 80, 1)";
        if (this.isSelected) {
	        ctx.shadowBlur = 10;
			ctx.shadowColor = "rgba(0,0,0,0.9)";
        }
        ctx.stroke();
        
        // Arrow head
        ctx.beginPath();
        ctx.moveTo(100, 100);
        ctx.lineTo(70, 60);
        ctx.lineTo(130, 60);
        ctx.closePath();
        if (this.isSelected) {
	        ctx.shadowBlur = 10;
			ctx.shadowColor = "rgba(0,0,0,0.9)";
        }
        ctx.fillStyle = "rgba(80, 80, 80, 1)";
        ctx.fill();
	}
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);
	
	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.UpShoot.prototype.description = function()
{
    var returnString = "Up shoot";
	
	return returnString;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */
 
/**
 * VPattern
 *
 * @class VPattern
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.VPattern = function(_drawing, _parameterJSON)
{
    this.savedParameterArray = ['rotation'];
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
	
	// Set classname
	this.className = "VPattern";
}

/**
 * Sets superclass and constructor
 */
ED.VPattern.prototype = new ED.Doodle;
ED.VPattern.prototype.constructor = ED.VPattern;
ED.VPattern.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.VPattern.prototype.setHandles = function()
{
}

/**
 * Sets default dragging attributes
 */
ED.VPattern.prototype.setPropertyDefaults = function()
{
	this.isSelectable = false;
	this.isOrientated = false;
	this.isScaleable = false;
	this.isSqueezable = false;
	this.isMoveable = false;
	this.isRotatable = false;
}

/**
 * Sets default parameters
 */
ED.VPattern.prototype.setParameterDefaults = function()
{
    if(this.drawing.eye == ED.eye.Right)
    {
        this.rotation = -Math.PI/8;
    }
    else
    {
        this.rotation = Math.PI/8;        
    }
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.VPattern.prototype.draw = function(_point)
{
	// Get context
	var ctx = this.drawing.context;
	
	// Call draw method in superclass
	ED.VPattern.superclass.draw.call(this, _point);
    
	// Boundary path
	ctx.beginPath();
    
	// Dotted Line
    var dash = 4;
    var gap = 4;
    var length = 0;
    var startY = -500;
    ctx.moveTo(0, startY)
    while (length < -2*startY)
    {
        length += dash;
        ctx.lineTo(0, startY + length);
        length += gap;            
        ctx.moveTo(0, startY + length);
    }
    
	// Close path
	ctx.closePath();
	
	// Set line attributes
	ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(80, 80, 80, 1)";
    
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Other stuff here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw)
	{
	}
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);
	
	// Return value indicating successful hittest
	return this.isClicked;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */
 
/**
 * 
 *
 * @class XPattern
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.XPattern = function(_drawing, _parameterJSON)
{
    this.savedParameterArray = ['rotation'];

    // Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
	
	// Set classname
	this.className = "XPattern";
}

/**
 * Sets superclass and constructor
 */
ED.XPattern.prototype = new ED.Doodle;
ED.XPattern.prototype.constructor = ED.XPattern;
ED.XPattern.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.XPattern.prototype.setHandles = function()
{
}

/**
 * Sets default dragging attributes
 */
ED.XPattern.prototype.setPropertyDefaults = function()
{
	this.isSelectable = false;
	this.isOrientated = false;
	this.isScaleable = false;
	this.isSqueezable = false;
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;
}

/**
 * Sets default parameters
 */
ED.XPattern.prototype.setParameterDefaults = function()
{
    if(this.drawing.eye == ED.eye.Right)
    {
        this.rotation = 0;
    }
    else
    {
        this.rotation = Math.PI;        
    }
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.XPattern.prototype.draw = function(_point)
{
	// Get context
	var ctx = this.drawing.context;
	
	// Call draw method in superclass
	ED.XPattern.superclass.draw.call(this, _point);
    
	// Boundary path
	ctx.beginPath();
    
	// Dotted Line
    var dash = 4;
    var gap = 4;
    var length = 0;
    var depth = 0;
    var startY = -450;
        
    ctx.moveTo(-350, startY);
    while (length < 185)
    {
        length += 2 * dash;
        depth += dash;
        ctx.lineTo(-350 + length, startY + depth);
        length += gap; 
        depth += gap;           
        ctx.moveTo(-350 + length, startY + depth);
    }
    
    length = 0;
    depth = 0;
    ctx.moveTo(-350, startY * -1);
    while (length < 185)
    {
        length += 2 * dash;
        depth += dash;
        ctx.lineTo(-350 + length, startY*-1 - depth);
        length += gap; 
        depth += gap;             
        ctx.moveTo(-350 + length, startY*-1 - depth);
    }
    
	// Close path
	ctx.closePath();
	
	// Set line attributes
	ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(80, 80, 80, 1)";
    
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Other stuff here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw)
	{
	}
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);
	
	// Return value indicating successful hittest
	return this.isClicked;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */
 
/**
 * YPattern
 *
 * @class YPattern
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.YPattern = function(_drawing, _parameterJSON)
{
    this.savedParameterArray = ['side'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
	
	// Set classname
	this.className = "YPattern";
}

/**
 * Sets superclass and constructor
 */
ED.YPattern.prototype = new ED.Doodle;
ED.YPattern.prototype.constructor = ED.YPattern;
ED.YPattern.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.YPattern.prototype.setHandles = function()
{
}

/**
 * Sets default dragging attributes
 */
ED.YPattern.prototype.setPropertyDefaults = function()
{
	this.isSelectable = false;
	this.isOrientated = false;
	this.isScaleable = false;
	this.isSqueezable = false;
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;
}

/**
 * Sets default parameters
 */
ED.YPattern.prototype.setParameterDefaults = function()
{
    if(this.drawing.eye == ED.eye.Right)
    {
        this.side = 1;
    }
    else
    {
        this.side = -1;        
    }
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.YPattern.prototype.draw = function(_point)
{
	// Get context
	var ctx = this.drawing.context;
	
	// Call draw method in superclass
	ED.YPattern.superclass.draw.call(this, _point);
    
	// Boundary path
	ctx.beginPath();
    
	// Dotted Line
    var dash = 4;
    var gap = 4;
    var length = 0;
    var depth = 0;
    var startY = -450;
        
    ctx.moveTo(-350 * this.side, startY);
    while (length < 185)
    {
        length += 2 * dash;
        depth += dash;
        ctx.lineTo((-350 + length) * this.side, startY + depth);
        length += gap; 
        depth += gap;           
        ctx.moveTo((-350 + length) * this.side, startY + depth);
    }
    
    length = 0;
    depth = 0;
    ctx.moveTo(0, 20+startY * -1);
    while (length < 40)
    {
        depth += dash * 2;
        ctx.lineTo(0, 20+startY*-1 - depth);
        length += gap; 
        depth += gap;             
        ctx.moveTo(-0, 20+startY*-1 - depth);
    }
    
	// Close path
	ctx.closePath();
	
	// Set line attributes
	ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(80, 80, 80, 1)";
    
	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	
	// Other stuff here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw)
	{
	}
	
	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);
	
	// Return value indicating successful hittest
	return this.isClicked;
}
/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Template for strabismus surgery
 *
 * @class StrabOpTemplate
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.StrabOpTemplate = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "StrabOpTemplate";

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.StrabOpTemplate.prototype = new ED.Doodle;
ED.StrabOpTemplate.prototype.constructor = ED.StrabOpTemplate;
ED.StrabOpTemplate.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.StrabOpTemplate.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
	this.isUnique = true;
	this.isDeletable = false;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.StrabOpTemplate.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.StrabOpTemplate.superclass.draw.call(this, _point);

	// Drawing properties
	var insertionY = -200;
	var insertionHalfWidth = 70;

	// Boundary path
	ctx.beginPath();

	// Cornea
	ctx.arc(0, 0, 80, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(100, 200, 250, 0.75)";
	ctx.strokeStyle = "blue";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Pupil
		ctx.beginPath();
		ctx.arc(0, 0, 30, 0, Math.PI * 2, true);
		ctx.fillStyle = "black";
		ctx.fill();

		// Insertions
		ctx.beginPath();
		ctx.moveTo(-insertionHalfWidth, insertionY);
		ctx.lineTo(insertionHalfWidth, insertionY);
		ctx.moveTo(insertionY, -insertionHalfWidth);
		ctx.lineTo(insertionY, insertionHalfWidth);
		ctx.moveTo(-insertionHalfWidth, -insertionY);
		ctx.lineTo(insertionHalfWidth, -insertionY);
		ctx.moveTo(-insertionY, -insertionHalfWidth);
		ctx.lineTo(-insertionY, insertionHalfWidth);
		ctx.lineWidth = 16;
		ctx.strokeStyle = "brown";
		ctx.stroke();
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * The optic disc
 *
 * @class SubretinalFluid
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.SubretinalFluid = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "SubretinalFluid";

	// Private parameters
	this.numberOfHandles = 8;
	this.initialRadius = 80;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.SubretinalFluid.prototype = new ED.Doodle;
ED.SubretinalFluid.prototype.constructor = ED.SubretinalFluid;
ED.SubretinalFluid.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.SubretinalFluid.prototype.setHandles = function() {
	// Array of handles
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	}

	// Allow top handle to rotate doodle
	this.handleArray[0].isRotatable = true;
}

/**
 * Sets default properties
 */
ED.SubretinalFluid.prototype.setPropertyDefaults = function() {
	// Create ranges to constrain handles
	this.handleVectorRangeArray = new Array();
	for (var i = 0; i < this.numberOfHandles; i++) {
		// Full circle in radians
		var cir = 2 * Math.PI;

		// Create a range object for each handle
		var n = this.numberOfHandles;
		var range = new Object;
		range.length = new ED.Range(+50, +290);
		range.angle = new ED.Range((((2 * n - 1) * cir / (2 * n)) + i * cir / n) % cir, ((1 * cir / (2 * n)) + i * cir / n) % cir);
		this.handleVectorRangeArray[i] = range;
	}
}

/**
 * Sets default parameters
 */
ED.SubretinalFluid.prototype.setParameterDefaults = function() {
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		var np = new ED.Point(doodle.originX + 100, 0);
		this.move(np.x, np.y);
	} else {
		this.move((this.drawing.eye == ED.eye.Right ? -1 : 1) * 100, 0);
	}

	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate with handles at equidistant points around circumference
	for (var i = 0; i < this.numberOfHandles; i++) {
		var point = new ED.Point(0, 0);
		point.setWithPolars(this.initialRadius, i * 2 * Math.PI / this.numberOfHandles);
		this.addPointToSquiggle(point);
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.SubretinalFluid.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.SubretinalFluid.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Bezier points
	var fp;
	var tp;
	var cp1;
	var cp2;

	// Angle of control point from radius line to point (this value makes path a circle Math.PI/12 for 8 points
	var phi = 2 * Math.PI / (3 * this.numberOfHandles);

	// Start curve
	ctx.moveTo(this.squiggleArray[0].pointsArray[0].x, this.squiggleArray[0].pointsArray[0].y);

	// Complete curve segments
	for (var i = 0; i < this.numberOfHandles; i++) {
		// From and to points
		fp = this.squiggleArray[0].pointsArray[i];
		var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
		tp = this.squiggleArray[0].pointsArray[toIndex];

		// Control points
		cp1 = fp.tangentialControlPoint(+phi);
		cp2 = tp.tangentialControlPoint(-phi);

		// Draw Bezier curve
		ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);
	}

	// Close path
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(0, 0, 255, 0.75)";
	ctx.strokeStyle = "blue";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of expert handles (in canvas plane)
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[i]);
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.SubretinalFluid.prototype.description = function() {
	return 'Subretinal fluid';
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Subretinal heavy liquid
 *
 * @class SubretinalPFCL
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.SubretinalPFCL = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "SubretinalPFCL";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'originX', 'originY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);

	// Invariate parameters
	this.rotation = Math.PI / 4;
}

/**
 * Sets superclass and constructor
 */
ED.SubretinalPFCL.prototype = new ED.Doodle;
ED.SubretinalPFCL.prototype.constructor = ED.SubretinalPFCL;
ED.SubretinalPFCL.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.SubretinalPFCL.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.SubretinalPFCL.prototype.setPropertyDefaults = function() {
	this.addAtBack = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-80, -20);
}

/**
 * Sets default parameters
 */
ED.SubretinalPFCL.prototype.setParameterDefaults = function() {
	this.apexY = -40;

	// Displacement from fovea, and from last doodle
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		var p = new ED.Point(doodle.originX, doodle.originY);

		var np = new ED.Point(0, 0);
		np.setWithPolars(p.length(), p.direction() + Math.PI / 6);

		this.move(np.x, np.y);
	} else {
		this.move((this.drawing.eye == ED.eye.Right ? -1 : 1) * 200, 0);
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.SubretinalPFCL.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.SubretinalPFCL.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Radius
	var r = Math.sqrt(this.apexX * this.apexX + this.apexY * this.apexY);

	// Circular bleb
	ctx.arc(0, 0, r, 0, 2 * Math.PI, true);

	// Set line attributes
	ctx.lineWidth = 1;

	var d = r / 1.1412135
	var lingrad = ctx.createLinearGradient(-d, -d, d, d);
	lingrad.addColorStop(0, 'rgba(255,255,255,1)');
	lingrad.addColorStop(0.7, 'rgba(200,200,200,1)');
	lingrad.addColorStop(1, 'rgba(140,140,140,1)');

	ctx.fillStyle = lingrad
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.SubretinalPFCL.prototype.groupDescription = function() {
	return "Subretinal PFCL";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Supramid suture
 *
 * @class Supramid
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Supramid = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Supramid";

	// Other parameters
	this.percent = '80';

	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY', 'rotation', 'percent'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'percent':'Percentage of tube'};

	// Bezier segmentation is not linear, so can make fine adjustments here if required
	this.adjustmentArray = {
		'0':0,
		'10':10,
		'20':20,
		'30':30,
		'40':40,
		'50':50,
		'60':60,
		'70':70,
		'80':80,
		'90':90,
		'100':100
	}

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Supramid.prototype = new ED.Doodle;
ED.Supramid.prototype.constructor = ED.Supramid;
ED.Supramid.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Supramid.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.Supramid.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-800, +800);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-800, +800);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['percent'] = {
		kind: 'other',
		type: 'string',
		list: ['0', '10', '20', '30', '40', '50', '60', '70', '80', '90', '100'],
		animate: false
	};
}

/**
 * Sets default parameters
 */
ED.Supramid.prototype.setParameterDefaults = function() {
	this.apexX = -660;
	this.apexY = 30;

	// Default value of insertion percentage
	this.setParameterFromString('percent', '80');

	// Make rotation same as tube
	var doodle = this.drawing.lastDoodleOfClass("Tube");
	if (doodle) {
		this.rotation = doodle.rotation;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Supramid.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Supramid.superclass.draw.call(this, _point);

	// Get Tube or TubeExtender doodle (Latter takes preference)
	var doodle = this.drawing.lastDoodleOfClass("TubeExtender");

	// Watch condition when Tube extender is added after, since doodle can exist with empty bezierArray
	if (doodle && typeof(doodle.bezierArray['sp']) != 'undefined') {
		this.rotation = doodle.rotation;
	}
	else {
		doodle = this.drawing.lastDoodleOfClass("Tube");
		if (doodle) {
			this.rotation = doodle.rotation;
		}
	}
	
	// Calculate key points for supramid bezier
	var startPoint = new ED.Point(this.apexX, this.apexY);
	var tubePoint = new ED.Point(0, -700);

	// Boundary path
	ctx.beginPath();

	// Rectangle around end of suture
	ctx.rect(this.apexX - 100, this.apexY - 100, 200, 200);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 1;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	if (this.isSelected) ctx.strokeStyle = "rgba(0, 0, 0, 0.8)";
	else ctx.strokeStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();
		if (doodle && doodle.bezierArray['sp']) {
			// Suture
			var xDev = startPoint.x/Math.abs(startPoint.x) * 100;
			ctx.moveTo(startPoint.x, startPoint.y);
			ctx.bezierCurveTo(startPoint.x + xDev, startPoint.y - 100, tubePoint.x + xDev, tubePoint.y, doodle.bezierArray['sp'].x, doodle.bezierArray['sp'].y);

			// Number of bezier segments
			var nb = 50;

			// Draw Bezier of appropriate length for corrected proportion along curve
			var pc = this.adjustmentArray[this.percent];
			for (var t = 0; t < 1/nb + pc/100; t = t + 1/nb) {
				var nextPoint = doodle.bezierArray['sp'].bezierPointAtParameter(t, doodle.bezierArray['cp1'], doodle.bezierArray['cp2'], doodle.bezierArray['ep']);
				ctx.lineTo(nextPoint.x, nextPoint.y);
			}
		} else {
			// Just straight line to make it appear
			ctx.moveTo(startPoint.x, startPoint.y);
			ctx.lineTo(0, -400);
		}

		// Draw suture
		ctx.lineWidth = 4;
		ctx.strokeStyle = "purple";
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Supramid.prototype.description = function() {
	return "Supramid suture " + this.percent + "% along tube";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * SwollenDisc
 *
 * @class SwollenDisc
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.SwollenDisc = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "SwollenDisc";

	// Saved parameters
	this.savedParameterArray = ['originX'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.SwollenDisc.prototype = new ED.Doodle;
ED.SwollenDisc.prototype.constructor = ED.SwollenDisc;
ED.SwollenDisc.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.SwollenDisc.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;
	this.addAtBack = true;
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.SwollenDisc.prototype.setParameterDefaults = function() {
	this.originY = 0;
	if (this.drawing.hasDoodleOfClass('PostPole')) {
		this.originX = this.drawing.eye == ED.eye.Right ? 300 : -300;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.SwollenDisc.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.SwollenDisc.superclass.draw.call(this, _point);

	// Radii
	var ro = 140;
	var ri = 80;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, 0, Math.PI * 2, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, Math.PI * 2, 0, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;

	// Colors for gradient
	yellowColour = "rgba(255, 255, 0, 0.75)";
	var brownColour = "rgba(240, 140, 40, 0.75)";

	// Radial gradient
	var gradient = ctx.createRadialGradient(0, 0, ro, 0, 0, ri);
	gradient.addColorStop(0, yellowColour);
	gradient.addColorStop(1, brownColour);

	ctx.fillStyle = gradient;
	ctx.strokeStyle = "rgba(0,0,0,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.SwollenDisc.prototype.description = function() {
	return "Swollen disc";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 *
 *
 * @class TarsalPlates
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.TarsalPlates = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "TarsalPlates";

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.TarsalPlates.prototype = new ED.Doodle;
ED.TarsalPlates.prototype.constructor = ED.TarsalPlates;
ED.TarsalPlates.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.TarsalPlates.prototype.setPropertyDefaults = function() {
	this.isUnique = true;
	this.isSelectable = false;
	this.isDeletable = false;
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.TarsalPlates.prototype.setParameterDefaults = function() {
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.TarsalPlates.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.TarsalPlates.superclass.draw.call(this, _point);
	
	// Radius of arc
	var r = 480;
	
	// Height of arc
	var h = 700;
	
	// Start angle of arc
	var o = r - h;
	var theta = Math.asin(o/r);
	
	// Radius of plate
	var l = r * Math.cos(theta);
	
	// Draw superior plate
	ctx.moveTo(-l,o*0.5);
	ctx.arc(0,-o*0.5,r,theta,Math.PI-theta,true);
	ctx.lineTo(-l,o*0.5);
	
	// Draw inferior plate
	ctx.moveTo(-l,-o*0.5);
	ctx.arc(0,o*0.5,r,-theta,Math.PI+theta,false);
	ctx.lineTo(-l,-o*0.5);

	// Draw it
	ctx.stroke();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255, 255, 255, 0)";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Hard Drusen
 *
 * @class Telangiectasis
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Telangiectasis = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Telangiectasis";

	// Saved parameters
	this.savedParameterArray = ['originX', 'apexX', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Telangiectasis.prototype = new ED.Doodle;
ED.Telangiectasis.prototype.constructor = ED.Telangiectasis;
ED.Telangiectasis.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Telangiectasis.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.Telangiectasis.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-100, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-100, +0);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Telangiectasis.prototype.setParameterDefaults = function() {
	this.originX = this.drawing.eye == ED.eye.Right ? -160 : 160;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Telangiectasis.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Telangiectasis.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Invisible boundary
	var r = 100;
	ctx.arc(0, 0, r, 0, Math.PI * 2, true);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 0;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "rgba(0, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Telangiectasis
		var fill = "red";

		var dr = 10 / this.scaleX;

		var p = new ED.Point(0, 0);
		var n = 10;
		for (var i = 0; i < n; i++) {
			p.setWithPolars(r * 0.8 * ED.randomArray[i], 2 * Math.PI * ED.randomArray[i + 100]);
			this.drawSpot(ctx, p.x, p.y, dr, fill);
		}

		// Ring of Exudate
		if (this.apexY < - 50) {
			fill = "yellow";
			n = 18;
			for (var i = 0; i < n; i++) {
				p.setWithPolars(r, 2 * Math.PI * i/n);
				this.drawSpot(ctx, p.x, p.y, dr, fill);
			}
		}

		// Pigmentation
		fill = "brown";
		n = Math.abs(Math.floor(this.apexX / 10));
		for (var i = 0; i < n; i++) {
			p.setWithPolars(r * 0.8 * ED.randomArray[i + 10], 2 * Math.PI * ED.randomArray[i + 100]);
			this.drawSpot(ctx, p.x, p.y, dr * 2, fill);
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Telangiectasis.prototype.description = function() {
	return "Parafoveal telangiectasia";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Toric Posterior chamber IOL
 *
 * @class ToricPCIOL
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ToricPCIOL = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ToricPCIOL";
	
	// Derived parameters
	this.axis = 0;
	
	// Other parameters
	this.model = 'Type 1';

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'rotation', 'model'];
	
	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'model':'Model'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.ToricPCIOL.prototype = new ED.Doodle;
ED.ToricPCIOL.prototype.constructor = ED.ToricPCIOL;
ED.ToricPCIOL.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.ToricPCIOL.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Rotate, false);
}

/**
 * Sets default dragging attributes
 */
ED.ToricPCIOL.prototype.setPropertyDefaults = function() {
	this.addAtBack = true;
	this.isOrientated = false;
	this.isScaleable = false;
	this.isUnique = true;
	
	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['axis'] = {
		kind: 'derived',
		type: 'mod',
		range: new ED.Range(0, 180),
		clock: 'bottom',
		animate: true
	};
	
	this.parameterValidationArray['model'] = {
		kind: 'derived',
		type: 'string',
		list: ['AcrySof T3 (+1.50 D)', 'AcrySof T4 (+2.25 D)', 'AcrySof T5 (+3.00 D)', 'AA4203-TF (+2.00 D)', 'AA4203-TL (+3.50 D)'],
		animate: false
	}
}

/**
 * Sets default parameters
 */
ED.ToricPCIOL.prototype.setParameterDefaults = function() {
	this.scaleX = 0.75;
	this.scaleY = 0.75;
	this.setParameterFromString('axis', '0');
	this.setParameterFromString('model', 'AcrySof T3 (+1.50 D)');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.ToricPCIOL.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	// Similar to TrialLens but with correction to line up haptics correctly
	switch (_parameter) {
		case 'rotation':
			returnArray['axis'] = (-120 + 720 - 180 * _value / Math.PI) % 180;
			break;

		case 'axis':
			returnArray['rotation'] = (60 + 180 - _value) * Math.PI / 180;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ToricPCIOL.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ToricPCIOL.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Radius of IOL optic
	var r = 240;

	// Draw optic
	ctx.arc(0, 0, r, 0, Math.PI * 2, false);

	// Draw upper haptic
	ctx.moveTo(150, -190);
	ctx.bezierCurveTo(160, -200, 190, -350, 160, -380);
	ctx.bezierCurveTo(90, -440, -150, -410, -220, -370);
	ctx.bezierCurveTo(-250, -350, -260, -400, -200, -430);
	ctx.bezierCurveTo(-110, -480, 130, -470, 200, -430);
	ctx.bezierCurveTo(270, -390, 220, -140, 220, -100);

	// Draw lower haptic
	ctx.moveTo(-150, 190);
	ctx.bezierCurveTo(-160, 200, -190, 350, -160, 380);
	ctx.bezierCurveTo(-90, 440, 150, 410, 220, 370);
	ctx.bezierCurveTo(250, 350, 260, 400, 200, 430);
	ctx.bezierCurveTo(110, 480, -130, 470, -200, 430);
	ctx.bezierCurveTo(-270, 390, -220, 140, -220, 100);

	// Colour of fill is white but with transparency
	ctx.fillStyle = "rgba(255,255,255,0.75)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "darkgray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Lines for toric IOL
		ctx.beginPath();

		// Create points
		var phi = 0.7 * Math.PI / 4;
		var theta = phi + Math.PI;
		var p1 = new ED.Point(0, 0)
		p1.setWithPolars(r - 20, phi);
		var p2 = new ED.Point(0, 0);
		p2.setWithPolars(r - 100, phi);
		var p3 = new ED.Point(0, 0)
		p3.setWithPolars(r - 20, theta);
		var p4 = new ED.Point(0, 0);
		p4.setWithPolars(r - 100, theta);

		// Create lines
		ctx.moveTo(p1.x, p1.y);
		ctx.lineTo(p2.x, p2.y);
		ctx.moveTo(p3.x, p3.y);
		ctx.lineTo(p4.x, p4.y);

		// Set line attributes
		ctx.lineWidth = 24;
		ctx.lineCap = "round";
		ctx.strokeStyle = "darkgray";

		// Draw lines
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	var point = new ED.Point(0, 0)
	point.setWithPolars(r, 4 * Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ToricPCIOL.prototype.description = function() {
	var returnValue = "Toric posterior chamber IOL " + this.model + " ";

	// Displacement limit
	var limit = 40;

	// ***TODO*** ensure description takes account of side of eye
	var displacementValue = "";

	if (this.originY < -limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += " superiorly";
	}
	if (this.originY > limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += " inferiorly";
	}
	if (this.originX < -limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += " temporally";
	}
	if (this.originX > limit) {
		if (displacementValue.length > 0) displacementValue += " and";
		displacementValue += " nasally";
	}

	// Add displacement description
	if (displacementValue.length > 0) returnValue += " displaced" + displacementValue;

	returnValue += ' @ ' + this.axis.toFixed(0) + '\xB0';

	return returnValue;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Trabectome
 *
 * @class Trabectome
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Trabectome = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Trabectome";

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Trabectome.prototype = new ED.Doodle;
ED.Trabectome.prototype.constructor = ED.Trabectome;
ED.Trabectome.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Trabectome.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Sets default properties
 */
ED.Trabectome.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isArcSymmetrical = true;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 16, Math.PI);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.Trabectome.prototype.setParameterDefaults = function() {
	this.arc = Math.PI / 4;
	this.setRotationWithDisplacements(-90, -120);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Trabectome.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Trabectome.superclass.draw.call(this, _point);

	// Radius of outer curve and inner curve
	var ro = 440;
	var ri = 400;

	// Dimensions of instrument
	var vo = 500;
	var sw = 10;
	var sl = 760;
	var cl = 100;
	var hw = 150;
	var hl = 170;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of Trabectome
	var rm = (ro + ri) / 2;
	var topRightX = rm * Math.sin(theta);
	var topRightY = -rm * Math.cos(theta);
	var topLeftX = -rm * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// arc back again
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	ctx.moveTo(-sw, vo - (cl + sl));
	ctx.lineTo(0, vo - (cl + sl) - sw);
	ctx.lineTo(sw, vo - (cl + sl));
	ctx.lineTo(sw, vo - cl);
	ctx.lineTo(hw, vo);
	ctx.lineTo(hw, vo + hl);
	ctx.lineTo(-hw, vo + hl);
	ctx.lineTo(-hw, vo);
	ctx.lineTo(-sw, vo - cl);
	ctx.lineTo(-sw, vo - (cl + sl));

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(200, 200, 200, 0.5)";
	ctx.strokeStyle = "rgba(200, 200, 200, 0.8)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Re-do ablation area
		ctx.beginPath();
		ctx.arc(0, 0, ro, arcStart, arcEnd, true);
		ctx.arc(0, 0, ri, arcEnd, arcStart, false);
		ctx.fillStyle = "rgba(200, 100, 100, 0.8)";
		ctx.strokeStyle = "red";
		ctx.fill();
		ctx.stroke();

		// Put in corneal incision
		var cr = 334;
		var cd = 30;
		var cro = cr + cd;
		var cri = cr - cd;
		ctx.beginPath();
		var ctheta = 0.125;
		ctx.arc(0, 0, cro, Math.PI / 2 + ctheta, Math.PI / 2 - ctheta, true);
		ctx.arc(0, 0, cri, Math.PI / 2 - ctheta, Math.PI / 2 + ctheta, false);
		ctx.fillStyle = "rgba(200,200,200,0.75)";
		ctx.strokeStyle = "rgba(120,120,120,0.75)";
		ctx.fill();
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Trabectome.prototype.description = function() {
	return "Trabecular meshwork ablation of " + this.degreesExtent() + " degrees centred around " + this.clockHour() + " o'clock";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Peripheral retinectomy
 *
 * @class TrabyConjIncision
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.TrabyConjIncision = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "TrabyConjIncision";

	// Saved parameters
	this.savedParameterArray = ['arc', 'rotation'];
	
	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.TrabyConjIncision.prototype = new ED.Doodle;
ED.TrabyConjIncision.prototype.constructor = ED.TrabyConjIncision;
ED.TrabyConjIncision.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.TrabyConjIncision.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Sets default properties
 */
ED.TrabyConjIncision.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isArcSymmetrical = true

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 8, Math.PI);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.TrabyConjIncision.prototype.setParameterDefaults = function() {
	this.arc = 80 * Math.PI / 180;

	// If more than one, rotate it a bit to distinguish it
	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		this.rotation = doodle.rotation + Math.PI / 4;
	} else {
		this.rotation = 0;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.TrabyConjIncision.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.TrabyConjIncision.superclass.draw.call(this, _point);

	// Radius of outer end of radial incision
	var ro = 660;
	var ri = 400;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;
	
	// Coordinates of 'corners'
	var topRightX = ro * Math.sin(theta);
	var topRightY = -ro * Math.cos(theta);
	var topLeftX = -ro * Math.sin(theta);
	var topLeftY = topRightY;
	var bottomRightX = ri * Math.sin(theta);
	var bottomRightY = -ri * Math.cos(theta);
	var bottomLeftX = -ri * Math.sin(theta);
	var bottomLeftY = bottomRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255,255,0,0)";
	ctx.strokeStyle = "rgba(255,0,255,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Path for incision
		ctx.beginPath();

		// Path
		ctx.moveTo(topRightX, topRightY);
		ctx.lineTo(bottomRightX, bottomRightY);
		ctx.arc(0, 0, ri, arcStart, arcEnd, true);
		ctx.lineTo(topLeftX, topLeftY);

		// Draw retinectomy
		ctx.lineWidth = 4;
		ctx.strokeStyle = "gray";
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)limbus
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.TrabyConjIncision.prototype.description = function() {
	return "";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * TrabyFlap
 *
 * @class TrabyFlap
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.TrabyFlap = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "TrabyFlap";

	// Derived parameters
	this.site = 'Superior';
	this.size = '4x3';
	this.sclerostomy = 'Punch';
	this.height = -580;

	// Doodle specific parameters
	this.r = 380;
	this.right = new ED.Point(0, 0);
	this.left = new ED.Point(0, 0);

	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY', 'arc', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.TrabyFlap.prototype = new ED.Doodle;
ED.TrabyFlap.prototype.constructor = ED.TrabyFlap;
ED.TrabyFlap.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.TrabyFlap.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.TrabyFlap.prototype.setPropertyDefaults = function() {
	this.isScaleable = false;
	this.isMoveable = false;
	this.isArcSymmetrical = true;
	this.snapToArc = true;
	this.isDeletable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-50, +50);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-440, -440);
	this.parameterValidationArray['rotation']['delta'] = 0.1;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['site'] = {
		kind: 'derived',
		type: 'string',
		list: ['Superior', 'Superonasal', 'Superotemporal'],
		animate: false
	};
	this.parameterValidationArray['size'] = {
		kind: 'derived',
		type: 'string',
		list: ['4x3', '5x2'],
		animate: false
	};
	this.parameterValidationArray['sclerostomy'] = {
		kind: 'derived',
		type: 'string',
		list: ['Punch', 'Block', 'Ex-Press shunt'],
		animate: false
	};

	// Array of arcs to snap to
	this.arcArray = [0.9, 1.13];
}

/**
 * Sets default parameters
 */
ED.TrabyFlap.prototype.setParameterDefaults = function() {
	this.apexY = -440;
	this.height = -580;
	this.setParameterFromString('size', 'Superior');
	this.setParameterFromString('size', '4x3');
	this.setParameterFromString('sclerostomy', 'Punch');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.TrabyFlap.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {

		case 'apexX':
			if (_value < -15) returnArray['sclerostomy'] = 'Punch';
			else if (_value > + 15) returnArray['sclerostomy'] = 'Ex-Press shunt';
			else returnArray['sclerostomy'] = 'Block';
			break;

		case 'arc':
			if (_value < 1.0) {
				returnArray['size'] = '4x3';
				returnArray['height'] = -580;
			} else {
				returnArray['size'] = '5x2';
				returnArray['height'] = -510;
			}
			break;

		case 'rotation':
			if (_value > Math.PI / 16 && _value < Math.PI) returnArray['site'] = this.drawing.eye == ED.eye.Right ? 'Superonasal' : 'Superotemporal';
			else if (_value >= Math.PI && _value < 31 * Math.PI / 16) returnArray['site'] = this.drawing.eye == ED.eye.Right ? 'Superotemporal' : 'Superonasal';
			else returnArray['site'] = 'Superior';
			break;

		case 'site':
			switch (_value) {
				case 'Superior':
					returnArray['rotation'] = 0;
					break;
				case 'Superonasal':
					returnArray['rotation'] = this.drawing.eye == ED.eye.Right ? Math.PI / 4 : (7 * Math.PI / 4);
					break;
				case 'Superotemporal':
					returnArray['rotation'] = this.drawing.eye == ED.eye.Right ? (7 * Math.PI / 4) : Math.PI / 4;
					break;
			}
			break;

		case 'size':
			switch (_value) {
				case '4x3':
					returnArray['arc'] = 0.9;
					returnArray['height'] = -580;
					this.right.setCoordinates(this.r * Math.sin(this.arc / 2), -this.r * Math.cos(this.arc / 2));
					break;
				case '5x2':
					returnArray['arc'] = 1.13;
					returnArray['height'] = -510;
					this.right.setCoordinates(this.r * Math.sin(this.arc / 2), -this.r * Math.cos(this.arc / 2));
					break;
			}
			break;

		case 'sclerostomy':
			switch (_value) {
				case 'Punch':
					returnArray['apexX'] = -50;
					break;
				case 'Block':
					returnArray['apexX'] = +0;
					break;
				case 'Ex-Press shunt':
					returnArray['apexX'] = +50;
					break;
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.TrabyFlap.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.TrabyFlap.superclass.draw.call(this, _point);

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Offset angle for control points
	var phi = this.arc / 6;

	// Apex point
	var apex = new ED.Point(0, this.height);

	this.right.x = this.r * Math.sin(theta);
	this.right.y = -this.r * Math.cos(theta);
	this.left.x = -this.r * Math.sin(theta);
	this.left.y = -this.r * Math.cos(theta);

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, this.r, arcStart, arcEnd, true);

	// Rectangular flap
	ctx.lineTo(this.left.x, this.height);
	ctx.lineTo(this.right.x, this.height);
	ctx.closePath();

	// Colour of fill
	ctx.fillStyle = "rgba(220,220,150,0.5)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "rgba(120,120,120,0.75)";;

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		ctx.beginPath();

		switch (this.sclerostomy) {
			case 'Punch':
				ctx.arc(0, this.apexY, 50, 0, 2 * Math.PI, true);
				break;
			case 'Block':
				// Draw block at half width and height
				var angle = theta / 2;
				arcStart = -Math.PI / 2 + angle;
				arcEnd = -Math.PI / 2 - angle;
				var top = new ED.Point(0, -this.r + (this.height + this.r) / 2);

				ctx.arc(0, 0, this.r, arcStart, arcEnd, true);
				ctx.lineTo(-this.r * Math.sin(angle), top.y);
				ctx.lineTo(this.r * Math.sin(angle), top.y);
				ctx.closePath();
				break;
			case 'Ex-Press shunt':
				ctx.arc(0, this.apexY, 40, 0, 2 * Math.PI, true);
				ctx.moveTo(- 20, -420);
				ctx.lineTo(-20, -300);
				ctx.lineTo(20, -300);
				ctx.lineTo(20, -420);
				break;
		}

		// Colour of fill
		ctx.fillStyle = "gray";
		ctx.fill();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(this.left);
	this.handleArray[3].location = this.transform.transformPoint(this.right);
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.TrabyFlap.prototype.description = function() {
	return "Trabeculectomy flap at " + this.clockHour() + " o'clock with " + ED.firstLetterToLowerCase(this.sclerostomy) + " sclerostomy";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * TrabySuture suture
 *
 * @class TrabySuture
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.TrabySuture = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "TrabySuture";

	// Derived parameters
	this.type = 'Fixed';
	this.material = 'Nylon';
	this.size = '10/0';
	this.removed = false;

	// Number of additional handles for releasable suture
	this.numberOfHandles = 5;

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexX', 'apexY', 'arc', 'rotation', 'type', 'material', 'size','removed'];

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'type':'Shape', 'material':'Material', 'size':'Size','removed':'Removed'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.TrabySuture.prototype = new ED.Doodle;
ED.TrabySuture.prototype.constructor = ED.TrabySuture;
ED.TrabySuture.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.TrabySuture.prototype.setHandles = function() {
	// Rotation Handle
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Rotate, false);
}

/**
 * Sets default dragging attributes
 */
ED.TrabySuture.prototype.setPropertyDefaults = function() {
	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-50, +50);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(+70, +70);
	this.parameterValidationArray['originY']['range'].setMinAndMax(-625, +625);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['type'] = {
		kind: 'derived',
		type: 'string',
		list: ['Fixed', 'Adjustable', 'Releasable'],
		animate: false
	};
	this.parameterValidationArray['material'] = {
		kind: 'derived',
		type: 'string',
		list: ['Nylon', 'Prolene', 'Vicryl', 'Silk'],
		animate: false
	}
	this.parameterValidationArray['size'] = {
		kind: 'derived',
		type: 'string',
		list: ['11/0', '10/0', '9/0', '8/0', '7/0', '6/0'],
		animate: false
	}
	this.parameterValidationArray['removed'] = {
		kind: 'derived',
		type: 'bool',
		animate: false
	}
}

/**
 * Sets default parameters
 */
ED.TrabySuture.prototype.setParameterDefaults = function() {
	this.apexX = +50;
	this.apexY = +70;
	this.material = 'Nylon';
	this.size = '10/0';

	// Suture position depends on presence of a trabeculectomy flap
	var trabyFlap = this.drawing.lastDoodleOfClass('TrabyFlap');
	if (trabyFlap) {
		var number = this.drawing.numberOfDoodlesOfClass("TrabySuture");
		
		// Get top of Traby suture
		var p = new ED.Point(-1 * trabyFlap.right.x, (trabyFlap.height + 0 * (trabyFlap.right.y - trabyFlap.height)));
		p.setWithPolars(p.length(), p.direction() + trabyFlap.rotation);

		switch (number) {
			// First suture is top left
			case 0:
				this.originX = p.x;
				this.originY = p.y;
				this.rotation = trabyFlap.rotation;
				this.scaleX = this.scaleX * -1;
				break;
			// Second suture is top right
			case 1:
				p = new ED.Point(+1 * trabyFlap.right.x, (trabyFlap.height + 0 * (trabyFlap.right.y - trabyFlap.height)));
				p.setWithPolars(p.length(), p.direction() + trabyFlap.rotation);
				this.originX = p.x;
				this.originY = p.y;
				this.rotation = trabyFlap.rotation;
				break;
			// Third suture is between the first two
			case 2:
				var doodle1 = this.drawing.firstDoodleOfClass("TrabySuture");
				var doodle2 = this.drawing.lastDoodleOfClass("TrabySuture");
				this.originX = doodle1.originX + (doodle2.originX - doodle1.originX)/2;
				this.originY = p.y;
				this.rotation = doodle2.rotation;
				break;
			default:
				this.setOriginWithDisplacements(0, -40);
				break;
		}

	}
	else {
		this.setOriginWithDisplacements(0, -40);
	}

	// Make type same as last one
	var doodle = this.drawing.lastDoodleOfClass("TrabySuture");
	if (doodle) {
		this.type = doodle.type;
	}
	else {
		this.type = 'Releasable';
	}

	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate handle array (value of d determines size) for releasable suture
	var d = 50;
	var positionSet = [
		{x: d, y: -d},
		{x: -d, y: d},
		{x: -d, y: 3 * d},
		{x: 0, y: 7 * d},
		{x: d, y: 2 * d},
	];
	for (var i = 0; i < positionSet.length; i++) {
		var point = new ED.Point(positionSet[i].x, positionSet[i].y);
		this.addPointToSquiggle(point);
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.TrabySuture.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.TrabySuture.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Outline
	ctx.rect(-40, -70, 80, 100);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255,255,255,0)";
	if (this.isSelected) {
		ctx.strokeStyle = "gray";
	} else {
		ctx.strokeStyle = "rgba(255,255,255,0)";
	}

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Suture path
		ctx.beginPath();

		// Type of suture
		switch (this.type) {
			case 'Releasable':
				// Decorative knot between first two points
				var fp = this.squiggleArray[0].pointsArray[0];
				ctx.moveTo(fp.x, fp.y);
				var tp = this.squiggleArray[0].pointsArray[1];

				// ***TODO*** not sure this function is working as planned, but result here is OK
				var cp1 = fp.pointAtAngleToLineToPointAtProportion(Math.PI/3, tp, 0.5);
				var cp2 = fp.pointAtAngleToLineToPointAtProportion(-Math.PI/3, tp, 0.5);
				ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);

				// First three segments are straight
				var tp = this.squiggleArray[0].pointsArray[0];
				ctx.moveTo(tp.x, tp.y);
				for (var i = 1; i < 3; i++) {
					tp = this.squiggleArray[0].pointsArray[i];
					ctx.lineTo(tp.x, tp.y);
					fp = tp;
				}

				// Next two segments are curved
				var fp = this.squiggleArray[0].pointsArray[2];
				var tp = this.squiggleArray[0].pointsArray[3];
				var p = 2;
				var cp1 = new ED.Point(fp.x, fp.y + (tp.y - fp.y)/p);
				var cp2 = new ED.Point(tp.x - (tp.x - fp.x)/p, tp.y);
				ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);

				fp = this.squiggleArray[0].pointsArray[3];
				tp = this.squiggleArray[0].pointsArray[4];
				p = 2;
				cp1 = new ED.Point(fp.x + (tp.x - fp.x)/p, fp.y);
				cp2 = new ED.Point(tp.x, tp.y - (tp.y - fp.y)/p);
				ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);

				// Array of handles for releasable suture
				for (var i = 0; i < this.numberOfHandles; i++) {
					this.handleArray[i] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
					this.handleArray[i].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[i]);
				}
				break;

			case 'Adjustable':
				ctx.moveTo(-2, 64);
				ctx.bezierCurveTo(20, 36, -15, 16, -16, -7);
				ctx.bezierCurveTo(-18, -30, -12, -43, -4, -43);
				ctx.bezierCurveTo(6, -43, 12, -28, 12, -9);
				ctx.bezierCurveTo(12, 11, 0, 23, -2, 30);
				ctx.bezierCurveTo(-3, 36, 3, 37, 2, 30);
				ctx.bezierCurveTo(2, 20, -4, 24, -3, 29);
				ctx.bezierCurveTo(-3, 36, 14, 37, 23, 56);
				ctx.bezierCurveTo(32, 74, 34, 100, 34, 100);

				this.handleArray.length = 1;
				this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Rotate, false);
				this.handleArray[0].location = this.transform.transformPoint(new ED.Point(40, -70));
				break;

			case 'Fixed':
				ctx.moveTo(0, -30);
				ctx.bezierCurveTo(5, -10, 5, 10, 0, 30);
				ctx.bezierCurveTo(-5, 10, -5, -10, 0, -30);
				ctx.moveTo(-5, 50);
				ctx.lineTo(0, 30);
				ctx.lineTo(5, 50);

				this.handleArray.length = 1;
				this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Rotate, false);
				this.handleArray[0].location = this.transform.transformPoint(new ED.Point(40, -70));
				break;
		}

		// Set line attributes
		ctx.lineWidth = 8;
		ctx.fillStyle = "rgba(0, 0, 0, 0)";
		if (this.removed) ctx.strokeStyle = "rgba(150,150,150,0.5)";
		else ctx.strokeStyle = "purple";

		// Draw line
		ctx.stroke();
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.TrabySuture.prototype.groupDescription = function() {
	return "Flap sutures at ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.TrabySuture.prototype.description = function() {
	return this.clockHour();
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.TrabySuture.prototype.groupDescriptionEnd = function() {
	return " o'clock";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * TractionRetinalDetachment
 *
 * @class TractionRetinalDetachment
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.TractionRetinalDetachment = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "TractionRetinalDetachment";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'scaleX', 'scaleY', 'rotation'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.TractionRetinalDetachment.prototype = new ED.Doodle;
ED.TractionRetinalDetachment.prototype.constructor = ED.TractionRetinalDetachment;
ED.TractionRetinalDetachment.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.TractionRetinalDetachment.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, true);
}

/**
 * Set default properties
 */
ED.TractionRetinalDetachment.prototype.setPropertyDefaults = function() {
	this.isSqueezable = true;
	this.addAtBack = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['scaleX']['range'].setMinAndMax(+0.5, +1.5);
	this.parameterValidationArray['scaleY']['range'].setMinAndMax(+0.5, +1.5);
}

/**
 * Sets default parameters
 */
ED.TractionRetinalDetachment.prototype.setParameterDefaults = function() {
	this.setOriginWithDisplacements(200, -100);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.TractionRetinalDetachment.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.TractionRetinalDetachment.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Move to centre
	var r = 60;
	var s = 150;
	ctx.moveTo(-s, -s);

	// Create curves for the TractionRetinalDetachment
	ctx.bezierCurveTo(-r, -r, r, -r, s, -s);
	ctx.bezierCurveTo(r, -r, r, r, s, s);
	ctx.bezierCurveTo(r, r, -r, r, -s, s);
	ctx.bezierCurveTo(-r, r, -r, -r, -s, -s);
	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 1;
	ctx.strokeStyle = "blue";
	ctx.fillStyle = "blue";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[2].location = this.transform.transformPoint(new ED.Point(s, -s));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.TractionRetinalDetachment.prototype.groupDescription = function() {
	return "Traction retinal detachment ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.TractionRetinalDetachment.prototype.description = function() {
	return this.locationRelativeToDisc();
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Transillumination defect
 *
 * @class TransilluminationDefect
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.TransilluminationDefect = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "TransilluminationDefect";

	// Saved parameters
	this.savedParameterArray = ['apexY', 'arc', 'rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.TransilluminationDefect.prototype = new ED.Doodle;
ED.TransilluminationDefect.prototype.constructor = ED.TransilluminationDefect;
ED.TransilluminationDefect.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.TransilluminationDefect.prototype.setHandles = function() {
	this.handleArray[0] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Arc, false);
}

/**
 * Set default properties
 */
ED.TransilluminationDefect.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['arc']['range'].setMinAndMax(Math.PI / 8, Math.PI * 2);
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-400, -100);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.TransilluminationDefect.prototype.setParameterDefaults = function() {
	this.arc = 60 * Math.PI / 180;

	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		this.rotation = doodle.rotation + (this.drawing.eye == ED.eye.Right ? -1 : 1) * (doodle.arc / 2 + this.arc / 2 + Math.PI / 12);
	} else {
		this.rotation = (this.drawing.eye == ED.eye.Right ? -1 : 1) * this.arc / 2;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.TransilluminationDefect.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.TransilluminationDefect.superclass.draw.call(this, _point);

	// Radius of outer curve just inside ora on right and left fundus diagrams
	var ro = 380;
	var ri = 280;
	var r = ri + (ro - ri) / 2;

	// Calculate parameters for arcs
	var theta = this.arc / 2;
	var arcStart = -Math.PI / 2 + theta;
	var arcEnd = -Math.PI / 2 - theta;

	// Coordinates of 'corners' of TransilluminationDefect
	var topRightX = r * Math.sin(theta);
	var topRightY = -r * Math.cos(theta);
	var topLeftX = -r * Math.sin(theta);
	var topLeftY = topRightY;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, arcStart, arcEnd, true);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, arcEnd, arcStart, false);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255,255,255,0)";
	ctx.strokeStyle = "rgba(255,255,255,0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Spot data
		var sr = 30;
		var inc = Math.PI / 8;

		// Iterate through radius and angle to draw spots
		for (var a = -Math.PI / 2 - arcStart + inc / 2; a < this.arc - Math.PI / 2 - arcStart; a += inc) {
			var p = new ED.Point(0, 0);
			p.setWithPolars(r, a);
			
			// Circle
			//this.drawCircle(ctx, p.x, p.y, sr, "rgba(255,255,255,1)", 4, "rgba(255,255,255,1)");
			
			// Slit
			var p1 = new ED.Point(0,0);
			p1.setWithPolars(r - sr, a);
			var p2 = new ED.Point(0,0);
			p2.setWithPolars(r + sr, a);
			var phi = Math.PI/40;
			var cp1 = new ED.Point(0,0);
			cp1.setWithPolars(r, a - phi);
			var cp2 = new ED.Point(0,0);
			cp2.setWithPolars(r, a + phi);
			
			ctx.save();

			ctx.beginPath();
			ctx.moveTo(p1.x, p1.y);
			ctx.quadraticCurveTo(cp1.x, cp1.y, p2.x, p2.y);
			ctx.quadraticCurveTo(cp2.x, cp2.y, p1.x, p1.y);
			
			ctx.fillStyle = "rgba(255,255,255,1)";
			ctx.fill();				
			ctx.lineWidth = 4;
			ctx.strokeStyle = "rgba(255,255,255,1)";
			ctx.stroke();
			
			ctx.restore();			
		}
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[0].location = this.transform.transformPoint(new ED.Point(topLeftX, topLeftY));
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(topRightX, topRightY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.TransilluminationDefect.prototype.groupDescription = function() {
	return "Transillumination defects of iris";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Trial Frame
 *
 * @class TrialFrame
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.TrialFrame = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "TrialFrame";

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.TrialFrame.prototype = new ED.Doodle;
ED.TrialFrame.prototype.constructor = ED.TrialFrame;
ED.TrialFrame.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.TrialFrame.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
	this.isDeletable = false;
	this.isUnique = true;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.TrialFrame.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.TrialFrame.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Settings
	var ro = 420;
	var rt = 340;
	var ri = 300;
	var d = 20;
	var height = 50;

	// Angles, phi gives a little extra at both ends of the frame
	var phi = -Math.PI / 20;
	var arcStart = 0 + phi;
	var arcEnd = Math.PI - phi;

	// Boundary path
	ctx.beginPath();

	// Arc across
	ctx.arc(0, 0, ro, arcStart, arcEnd, false);

	// Arc back
	ctx.arc(0, 0, ri, arcEnd, arcStart, true);

	ctx.closePath();

	// Colour of fill is white but with transparency
	ctx.fillStyle = "rgba(230,230,230,1)";

	// Set line attributes
	ctx.lineWidth = 4;

	// Colour of outer line is dark gray
	ctx.strokeStyle = "darkgray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Set font and colour
		ctx.font = height + "px sans-serif";
		ctx.fillStyle = "blue";

		ctx.beginPath();

		var theta = 0;

		// Points for each line
		var pi = new ED.Point(0, 0);
		var pj = new ED.Point(0, 0);
		var pt = new ED.Point(0, 0);
		var po = new ED.Point(0, 0);
		var pp = new ED.Point(0, 0);

		for (var i = 0; i < 19; i++) {
			var text = i.toFixed(0);
			theta = (-90 - i * 10) * Math.PI / 180;

			pi.setWithPolars(ri, theta);
			pj.setWithPolars(ri + d, theta);
			pt.setWithPolars(rt, theta);
			pp.setWithPolars(ro - d, theta);
			po.setWithPolars(ro, theta);

			ctx.moveTo(pi.x, pi.y);
			ctx.lineTo(pj.x, pj.y);
			ctx.moveTo(pp.x, pp.y);
			ctx.lineTo(po.x, po.y);

			ctx.save();
			ctx.translate(pt.x, pt.y);
			ctx.rotate(Math.PI + theta);
			ctx.textAlign = "center";
			ctx.fillText(text, 0, 80 / 2);
			ctx.restore();
		}

		ctx.moveTo(-20, 0);
		ctx.lineTo(20, 0);
		ctx.moveTo(0, -20);
		ctx.lineTo(0, 20);

		ctx.stroke();
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * TrialLens
 *
 * @class TrialLens
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.TrialLens = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "TrialLens";

	// Derived parameters
	this.axis = '0';

	// Saved parameters
	this.savedParameterArray = ['rotation'];

	// Call super-class constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.TrialLens.prototype = new ED.Doodle;
ED.TrialLens.prototype.constructor = ED.TrialLens;
ED.TrialLens.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.TrialLens.prototype.setPropertyDefaults = function() {
	this.isDeletable = false;
	this.isShowHighlight = false;
	this.isMoveable = false;
	this.addAtBack = true;
	this.isUnique = true;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['axis'] = {
		kind: 'derived',
		type: 'mod',
		range: new ED.Range(0, 180),
		clock: 'bottom',
		animate: true
	};
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.TrialLens.prototype.setParameterDefaults = function() {
	this.setParameterFromString('axis', '0');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if their 'animate' property is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.TrialLens.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	switch (_parameter) {
		case 'rotation':
			returnArray['axis'] = (360 - 180 * _value / Math.PI) % 180;
			break;

		case 'axis':
			returnArray['rotation'] = (180 - _value) * Math.PI / 180;
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.TrialLens.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.TrialLens.superclass.draw.call(this, _point);

	// Radius of outer curve just inside ora on right and left fundus diagrams
	var ro = 360;
	var ri = 180;

	// Boundary path
	ctx.beginPath();

	// Arc across to mirror image point on the other side
	ctx.arc(0, 0, ro, 0, 2 * Math.PI, true);

	// Move to start of next arc
	ctx.moveTo(ri, 0);

	// Arc back to mirror image point on the other side
	ctx.arc(0, 0, ri, 2 * Math.PI, 0, false);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(255,100,100,1)";
	ctx.strokeStyle = "gray";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Other paths and drawing here
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		var d = 20;
		ctx.beginPath();
		ctx.moveTo(ro - d, 0);
		ctx.lineTo(ri + d, 0);
		ctx.moveTo(-ro + d, 0);
		ctx.lineTo(-ri - d, 0);

		ctx.lineWidth = 16;
		ctx.strokeStyle = "black";
		ctx.stroke();
	}

	// Return value indicating successful hit test
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Tube tube
 *
 * @class Tube
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Tube = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Tube";

	// Derived parameters
	this.type = 'Baerveldt 103-250';
	this.platePosition = 'STQ';
	
	// Other Parameters
	this.bezierArray = new Array();

	// Private parameters
	this.tubeExtender = false;

	// Saved parameters
	this.savedParameterArray = ['rotation', 'apexX', 'apexY', 'type'];
	
	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'type':'Type'};

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Tube.prototype = new ED.Doodle;
ED.Tube.prototype.constructor = ED.Tube;
ED.Tube.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.Tube.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.Tube.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = true;
	this.snapToAngles = true;
	this.isDeletable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-300, +300);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-600, -100);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['type'] = {
		kind: 'other',
		type: 'string',
		list: ['Ahmed FP7', 'Baerveldt 103-250', 'Baerveldt 101-350', 'Baerveldt 103-350', 'Molteno Single'],
		animate: false
	};
	this.parameterValidationArray['platePosition'] = {
		kind: 'derived',
		type: 'string',
		list: ['STQ', 'SNQ', 'INQ', 'ITQ'],
		animate: true
	};

	// Array of angles to snap to
	var phi = Math.PI / 4;
	this.anglesArray = [phi, 3 * phi, 5 * phi, 7 * phi];
}

/**
 * Sets default parameters
 */
ED.Tube.prototype.setParameterDefaults = function() {
	this.apexY = -300;
	//this.setParameterFromString('type', 'Baerveldt');
	this.setParameterFromString('platePosition', 'STQ');
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.Tube.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	var isRE = (this.drawing.eye == ED.eye.Right);
	var phi = Math.PI / 4;

	switch (_parameter) {
		case 'rotation':
			if (this.rotation > 0 && this.rotation <= 2 * phi) {
				returnArray['platePosition'] = isRE ? 'SNQ' : 'STQ';
			} else if (this.rotation > 2 * phi && this.rotation <= 4 * phi) {
				returnArray['platePosition'] = isRE ? 'INQ' : 'ITQ';
			} else if (this.rotation > 4 * phi && this.rotation <= 6 * phi) {
				returnArray['platePosition'] = isRE ? 'ITQ' : 'INQ';
			} else {
				returnArray['platePosition'] = isRE ? 'STQ' : 'SNQ';
			}
			break;

		case 'platePosition':
			switch (_value) {
				case 'STQ':
					if (isRE) {
						returnArray['rotation'] = 7 * phi;
					} else {
						returnArray['rotation'] = phi;
					}
					break;
				case 'SNQ':
					if (isRE) {
						returnArray['rotation'] = phi;
					} else {
						returnArray['rotation'] = 7 * phi;
					}
					break;
				case 'INQ':
					if (isRE) {
						returnArray['rotation'] = 3 * phi;
					} else {
						returnArray['rotation'] = 5 * phi;
					}
					break;
				case 'ITQ':
					if (isRE) {
						returnArray['rotation'] = 5 * phi;
					} else {
						returnArray['rotation'] = 3 * phi;
					}
					break;
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Tube.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Tube.superclass.draw.call(this, _point);
	
	// Determine if a TubeExtender is present
	this.tubeExtender = this.drawing.hasDoodleOfClass("TubeExtender");

	// Boundary path
	ctx.beginPath();

	// Scaling factor
	var s = 0.41666667;

	// Vertical shift
	var d = -740;
	
	switch (this.type) {
		case 'Ahmed FP7':
			// Plate
			ctx.moveTo(-300 * s, 0 * s + d);
			ctx.bezierCurveTo(-300 * s, -100 * s + d, -200 * s, -400 * s + d, 0 * s, -400 * s + d);
			ctx.bezierCurveTo(200 * s, -400 * s + d, 300 * s, -100 * s + d, 300 * s, 0 * s + d);
			ctx.bezierCurveTo(300 * s, 140 * s + d, 200 * s, 250 * s + d, 0 * s, 250 * s + d);
			ctx.bezierCurveTo(-200 * s, 250 * s + d, -300 * s, 140 * s + d, -300 * s, 0 * s + d);

			// Connection flange
			ctx.moveTo(-160 * s, 230 * s + d);
			ctx.lineTo(-120 * s, 290 * s + d);
			ctx.lineTo(120 * s, 290 * s + d);
			ctx.lineTo(160 * s, 230 * s + d);
			ctx.bezierCurveTo(120 * s, 250 * s + d, -120 * s, 250 * s + d, -160 * s, 230 * s + d);
			break;

		case 'Ahmed S2':
			// Plate
			ctx.moveTo(-300 * s, 0 * s + d);
			ctx.bezierCurveTo(-300 * s, -100 * s + d, -200 * s, -400 * s + d, 0 * s, -400 * s + d);
			ctx.bezierCurveTo(200 * s, -400 * s + d, 300 * s, -100 * s + d, 300 * s, 0 * s + d);
			ctx.bezierCurveTo(300 * s, 140 * s + d, 200 * s, 250 * s + d, 0 * s, 250 * s + d);
			ctx.bezierCurveTo(-200 * s, 250 * s + d, -300 * s, 140 * s + d, -300 * s, 0 * s + d);

			// Connection flange
			ctx.moveTo(-160 * s, 230 * s + d);
			ctx.lineTo(-120 * s, 290 * s + d);
			ctx.lineTo(120 * s, 290 * s + d);
			ctx.lineTo(160 * s, 230 * s + d);
			ctx.bezierCurveTo(120 * s, 250 * s + d, -120 * s, 250 * s + d, -160 * s, 230 * s + d);
			break;
			
		case 'Ahmed S3':
			// Plate
			ctx.moveTo(-100 * s, 230 * s + d);
			ctx.lineTo(100 * s, 230 * s + d);
			ctx.lineTo(200 * s, 0 * s + d);
			ctx.lineTo(100 * s, -230 * s + d);
			ctx.lineTo(-100 * s, -230 * s + d);
			ctx.lineTo(-200 * s, 0 * s + d);
			ctx.lineTo(-100 * s, 230 * s + d);
				
			// Connection flange
			ctx.moveTo(-100 * s, 230 * s + d);
			ctx.lineTo(-100 * s, 290 * s + d);
			ctx.lineTo(100 * s, 290 * s + d);
			ctx.lineTo(100 * s, 230 * s + d);
			ctx.bezierCurveTo(100 * s, 250 * s + d, -100 * s, 250 * s + d, -100 * s, 230 * s + d);
			break;

		case 'Baerveldt 103-250':
			// Plate
			ctx.moveTo(0, 230 * s + d);
			ctx.lineTo(-100 * s, 230 * s + d);
			ctx.bezierCurveTo(-500 * s, 180 * s + d, -300 * s, -240 * s + d, 0, -200 * s + d);
			ctx.bezierCurveTo(300 * s, -240 * s + d, 500 * s, 180 * s + d, 100 * s, 230 * s + d);
			ctx.lineTo(0, 230 * s + d);

			// Connection flange
			ctx.moveTo(-160 * s, 230 * s + d);
			ctx.lineTo(-120 * s, 290 * s + d);
			ctx.lineTo(120 * s, 290 * s + d);
			ctx.lineTo(160 * s, 230 * s + d);
			ctx.bezierCurveTo(120 * s, 250 * s + d, -120 * s, 250 * s + d, -160 * s, 230 * s + d);
			break;
			
		case 'Baerveldt 101-350':
			// Plate
			ctx.moveTo(0, 230 * s + d);
			ctx.lineTo(-100 * s, 230 * s + d);
			ctx.bezierCurveTo(-150 * s, 230 * s + d, -600 * s, 0 * s + d, -300 * s, -200 * s + d);
			ctx.bezierCurveTo(-200 * s, -240 * s + d, 200 * s, -240 * s + d, 300 * s, -200 * s + d);
			ctx.bezierCurveTo(600 * s, 0 * s + d, 150 * s, 230 * s + d, 100 * s, 230 * s + d);
			ctx.lineTo(0, 230 * s + d);

			// Connection flange
			ctx.moveTo(-160 * s, 230 * s + d);
			ctx.lineTo(-120 * s, 290 * s + d);
			ctx.lineTo(120 * s, 290 * s + d);
			ctx.lineTo(160 * s, 230 * s + d);
			ctx.bezierCurveTo(120 * s, 250 * s + d, -120 * s, 250 * s + d, -160 * s, 230 * s + d);
			break;
			
		case 'Baerveldt 103-350':
			// Plate
			ctx.moveTo(0, 230 * s + d);
			ctx.lineTo(-100 * s, 230 * s + d);
			ctx.bezierCurveTo(-150 * s, 230 * s + d, -600 * s, 0 * s + d, -300 * s, -200 * s + d);
			ctx.bezierCurveTo(-200 * s, -240 * s + d, 200 * s, -240 * s + d, 300 * s, -200 * s + d);
			ctx.bezierCurveTo(600 * s, 0 * s + d, 150 * s, 230 * s + d, 100 * s, 230 * s + d);
			ctx.lineTo(0, 230 * s + d);

			// Connection flange
			ctx.moveTo(-160 * s, 230 * s + d);
			ctx.lineTo(-120 * s, 290 * s + d);
			ctx.lineTo(120 * s, 290 * s + d);
			ctx.lineTo(160 * s, 230 * s + d);
			ctx.bezierCurveTo(120 * s, 250 * s + d, -120 * s, 250 * s + d, -160 * s, 230 * s + d);
			break;
						
		case 'Molteno Single':
			// Plate
			ctx.arc(0, d, 310 * s, 0, Math.PI * 2, true);
			break;
			
		case 'Molteno 8mm':
			// Plate
			ctx.arc(0, d + 30, 250 * s, 0, Math.PI * 2, true);
			break;
	}

	// Set Attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "rgba(120,120,120,0.75)";
	ctx.fillStyle = "rgba(220,220,220,0.5)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Extras
		switch (this.type) {
			case 'Ahmed FP7':
				// Spots
				this.drawSpot(ctx, 0 * s, -230 * s + d, 20 * s, "white");
				this.drawSpot(ctx, -180 * s, -180 * s + d, 20 * s, "white");
				this.drawSpot(ctx, 180 * s, -180 * s + d, 20 * s, "white");

				// Trapezoid mechanism
				ctx.beginPath()
				ctx.moveTo(-100 * s, 230 * s + d);
				ctx.lineTo(100 * s, 230 * s + d);
				ctx.lineTo(200 * s, 0 * s + d);
				ctx.lineTo(40 * s, 0 * s + d);
				ctx.arcTo(0, -540 * s + d, -40 * s, 0 * s + d, 15);
				ctx.lineTo(-40 * s, 0 * s + d);
				ctx.lineTo(-200 * s, 0 * s + d);
				ctx.closePath();
				ctx.fillStyle = "rgba(250,250,250,0.7)";
				ctx.fill();

				// Lines
				ctx.moveTo(-80 * s, -40 * s + d);
				ctx.lineTo(-160 * s, -280 * s + d);
				ctx.moveTo(80 * s, -40 * s + d);
				ctx.lineTo(160 * s, -280 * s + d);
				ctx.lineWidth = 8;
				ctx.strokeStyle = "rgba(250,250,250,0.7)";
				ctx.stroke();

				// Ridge on flange
				ctx.beginPath()
				ctx.moveTo(-30 * s, 250 * s + d);
				ctx.lineTo(-30 * s, 290 * s + d);
				ctx.moveTo(30 * s, 250 * s + d);
				ctx.lineTo(30 * s, 290 * s + d);			
				break;
				
			case 'Ahmed S2':
				// Trapezoid mechanism
				ctx.beginPath()
				ctx.moveTo(-100 * s, 230 * s + d);
				ctx.lineTo(100 * s, 230 * s + d);
				ctx.lineTo(200 * s, 0 * s + d);
				ctx.lineTo(-40 * s, 0 * s + d);
				ctx.lineTo(-200 * s, 0 * s + d);
				ctx.closePath();
				ctx.fillStyle = "rgba(250,250,250,0.7)";
				ctx.fill();

				// Line
				ctx.beginPath();
				ctx.moveTo(-280 * s, 0 * s + d);
				ctx.lineTo(+280 * s, 0 * s + d);
				ctx.lineWidth = 8;
				ctx.strokeStyle = "rgba(250,250,250,0.7)";
				ctx.stroke();		
				break;
				
			case 'Ahmed S3':
				// Trapezoid mechanism
				ctx.beginPath()
				ctx.moveTo(-100 * s, 230 * s + d);
				ctx.lineTo(100 * s, 230 * s + d);
				ctx.lineTo(200 * s, 0 * s + d);
				ctx.lineTo(-40 * s, 0 * s + d);
				ctx.lineTo(-200 * s, 0 * s + d);
				ctx.closePath();
				ctx.fillStyle = "rgba(250,250,250,0.7)";
				ctx.fill();	
				break;
											
			case 'Baerveldt 103-250':
				// Spots
 				this.drawSpot(ctx, -120 * s, 20 * s + d, 10, "rgba(150,150,150,0.5)");
				this.drawSpot(ctx, 120 * s, 20 * s + d, 10, "rgba(150,150,150,0.5)");

				// Ridge on flange
				ctx.beginPath();
				ctx.moveTo(-30 * s, 250 * s + d);
				ctx.lineTo(-30 * s, 290 * s + d);
				ctx.moveTo(30 * s, 250 * s + d);
				ctx.lineTo(30 * s, 290 * s + d);
				ctx.strokeStyle = "rgba(150,150,150,0.5)";
				ctx.stroke();
				break;
											
			case 'Baerveldt 101-350':
				// Spots
 				this.drawSpot(ctx, -120 * s, 20 * s + d, 10, "rgba(150,150,150,0.5)");
				this.drawSpot(ctx, 120 * s, 20 * s + d, 10, "rgba(150,150,150,0.5)");

				// Ridge on flange
				ctx.beginPath();
				ctx.moveTo(-30 * s, 250 * s + d);
				ctx.lineTo(-30 * s, 290 * s + d);
				ctx.moveTo(30 * s, 250 * s + d);
				ctx.lineTo(30 * s, 290 * s + d);
				ctx.strokeStyle = "rgba(150,150,150,0.5)";
				ctx.stroke();
				break;
											
			case 'Baerveldt 103-350':
				// Spots
 				this.drawSpot(ctx, -120 * s, 20 * s + d, 10, "rgba(150,150,150,0.5)");
				this.drawSpot(ctx, 120 * s, 20 * s + d, 10, "rgba(150,150,150,0.5)");

				// Ridge on flange
				ctx.beginPath();
				ctx.moveTo(-30 * s, 250 * s + d);
				ctx.lineTo(-30 * s, 290 * s + d);
				ctx.moveTo(30 * s, 250 * s + d);
				ctx.lineTo(30 * s, 290 * s + d);
				ctx.strokeStyle = "rgba(150,150,150,0.5)";
				ctx.stroke();
				break;
												
		case 'Molteno Single':				
				// Inner ring
				ctx.beginPath();
				ctx.arc(0, d, 250 * s, 0, Math.PI * 2, true);
				ctx.stroke();

				// Suture holes
				this.drawSpot(ctx, -200 * s, 200 * s + d, 5, "rgba(255,255,255,1)");
				this.drawSpot(ctx, -200 * s, -200 * s + d, 5, "rgba(255,255,255,1)");
				this.drawSpot(ctx, 200 * s, -200 * s + d, 5, "rgba(255,255,255,1)");
				this.drawSpot(ctx, 200 * s, 200 * s + d, 5, "rgba(255,255,255,1)");
				break;
				
		case 'Molteno 8mm':				
				// Inner ring
				ctx.beginPath();
				ctx.arc(0, d + 30, 200 * s, 0, Math.PI * 2, true);
				ctx.stroke();

				// Suture holes
				this.drawSpot(ctx, -160 * s, 160 * s + d + 30, 5, "rgba(255,255,255,1)");
				this.drawSpot(ctx, -160 * s, -160 * s + d + 30, 5, "rgba(255,255,255,1)");
				this.drawSpot(ctx, 160 * s, -160 * s + d + 30, 5, "rgba(255,255,255,1)");
				this.drawSpot(ctx, 160 * s, 160 * s + d + 30, 5, "rgba(255,255,255,1)");
				break;
		}

		if (!this.tubeExtender) {
			// Bezier points for curve of tube in array to export to Supramid
			this.bezierArray['sp'] = new ED.Point(0, 380 * s + d);
			this.bezierArray['cp1'] = new ED.Point(0, 460 * s + d);
			this.bezierArray['ep'] = new ED.Point(this.apexX, this.apexY);
		
			// CP2 varies according to displacement from midline
			var apexPoint = new ED.Point(this.apexX, this.apexY);
			var angle = apexPoint.direction() < Math.PI?apexPoint.direction():(2 * Math.PI - apexPoint.direction());
			this.bezierArray['cp2'] = apexPoint.pointAtRadiusAndClockwiseAngle(300 * (1 + 1.5 * angle), angle * 0.2);
		
			// Path of tube
			ctx.beginPath();
			ctx.moveTo(0, 290 * s + d);
			ctx.lineTo(this.bezierArray['sp'].x, this.bezierArray['sp'].y);		
			ctx.bezierCurveTo(this.bezierArray['cp1'].x, this.bezierArray['cp1'].y, this.bezierArray['cp2'].x, this.bezierArray['cp2'].y, this.bezierArray['ep'].x, this.bezierArray['ep'].y);
		}
		else {
			ctx.beginPath();
			ctx.moveTo(0, 290 * s + d);
			ctx.lineTo(0, 480 * s + d);
		}
		
		// Simulate tube with gray line and white narrower line
		ctx.strokeStyle = "rgba(150,150,150,0.5)";
		ctx.lineWidth = 20;
		ctx.stroke();
		ctx.strokeStyle = "white";
		ctx.lineWidth = 8;
		ctx.stroke();
	}

	if (!this.tubeExtender) {
		// Coordinates of handles (in canvas plane)
		this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

		// Draw handles if selected
		if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);
	}
	
	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Tube.prototype.description = function() {
	var descArray = {
		STQ: 'superotemporal',
		SNQ: 'superonasal',
		INQ: 'inferonasal',
		ITQ: 'inferotemporal'
	};

	return this.type + " tube in the " + descArray[this.platePosition] + " quadrant";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * TubeExtender TubeExtender
 *
 * @class TubeExtender
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.TubeExtender = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "TubeExtender";

	// Derived parameters
	this.platePosition = 'STQ';

	// Other Parameters
	this.bezierArray = new Array();

	// Saved parameters
	this.savedParameterArray = ['apexX', 'apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.TubeExtender.prototype = new ED.Doodle;
ED.TubeExtender.prototype.constructor = ED.TubeExtender;
ED.TubeExtender.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.TubeExtender.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default dragging attributes
 */
ED.TubeExtender.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = true;
	this.snapToAngles = true;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-600, -100);

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['platePosition'] = {
		kind: 'derived',
		type: 'string',
		list: ['STQ', 'SNQ', 'INQ', 'ITQ'],
		animate: true
	};

	// Array of angles to snap to
	var phi = Math.PI / 4;
	this.anglesArray = [phi, 3 * phi, 5 * phi, 7 * phi];
}

/**
 * Sets default parameters
 */
ED.TubeExtender.prototype.setParameterDefaults = function() {
	this.apexY = -300;
	this.setParameterFromString('platePosition', 'STQ');

	// Make rotation same as tube
	var doodle = this.drawing.lastDoodleOfClass("Tube");
	if (doodle) {
		this.rotation = doodle.rotation;
	}
}

/**
 * Calculates values of dependent parameters. This function embodies the relationship between simple and derived parameters
 * The returned parameters are animated if the 'animate' property in the parameterValidationArray is set to true
 *
 * @param {String} _parameter Name of parameter that has changed
 * @value {Undefined} _value Value of parameter to calculate
 * @returns {Array} Associative array of values of dependent parameters
 */
ED.TubeExtender.prototype.dependentParameterValues = function(_parameter, _value) {
	var returnArray = new Array();

	var isRE = (this.drawing.eye == ED.eye.Right);
	var phi = Math.PI / 4;

	switch (_parameter) {
		case 'rotation':
			if (this.rotation > 0 && this.rotation <= 2 * phi) {
				returnArray['platePosition'] = isRE ? 'SNQ' : 'STQ';
			} else if (this.rotation > 2 * phi && this.rotation <= 4 * phi) {
				returnArray['platePosition'] = isRE ? 'INQ' : 'ITQ';
			} else if (this.rotation > 4 * phi && this.rotation <= 6 * phi) {
				returnArray['platePosition'] = isRE ? 'ITQ' : 'INQ';
			} else {
				returnArray['platePosition'] = isRE ? 'STQ' : 'SNQ';
			}
			break;

		case 'platePosition':
			switch (_value) {
				case 'STQ':
					if (isRE) {
						returnArray['rotation'] = 7 * phi;
					} else {
						returnArray['rotation'] = phi;
					}
					break;
				case 'SNQ':
					if (isRE) {
						returnArray['rotation'] = phi;
					} else {
						returnArray['rotation'] = 7 * phi;
					}
					break;
				case 'INQ':
					if (isRE) {
						returnArray['rotation'] = 3 * phi;
					} else {
						returnArray['rotation'] = 5 * phi;
					}
					break;
				case 'ITQ':
					if (isRE) {
						returnArray['rotation'] = 5 * phi;
					} else {
						returnArray['rotation'] = 3 * phi;
					}
					break;
			}
			break;
	}

	return returnArray;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.TubeExtender.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// If a tube doodle exists, then sync with its' rotation
	var tubeDoodle = this.drawing.lastDoodleOfClass("Tube");
	if (tubeDoodle) {
		this.rotation = tubeDoodle.rotation;
	}

	// Call draw method in superclass
	ED.TubeExtender.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Scaling factor
	var s = 0.41666667;

	// Vertical shift (adjust to come up close to anterior edge of tube)
	var d = -680;

	// Plate
	this.roundRect(ctx, -160 * s, 200 * s + d, 320 * s, 200 * s, 40 * s);

	// Set Attributes
	ctx.lineWidth = 4;
	ctx.strokeStyle = "rgba(120,120,120,0.75)";
	ctx.fillStyle = "rgba(220,220,220,0.5)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Central structure
		ctx.beginPath();
		ctx.moveTo(0 * s, 180 * s + d);
  		ctx.lineTo(-30 * s, 180 * s + d);
  		ctx.quadraticCurveTo(-50 * s, 180 * s + d, -50 * s, 200 * s + d);
  		ctx.lineTo(-50 * s, 260 * s + d);
  		ctx.quadraticCurveTo(-100 * s, 300 * s + d, -50 * s, 340 * s + d);
   		ctx.lineTo(-50 * s, 400 * s + d);
   		ctx.quadraticCurveTo(-50 * s, 420 * s + d, -30 * s, 420 * s + d);
   		ctx.lineTo(0 * s, 420 * s + d);
   		ctx.lineTo(30 * s, 420 * s + d);
  		ctx.quadraticCurveTo(50 * s, 420 * s + d, 50 * s, 400 * s + d);
  		ctx.lineTo(50 * s, 340 * s + d);
  		ctx.quadraticCurveTo(100 * s, 300 * s + d, 50 * s, 260 * s + d);
  		ctx.lineTo(50 * s, 200 * s + d);
  		ctx.quadraticCurveTo(50 * s, 180 * s + d, 30 * s, 180 * s + d);
  		ctx.closePath();
		ctx.stroke();

		// Spots
		this.drawCircle(ctx, -120 * s, 300 * s + d, 20 * s, ctx.fillStyle, 4, ctx.strokeStyle);
		this.drawCircle(ctx, 120 * s, 300 * s + d, 20 * s, ctx.fillStyle, 4, ctx.strokeStyle);

		// Bezier points for curve of tube in array to export to Supramid
		this.bezierArray['sp'] = new ED.Point(0, 380 * s + d);
		this.bezierArray['cp1'] = new ED.Point(0, 460 * s + d);
		this.bezierArray['ep'] = new ED.Point(this.apexX, this.apexY);
	
		// CP2 varies according to displacement from midline
		var apexPoint = new ED.Point(this.apexX, this.apexY);
		var angle = apexPoint.direction() < Math.PI?apexPoint.direction():(2 * Math.PI - apexPoint.direction());
		this.bezierArray['cp2'] = apexPoint.pointAtRadiusAndClockwiseAngle(300 * (1 + 1.5 * angle), angle * 0.2);
	
		// Path of tube
		ctx.beginPath();
		ctx.moveTo(0, 290 * s + d);
		ctx.lineTo(this.bezierArray['sp'].x, this.bezierArray['sp'].y);		
		ctx.bezierCurveTo(this.bezierArray['cp1'].x, this.bezierArray['cp1'].y, this.bezierArray['cp2'].x, this.bezierArray['cp2'].y, this.bezierArray['ep'].x, this.bezierArray['ep'].y);
			
		// Simulate tube with gray line and white narrower line
		ctx.strokeStyle = "rgba(150,150,150,0.5)";
		ctx.lineWidth = 20;
		ctx.stroke();
		ctx.strokeStyle = "white";
		ctx.lineWidth = 8;
		ctx.stroke();
	}

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.TubeExtender.prototype.description = function() {
	return "Tube extender present";
}

/**
 * Draws a rounded rectangle using the current state of the canvas. ***TODO*** move to core
 * If you omit the last three params, it will draw a rectangle
 * outline with a 5 pixel border radius
 * @param {CanvasRenderingContext2D} ctx
 * @param {Number} x The top left x coordinate
 * @param {Number} y The top left y coordinate
 * @param {Number} width The width of the rectangle
 * @param {Number} height The height of the rectangle
 * @param {Number} radius The corner radius. Defaults to 5;
 */
ED.TubeExtender.prototype.roundRect = function(ctx, x, y, width, height, radius) {
	if (typeof radius === "undefined") {
	radius = 5;
	}
	ctx.beginPath();
	ctx.moveTo(x + radius, y);
	ctx.lineTo(x + width - radius, y);
	ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
	ctx.lineTo(x + width, y + height - radius);
	ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
	ctx.lineTo(x + radius, y + height);
	ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
	ctx.lineTo(x, y + radius);
	ctx.quadraticCurveTo(x, y, x + radius, y);
	ctx.closePath();
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * TubeLigation suture
 *
 * @class TubeLigation
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.TubeLigation = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "TubeLigation";

	// Derived parameters
	this.material = 'Vicryl';

	// Parameters in doodle control bar (parameter name: parameter label)
	this.controlParameterArray = {'material':'Material'};

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'rotation', 'material'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.TubeLigation.prototype = new ED.Doodle;
ED.TubeLigation.prototype.constructor = ED.TubeLigation;
ED.TubeLigation.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.TubeLigation.prototype.setPropertyDefaults = function() {
	this.isOrientated = true;
	this.isRotatable = false;

	// Add complete validation arrays for derived parameters
	this.parameterValidationArray['material'] = {
		kind: 'derived',
		type: 'string',
		list: ['10/0 Nylon', 'Vicryl', 'Prolene'],
		animate: false
	};
}

/**
 * Sets default parameters
 */
ED.TubeLigation.prototype.setParameterDefaults = function() {
	this.originX = -240;
	this.originY = -240;

	var isRE = (this.drawing.eye == ED.eye.Right);

	// Make rotation same as tube
	var doodle = this.drawing.lastDoodleOfClass("Tube");
	if (doodle) {
		switch (doodle.platePosition) {
			case 'STQ':
				if (isRE) {
					this.originX = -240;
					this.originY = -240;
					this.rotation = -Math.PI / 4;
				} else {
					this.originX = 240;
					this.originY = -240;
					this.rotation = Math.PI / 4;
				}
				break;
			case 'SNQ':
				if (isRE) {
					this.originX = 240;
					this.originY = -240;
					this.rotation = Math.PI / 4;
				} else {
					this.originX = -240;
					this.originY = -240;
					this.rotation = -Math.PI / 4;
				}
				break;
			case 'INQ':
				if (isRE) {
					this.originX = 240;
					this.originY = 240;
					this.rotation =  3 * Math.PI / 4;
				} else {
					this.originX = -240;
					this.originY = 240;
					this.rotation =  -3 * Math.PI / 4;
				}
				break;
			case 'ITQ':
				if (isRE) {
					this.originX = -240;
					this.originY = 240;
					this.rotation =  5 * Math.PI / 4;
				} else {
					this.originX = 240;
					this.originY = 240;
					this.rotation =  -5 * Math.PI / 4;
				}
				break;
		}
	}

	// If existing doodles, put in same meridian, but higher up
	var number = this.drawing.numberOfDoodlesOfClass(this.className);
	var doodle = this.drawing.firstDoodleOfClass(this.className);
	var xSign = doodle.originX > 0?1:-1;
	var ySign = doodle.originY > 0?1:-1;

	switch (number) {
		case 1:
			this.originX = 400 * xSign;
			this.originY = 400 * ySign;
			break;
		case 2:
			this.originX = 320 * xSign;
			this.originY = 320 * ySign;
			break;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.TubeLigation.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.TubeLigation.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Use arcTo to create an ellipsoid
	ctx.moveTo(-20, 0);
	ctx.arcTo(0, -20, 20, 0, 30);
	ctx.arcTo(0, 20, -20, 0, 30);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "purple";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Ends of suture
		ctx.beginPath();
		ctx.moveTo(35, -10);
		ctx.lineTo(20, 0);
		ctx.lineTo(35, 10);
		ctx.stroke();

		// Knot
		this.drawSpot(ctx, 20, 0, 4, "purple");
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a String which, if not empty, determines the root descriptions of multiple instances of the doodle
 *
 * @returns {String} Group description
 */
ED.TubeLigation.prototype.groupDescription = function() {
	var returnString = "";

	var number = this.drawing.numberOfDoodlesOfClass(this.className);
	returnString = number + " ligation suture";

	if (number > 1) returnString += "s";

	return returnString;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * 'U' tear
 *
 * @class UTear
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.UTear = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "UTear";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.UTear.prototype = new ED.Doodle;
ED.UTear.prototype.constructor = ED.UTear;
ED.UTear.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.UTear.prototype.setHandles = function() {
	this.handleArray[3] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.UTear.prototype.setPropertyDefaults = function() {
	this.isOrientated = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-40, +30);
}

/**
 * Sets default parameters (Only called for new doodles)
 * Use the setParameter function for derived parameters, as this will also update dependent variables
 */
ED.UTear.prototype.setParameterDefaults = function() {
	this.apexY = -20;
	this.cachedClockHour = undefined;

	var doodle = this.drawing.lastDoodleOfClass(this.className);
	if (doodle) {
		var p = new ED.Point(doodle.originX, doodle.originY);

		var np = new ED.Point(0, 0);
		np.setWithPolars(p.length(), p.direction() + Math.PI / 6);

		this.move(np.x, np.y);
	} else {
		this.move((this.drawing.eye == ED.eye.Right ? -1 : 1) * 200, -300);
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.UTear.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.UTear.superclass.draw.call(this, _point);
    // Boundary path
	ctx.beginPath();

	// U tear
	ctx.moveTo(0, 40);
	ctx.bezierCurveTo(-20, 40, -40, -20, -40, -40);
	ctx.bezierCurveTo(-40, -60, -20, this.apexY, 0, this.apexY);
	ctx.bezierCurveTo(20, this.apexY, 40, -60, 40, -40);
	ctx.bezierCurveTo(40, -20, 20, 40, 0, 40);

	// Close path
	ctx.closePath();

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "red";
	ctx.strokeStyle = "blue";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);
	// Coordinates of handles (in canvas plane)
	this.handleArray[3].location = this.transform.transformPoint(new ED.Point(40, -40));
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Calculate arc (Arc property not used naturally in this doodle)
	this.leftExtremity = this.transform.transformPoint(new ED.Point(-40, -40));
	this.rightExtremity = this.transform.transformPoint(new ED.Point(40, -40));
	this.arc = this.calculateArc();
	this.cachedClockHour = this.clockHour();
	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.UTear.prototype.groupDescription = function() {
	return "'U' tear at ";
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.UTear.prototype.description = function() {
	return this.cachedClockHour;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.UTear.prototype.groupDescriptionEnd = function() {
	return " o'clock";
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.UTear.prototype.snomedCode = function() {
	return 247168006;
}

/**
 * Returns a number indicating position in a hierarchy of diagnoses from 0 to 9 (highest)
 *
 * @returns {Int} Position in diagnostic hierarchy
 */
ED.UTear.prototype.diagnosticHierarchy = function() {
	return 6;
}


/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * Vicryl suture
 *
 * @class Vicryl
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.Vicryl = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "Vicryl";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY'];
	
	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.Vicryl.prototype = new ED.Doodle;
ED.Vicryl.prototype.constructor = ED.Vicryl;
ED.Vicryl.superclass = ED.Doodle.prototype;

/**
 * Sets default dragging attributes
 */
ED.Vicryl.prototype.setPropertyDefaults = function() {
	this.isOrientated = true;
	this.isRotatable = false;
}

/**
 * Sets default parameters
 */
ED.Vicryl.prototype.setParameterDefaults = function() {
	this.originY = -240;

	// Tubes are usually STQ
	if (this.drawing.eye == ED.eye.Right) {
		this.originX = -240;
		this.rotation = -Math.PI / 4;
	} else {
		this.originX = 240;
		this.rotation = Math.PI / 4;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.Vicryl.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.Vicryl.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Use arcTo to create an ellipsoid
	ctx.moveTo(-20, 0);
	ctx.arcTo(0, -20, 20, 0, 30);
	ctx.arcTo(0, 20, -20, 0, 30);

	// Set line attributes
	ctx.lineWidth = 4;
	ctx.fillStyle = "rgba(0, 0, 0, 0)";
	ctx.strokeStyle = "purple";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Ends of suture
		ctx.beginPath();
		ctx.moveTo(35, -10);
		ctx.lineTo(20, 0);
		ctx.lineTo(35, 10);
		ctx.stroke();

		// Knot
		this.drawSpot(ctx, 20, 0, 4, "purple");
	}

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.Vicryl.prototype.description = function() {
	return "Vicryl suture";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * ViewObscured template with disc and arcades
 *
 * @class ViewObscured
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.ViewObscured = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "ViewObscured";

	// Saved parameters
	this.savedParameterArray = ['apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.ViewObscured.prototype = new ED.Doodle;
ED.ViewObscured.prototype.constructor = ED.ViewObscured;
ED.ViewObscured.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.ViewObscured.prototype.setHandles = function() {
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.ViewObscured.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-100, +0);
}

/**
 * Sets default parameters
 */
ED.ViewObscured.prototype.setParameterDefaults = function() {
	this.apexY = -100;
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.ViewObscured.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.ViewObscured.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Radius of opacity
	var ro = 200;

	// Do a 360 arc
	 ctx.rect(-499, -499, 998, 998);

	// Opacity from apexY
	var opacity = 0.3 + 0.6 * (ro + 2 * this.apexY) / ro;
	ctx.fillStyle = "rgba(150, 150, 150," + opacity + ")";

	// Set attributes
	ctx.lineWidth = 0;
	ctx.strokeStyle = "rgba(150, 150, 150, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Coordinates of handles (in canvas plane)
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.ViewObscured.prototype.description = function() {
	var returnString;
	var endText;
	if (this.apexY < -50) {
		returnString = "Poor view of ";
		endText = "";
	}
	else {
		returnString =  "";
		endText = " obscured";
	}

	if (this.drawing.hasDoodleOfClass('PostPole')) {
		returnString += "Posterior pole";
	}
	else if (this.drawing.hasDoodleOfClass('Fundus')) {
		returnString += "Fundus";
	}
	else if (this.drawing.hasDoodleOfClass('OpticDisc')) {
		returnString += "Optic disc";
	}

	returnString += endText;

	return returnString;
}


/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * A Visual field
 *
 * @class VisualField
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.VisualField = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "VisualField";

	// Private parameters
	this.numberOfHandles = 8;

	// Blind spot x coordinate
	this.blindSpotX = 0;

	// Saved parameters
	this.savedParameterArray = ['apexY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.VisualField.prototype = new ED.Doodle;
ED.VisualField.prototype.constructor = ED.VisualField;
ED.VisualField.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.VisualField.prototype.setHandles = function() {
	// Array of handles for expert mode
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i] = new ED.Doodle.Handle(null, true, ED.Mode.Handles, false);
	}

	// Apex handle for basic mode
	this.handleArray[this.numberOfHandles] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Sets default properties
 */
ED.VisualField.prototype.setPropertyDefaults = function() {
	this.isMoveable = false;
	this.isRotatable = false;
	this.isDeletable = false;
	this.isUnique = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-320, -20);

	// Create ranges to constrain handles
	this.handleVectorRangeArray = new Array();
	for (var i = 0; i < this.numberOfHandles; i++) {
		// Full circle in radians
		var cir = 2 * Math.PI;

		// Create a range object for each handle
		var range = new Object;
		range.length = new ED.Range(+0, +400);
		range.angle = new ED.Range(((15 * cir / 16) + i * cir / 8) % cir, ((1 * cir / 16) + i * cir / 8) % cir);
		this.handleVectorRangeArray[i] = range;
	}
}

/**
 * Sets default parameters
 */
ED.VisualField.prototype.setParameterDefaults = function() {
	this.apexY = -40;

	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate with points around circumference
	var defaultPointsArray = [
		[0, -370],
		[300, -260],
		[400, 0],
		[300, 260],
		[0, 370],
		[-300, 260],
		[-400, 0],
		[-300, -260]
	];
	for (var i = 0; i < this.numberOfHandles; i++) {
		var coordArray = defaultPointsArray[i];
		var point = new ED.Point(coordArray[0], coordArray[1]);
		this.addPointToSquiggle(point);
	}

	// Adjust for eye
	if (this.drawing.eye == ED.eye.Right) {
		this.squiggleArray[0].pointsArray[3].x = 220;
		this.squiggleArray[0].pointsArray[3].y = 170;
		this.blindSpotX = -120;
	} else {
		this.squiggleArray[0].pointsArray[5].x = -220;
		this.squiggleArray[0].pointsArray[5].y = 170;
		this.blindSpotX = +120;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.VisualField.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.VisualField.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Bezier points
	var fp;
	var tp;
	var cp1;
	var cp2;

	// Angle of control point from radius line to point (this value makes path a circle Math.PI/12 for 8 points
	var phi = 2 * Math.PI / (3 * this.numberOfHandles);

	// Start curve
	ctx.moveTo(this.squiggleArray[0].pointsArray[0].x, this.squiggleArray[0].pointsArray[0].y);

	// Complete curve segments
	for (var i = 0; i < this.numberOfHandles; i++) {
		// From and to points
		fp = this.squiggleArray[0].pointsArray[i];
		var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
		tp = this.squiggleArray[0].pointsArray[toIndex];

		// Bezier or straight depending on distance from centre
		if (fp.length() < 100 || tp.length() < 100) {
			ctx.lineTo(tp.x, tp.y);
		} else {
			// Control points
			cp1 = fp.tangentialControlPoint(+phi);
			cp2 = tp.tangentialControlPoint(-phi);

			// Draw Bezier curve
			ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);
		}
	}


	// Blind spot
	ctx.moveTo(this.blindSpotX - this.apexY, 0);
	ctx.arc(this.blindSpotX, 0, -this.apexY, 0, Math.PI * 2, true);

	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 2;
	ctx.fillStyle = "lightGray";
	ctx.strokeStyle = "black";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary drawing
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {
		// Axis lines
		ctx.beginPath();
		ctx.moveTo(0, -450);
		ctx.lineTo(0, 450);
		ctx.moveTo(-450, 0);
		ctx.lineTo(450, 0);
		ctx.lineWidth = 8;
		ctx.strokeStyle = "black";
		ctx.stroke();
	}

	// Coordinates of expert handles (in canvas plane)
	for (var i = 0; i < this.numberOfHandles; i++) {
		this.handleArray[i].location = this.transform.transformPoint(this.squiggleArray[0].pointsArray[i]);
	}

	// Location of apex handle
	this.handleArray[this.numberOfHandles].location = this.transform.transformPoint(new ED.Point(this.blindSpotX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.VisualField.prototype.description = function() {
	return "";
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * A Visual field chart
 *
 * @class VisualFieldChart
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.VisualFieldChart = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "VisualFieldChart";

	// Private parameters
	this.numberOfHandles = 8;

	// Blind spot x coordinate
	this.blindSpotX = 0;

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.VisualFieldChart.prototype = new ED.Doodle;
ED.VisualFieldChart.prototype.constructor = ED.VisualFieldChart;
ED.VisualFieldChart.superclass = ED.Doodle.prototype;

/**
 * Sets default properties
 */
ED.VisualFieldChart.prototype.setPropertyDefaults = function() {
	this.isSelectable = false;
}

/**
 * Sets default parameters
 */
ED.VisualFieldChart.prototype.setParameterDefaults = function() {
	// Create a squiggle to store the handles points
	var squiggle = new ED.Squiggle(this, new ED.Colour(100, 100, 100, 1), 4, true);

	// Add it to squiggle array
	this.squiggleArray.push(squiggle);

	// Populate with points around circumference
	var defaultPointsArray = [
		[0, -370],
		[300, -260],
		[400, 0],
		[300, 260],
		[0, 370],
		[-300, 260],
		[-400, 0],
		[-300, -260]
	];
	for (var i = 0; i < this.numberOfHandles; i++) {
		var coordArray = defaultPointsArray[i];
		var point = new ED.Point(coordArray[0], coordArray[1]);
		this.addPointToSquiggle(point);
	}

	// Adjust for eye
	if (this.drawing.eye == ED.eye.Right) {
		this.squiggleArray[0].pointsArray[3].x = 220;
		this.squiggleArray[0].pointsArray[3].y = 170;
		this.blindSpotX = -120;
	} else {
		this.squiggleArray[0].pointsArray[5].x = -220;
		this.squiggleArray[0].pointsArray[5].y = 170;
		this.blindSpotX = +120;
	}
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.VisualFieldChart.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.VisualFieldChart.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Bezier points
	var fp;
	var tp;
	var cp1;
	var cp2;

	// Angle of control point from radius line to point (this value makes path a circle Math.PI/12 for 8 points
	var phi = 2 * Math.PI / (3 * this.numberOfHandles);

	// Start curve
	ctx.moveTo(this.squiggleArray[0].pointsArray[0].x, this.squiggleArray[0].pointsArray[0].y);

	// Complete curve segments
	for (var i = 0; i < this.numberOfHandles; i++) {
		// From and to points
		fp = this.squiggleArray[0].pointsArray[i];
		var toIndex = (i < this.numberOfHandles - 1) ? i + 1 : 0;
		tp = this.squiggleArray[0].pointsArray[toIndex];

		// Control points
		cp1 = fp.tangentialControlPoint(+phi);
		cp2 = tp.tangentialControlPoint(-phi);

		// Draw Bezier curve
		ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, tp.x, tp.y);
	}

	ctx.closePath();

	// Set attributes
	ctx.lineWidth = 2;
	ctx.fillStyle = "gray";
	ctx.strokeStyle = "black";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * OpenEyes
 *
 * Copyright (C) OpenEyes Foundation, 2011-2017
 * This file is part of OpenEyes.
 * OpenEyes is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * OpenEyes is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with OpenEyes in a file titled COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * @package OpenEyes
 * @link http://www.openeyes.org.uk
 * @author OpenEyes <info@openeyes.org.uk>
 * @copyright Copyright 2011-2017, OpenEyes Foundation
 * @license http://www.gnu.org/licenses/agpl-3.0.html The GNU Affero General Public License V3.0
 */

/**
 * VitreousOpacity template with disc and arcades
 *
 * @class VitreousOpacity
 * @property {String} className Name of doodle subclass
 * @param {Drawing} _drawing
 * @param {Object} _parameterJSON
 */
ED.VitreousOpacity = function(_drawing, _parameterJSON) {
	// Set classname
	this.className = "VitreousOpacity";

	// Saved parameters
	this.savedParameterArray = ['originX', 'originY', 'apexY', 'scaleX', 'scaleY'];

	// Call superclass constructor
	ED.Doodle.call(this, _drawing, _parameterJSON);
}

/**
 * Sets superclass and constructor
 */
ED.VitreousOpacity.prototype = new ED.Doodle;
ED.VitreousOpacity.prototype.constructor = ED.VitreousOpacity;
ED.VitreousOpacity.superclass = ED.Doodle.prototype;

/**
 * Sets handle attributes
 */
ED.VitreousOpacity.prototype.setHandles = function() {
	this.handleArray[2] = new ED.Doodle.Handle(null, true, ED.Mode.Scale, false);
	this.handleArray[4] = new ED.Doodle.Handle(null, true, ED.Mode.Apex, false);
}

/**
 * Set default properties
 */
ED.VitreousOpacity.prototype.setPropertyDefaults = function() {
	this.isRotatable = false;
	this.isSqueezable = true;

	// Update component of validation array for simple parameters
	this.parameterValidationArray['apexX']['range'].setMinAndMax(-0, +0);
	this.parameterValidationArray['apexY']['range'].setMinAndMax(-100, +0);
}

/**
 * Sets default parameters
 */
ED.VitreousOpacity.prototype.setParameterDefaults = function() {
	this.apexY = -100;
	this.setOriginWithDisplacements(0, -100);
}

/**
 * Draws doodle or performs a hit test if a Point parameter is passed
 *
 * @param {Point} _point Optional point in canvas plane, passed if performing hit test
 */
ED.VitreousOpacity.prototype.draw = function(_point) {
	// Get context
	var ctx = this.drawing.context;

	// Call draw method in superclass
	ED.VitreousOpacity.superclass.draw.call(this, _point);

	// Boundary path
	ctx.beginPath();

	// Boundary path
	ctx.beginPath();

	// Radius of opacity
	var ro = 200;

	// Do a 360 arc
	ctx.arc(0, 0, ro, 0, 2 * Math.PI, true);

	// Opacity from apexY
	var opacity = 0.3 + 0.6 * (ro + 2 * this.apexY) / ro;
	ctx.fillStyle = "rgba(255, 0, 0," + opacity + ")";

	// Set attributes
	ctx.lineWidth = 0;
	ctx.strokeStyle = "rgba(255, 0, 0, 0)";

	// Draw boundary path (also hit testing)
	this.drawBoundary(_point);

	// Non boundary paths
	if (this.drawFunctionMode == ED.drawFunctionMode.Draw) {}

	// Coordinates of handles (in canvas plane)
	point = new ED.Point(0, 0);
	point.setWithPolars(ro, Math.PI / 4);
	this.handleArray[2].location = this.transform.transformPoint(point);
	this.handleArray[4].location = this.transform.transformPoint(new ED.Point(this.apexX, this.apexY));

	// Draw handles if selected
	if (this.isSelected && !this.isForDrawing) this.drawHandles(_point);

	// Return value indicating successful hittest
	return this.isClicked;
}

/**
 * Returns a string containing a text description of the doodle
 *
 * @returns {String} Description of doodle
 */
ED.VitreousOpacity.prototype.description = function() {
	return "Vitreous haemorrhage";
}

/**
 * Returns the SnoMed code of the doodle
 *
 * @returns {Int} SnoMed code of entity representated by doodle
 */
ED.VitreousOpacity.prototype.snomedCode = function() {
	return 31341008;
}
